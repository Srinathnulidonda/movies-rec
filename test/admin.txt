1. # admin/__init__.py

from .routes import admin_bp, init_admin_routes
from .service import AdminNotificationService, AdminEmailService
from .dashboard import AdminDashboard
from .telegram import TelegramAdminService, TelegramService

def init_admin(app, db, models, services):
    """Initialize admin system"""
    
    # Initialize routes with existing models
    init_admin_routes(app, db, models, services)
    
    return models

__all__ = [
    'admin_bp',
    'init_admin',
    'AdminNotificationService',
    'AdminEmailService',
    'AdminDashboard',
    'TelegramAdminService',
    'TelegramService'
]
__version__ = '3.0.0'



2. # admin/dashboard.py

from datetime import datetime, timedelta
from sqlalchemy import func, desc, and_, or_
from collections import defaultdict
import json
import logging
import os

logger = logging.getLogger(__name__)

class AdminDashboard:
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.Content = models['Content']
        self.UserInteraction = models['UserInteraction']
        self.AdminRecommendation = models['AdminRecommendation']
        
        # Support models (optional)
        self.SupportTicket = models.get('SupportTicket')
        self.SupportCategory = models.get('SupportCategory')
        self.TicketActivity = models.get('TicketActivity')
        self.ContactMessage = models.get('ContactMessage')
        self.IssueReport = models.get('IssueReport')
        self.Feedback = models.get('Feedback')
        
        self.cache = services.get('cache')
        self.redis_client = services.get('redis_client')
        
        # Service references
        self.TMDBService = services.get('TMDBService')
        self.JikanService = services.get('JikanService')
    
    def get_overview(self):
        """Get admin dashboard overview"""
        try:
            overview_data = {
                'timestamp': datetime.utcnow().isoformat(),
                'general_stats': self._get_general_stats(),
                'recent_activity': self._get_recent_activity(),
                'quick_actions': self._get_quick_actions(),
                'alerts': self._get_alerts()
            }
            
            # Add support stats if available
            if self.SupportTicket:
                overview_data['support_overview'] = self._get_support_overview()
            
            return overview_data
            
        except Exception as e:
            logger.error(f"Error getting dashboard overview: {e}")
            return {'error': 'Failed to load dashboard overview'}
    
    def _get_general_stats(self):
        """Get general system statistics"""
        try:
            total_users = self.User.query.count()
            total_content = self.Content.query.count()
            total_interactions = self.UserInteraction.query.count()
            
            # Active users in last 7 days
            week_ago = datetime.utcnow() - timedelta(days=7)
            active_users = self.User.query.filter(
                self.User.last_active >= week_ago
            ).count()
            
            # New users in last 30 days
            month_ago = datetime.utcnow() - timedelta(days=30)
            new_users = self.User.query.filter(
                self.User.created_at >= month_ago
            ).count()
            
            # Popular content types
            content_types = self.db.session.query(
                self.Content.content_type,
                func.count(self.Content.id).label('count')
            ).group_by(self.Content.content_type).all()
            
            return {
                'total_users': total_users,
                'total_content': total_content,
                'total_interactions': total_interactions,
                'active_users_week': active_users,
                'new_users_month': new_users,
                'content_distribution': [
                    {'type': ct.content_type, 'count': ct.count}
                    for ct in content_types
                ]
            }
            
        except Exception as e:
            logger.error(f"Error getting general stats: {e}")
            return {}
    
    def _get_recent_activity(self):
        """Get recent system activity"""
        try:
            # Recent content added
            recent_content = self.Content.query.order_by(
                self.Content.created_at.desc()
            ).limit(5).all()
            
            # Recent user registrations
            recent_users = self.User.query.order_by(
                self.User.created_at.desc()
            ).limit(5).all()
            
            # Recent admin recommendations
            recent_recommendations = self.AdminRecommendation.query.filter_by(
                is_active=True
            ).order_by(self.AdminRecommendation.created_at.desc()).limit(5).all()
            
            return {
                'recent_content': [
                    {
                        'id': content.id,
                        'title': content.title,
                        'type': content.content_type,
                        'rating': content.rating,
                        'created_at': content.created_at.isoformat()
                    }
                    for content in recent_content
                ],
                'recent_users': [
                    {
                        'id': user.id,
                        'username': user.username,
                        'email': user.email,
                        'created_at': user.created_at.isoformat()
                    }
                    for user in recent_users
                ],
                'recent_recommendations': [
                    {
                        'id': rec.id,
                        'content_title': self.Content.query.get(rec.content_id).title if self.Content.query.get(rec.content_id) else 'Unknown',
                        'type': rec.recommendation_type,
                        'admin_name': self.User.query.get(rec.admin_id).username if self.User.query.get(rec.admin_id) else 'Unknown',
                        'created_at': rec.created_at.isoformat()
                    }
                    for rec in recent_recommendations
                ]
            }
            
        except Exception as e:
            logger.error(f"Error getting recent activity: {e}")
            return {}
    
    def _get_quick_actions(self):
        """Get quick actions for admin"""
        return [
            {
                'title': 'Add Content',
                'description': 'Search and add new movies, shows, or anime',
                'url': '/admin/content/search',
                'icon': 'ðŸŽ¬'
            },
            {
                'title': 'Create Recommendation',
                'description': 'Share your picks with users',
                'url': '/admin/recommendations/create',
                'icon': 'â­'
            },
            {
                'title': 'View Analytics',
                'description': 'Check detailed platform analytics',
                'url': '/admin/analytics',
                'icon': 'ðŸ“Š'
            },
            {
                'title': 'Support Center',
                'description': 'Manage tickets and user feedback',
                'url': '/admin/support',
                'icon': 'ðŸŽ§'
            }
        ]
    
    def _get_alerts(self):
        """Get system alerts and notifications"""
        alerts = []
        
        try:
            # Check for urgent tickets if support system is available
            if self.SupportTicket:
                try:
                    from support.tickets import TicketStatus, TicketPriority
                    
                    urgent_tickets = self.SupportTicket.query.filter(
                        and_(
                            self.SupportTicket.priority == TicketPriority.URGENT,
                            self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                        )
                    ).count()
                    
                    if urgent_tickets > 0:
                        alerts.append({
                            'type': 'urgent',
                            'title': f'{urgent_tickets} Urgent Tickets',
                            'message': f'{urgent_tickets} urgent support tickets need attention',
                            'action_url': '/admin/support/tickets?priority=urgent'
                        })
                    
                    # Check for SLA breaches
                    sla_breached = self.SupportTicket.query.filter(
                        and_(
                            self.SupportTicket.sla_breached == True,
                            self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                        )
                    ).count()
                    
                    if sla_breached > 0:
                        alerts.append({
                            'type': 'warning',
                            'title': f'{sla_breached} SLA Breaches',
                            'message': f'{sla_breached} tickets have exceeded their SLA deadline',
                            'action_url': '/admin/support/tickets?sla_breached=true'
                        })
                        
                except ImportError:
                    pass
            
            # Check for unread feedback
            if self.Feedback:
                unread_feedback = self.Feedback.query.filter_by(is_read=False).count()
                if unread_feedback > 5:
                    alerts.append({
                        'type': 'info',
                        'title': f'{unread_feedback} Unread Feedback',
                        'message': f'{unread_feedback} feedback messages are waiting for review',
                        'action_url': '/admin/support/feedback?unread_only=true'
                    })
            
            # Check system health
            if not self._check_external_apis():
                alerts.append({
                    'type': 'error',
                    'title': 'External API Issues',
                    'message': 'Some external APIs are not responding properly',
                    'action_url': '/admin/system-health'
                })
            
        except Exception as e:
            logger.error(f"Error getting alerts: {e}")
            alerts.append({
                'type': 'error',
                'title': 'Alert System Error',
                'message': 'Unable to check system alerts',
                'action_url': '/admin/system-health'
            })
        
        return alerts
    
    def _get_support_overview(self):
        """Get support system overview"""
        try:
            if not self.SupportTicket:
                return {'status': 'not_available'}
            
            today = datetime.utcnow().date()
            
            total_tickets = self.SupportTicket.query.count()
            today_tickets = self.SupportTicket.query.filter(
                func.date(self.SupportTicket.created_at) == today
            ).count()
            today_resolved = self.SupportTicket.query.filter(
                func.date(self.SupportTicket.resolved_at) == today
            ).count()
            
            try:
                from support.tickets import TicketStatus, TicketPriority
                
                open_tickets = self.SupportTicket.query.filter(
                    self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS, TicketStatus.WAITING_FOR_USER])
                ).count()
                
                urgent_tickets = self.SupportTicket.query.filter(
                    and_(
                        self.SupportTicket.priority == TicketPriority.URGENT,
                        self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                    )
                ).count()
                
            except ImportError:
                open_tickets = 0
                urgent_tickets = 0
            
            # Calculate average response time
            avg_response_time = self.db.session.query(
                func.avg(
                    func.extract('epoch', self.SupportTicket.first_response_at - self.SupportTicket.created_at) / 3600
                )
            ).filter(self.SupportTicket.first_response_at.isnot(None)).scalar() or 0
            
            return {
                'total_tickets': total_tickets,
                'open_tickets': open_tickets,
                'urgent_tickets': urgent_tickets,
                'today_created': today_tickets,
                'today_resolved': today_resolved,
                'avg_response_time_hours': round(avg_response_time, 2),
                'resolution_rate': round((today_resolved / max(today_tickets, 1)) * 100, 1)
            }
            
        except Exception as e:
            logger.error(f"Error getting support overview: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def get_analytics(self):
        """Get detailed analytics data"""
        try:
            return {
                'user_analytics': self._get_user_analytics(),
                'content_analytics': self._get_content_analytics(),
                'interaction_analytics': self._get_interaction_analytics(),
                'performance_metrics': self._get_performance_metrics(),
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Error getting analytics: {e}")
            return {'error': 'Failed to load analytics'}
    
    def _get_user_analytics(self):
        """Get user-related analytics"""
        try:
            # User growth over time
            user_growth = self.db.session.query(
                func.date(self.User.created_at).label('date'),
                func.count(self.User.id).label('count')
            ).group_by(func.date(self.User.created_at)).order_by('date').limit(30).all()
            
            # Active users trend
            active_users_trend = []
            for i in range(7):
                date = datetime.utcnow().date() - timedelta(days=i)
                count = self.User.query.filter(
                    func.date(self.User.last_active) == date
                ).count()
                active_users_trend.append({
                    'date': date.isoformat(),
                    'count': count
                })
            
            return {
                'user_growth': [
                    {'date': ug.date.isoformat(), 'count': ug.count}
                    for ug in user_growth
                ],
                'active_users_trend': active_users_trend,
                'total_users': self.User.query.count(),
                'active_today': self.User.query.filter(
                    func.date(self.User.last_active) == datetime.utcnow().date()
                ).count()
            }
            
        except Exception as e:
            logger.error(f"Error getting user analytics: {e}")
            return {}
    
    def _get_content_analytics(self):
        """Get content-related analytics"""
        try:
            # Popular content
            popular_content = self.db.session.query(
                self.Content.id, 
                self.Content.title, 
                func.count(self.UserInteraction.id).label('interaction_count')
            ).join(self.UserInteraction).group_by(
                self.Content.id, self.Content.title
            ).order_by(desc('interaction_count')).limit(10).all()
            
            # Genre popularity
            all_interactions = self.UserInteraction.query.join(self.Content).all()
            genre_counts = defaultdict(int)
            for interaction in all_interactions:
                content = self.Content.query.get(interaction.content_id)
                if content and content.genres:
                    try:
                        genres = json.loads(content.genres)
                        for genre in genres:
                            genre_counts[genre] += 1
                    except:
                        pass
            
            popular_genres = sorted(genre_counts.items(), key=lambda x: x[1], reverse=True)[:10]
            
            # Content type distribution
            content_types = self.db.session.query(
                self.Content.content_type,
                func.count(self.Content.id).label('count')
            ).group_by(self.Content.content_type).all()
            
            return {
                'popular_content': [
                    {'title': pc.title, 'interactions': pc.interaction_count}
                    for pc in popular_content
                ],
                'popular_genres': [
                    {'genre': genre, 'count': count}
                    for genre, count in popular_genres
                ],
                'content_distribution': [
                    {'type': ct.content_type, 'count': ct.count}
                    for ct in content_types
                ],
                'total_content': self.Content.query.count()
            }
            
        except Exception as e:
            logger.error(f"Error getting content analytics: {e}")
            return {}
    
    def _get_interaction_analytics(self):
        """Get user interaction analytics"""
        try:
            # Interaction types breakdown
            interaction_types = self.db.session.query(
                self.UserInteraction.interaction_type,
                func.count(self.UserInteraction.id).label('count')
            ).group_by(self.UserInteraction.interaction_type).all()
            
            # Daily interactions trend
            interaction_trend = []
            for i in range(7):
                date = datetime.utcnow().date() - timedelta(days=i)
                count = self.UserInteraction.query.filter(
                    func.date(self.UserInteraction.timestamp) == date
                ).count()
                interaction_trend.append({
                    'date': date.isoformat(),
                    'count': count
                })
            
            return {
                'interaction_types': [
                    {'type': it.interaction_type, 'count': it.count}
                    for it in interaction_types
                ],
                'daily_trend': interaction_trend,
                'total_interactions': self.UserInteraction.query.count()
            }
            
        except Exception as e:
            logger.error(f"Error getting interaction analytics: {e}")
            return {}
    
    def _get_performance_metrics(self):
        """Get system performance metrics"""
        try:
            # Cache statistics
            cache_stats = self.get_cache_stats()
            
            # Database statistics
            db_stats = {
                'total_tables': len(self.db.metadata.tables),
                'total_records': (
                    self.User.query.count() +
                    self.Content.query.count() +
                    self.UserInteraction.query.count()
                )
            }
            
            if self.SupportTicket:
                db_stats['total_records'] += self.SupportTicket.query.count()
            
            return {
                'cache_stats': cache_stats,
                'database_stats': db_stats,
                'external_apis': self._get_api_status()
            }
            
        except Exception as e:
            logger.error(f"Error getting performance metrics: {e}")
            return {}
    
    def _check_external_apis(self):
        """Check if external APIs are working"""
        try:
            # This is a simple check - in production you might want more sophisticated testing
            if self.TMDBService and self.JikanService:
                return True
            return False
        except:
            return False
    
    def _get_api_status(self):
        """Get external API status"""
        return {
            'tmdb': 'configured' if self.TMDBService else 'not_configured',
            'jikan': 'configured' if self.JikanService else 'not_configured'
        }
    
    def get_cache_stats(self):
        """Get cache statistics"""
        try:
            cache_info = {
                'type': self.app.config.get('CACHE_TYPE', 'unknown'),
                'default_timeout': self.app.config.get('CACHE_DEFAULT_TIMEOUT', 0),
            }
            
            if self.app.config.get('CACHE_TYPE') == 'redis':
                try:
                    import redis
                    REDIS_URL = self.app.config.get('CACHE_REDIS_URL')
                    if REDIS_URL:
                        r = redis.from_url(REDIS_URL)
                        redis_info = r.info()
                        cache_info['redis'] = {
                            'used_memory': redis_info.get('used_memory_human', 'N/A'),
                            'connected_clients': redis_info.get('connected_clients', 0),
                            'total_commands_processed': redis_info.get('total_commands_processed', 0),
                            'uptime_in_seconds': redis_info.get('uptime_in_seconds', 0)
                        }
                except:
                    cache_info['redis'] = {'status': 'Unable to connect'}
            
            return cache_info
            
        except Exception as e:
            logger.error(f"Error getting cache stats: {e}")
            return {'error': str(e)}
    
    def get_system_health(self):
        """Get comprehensive system health status"""
        try:
            health_data = {
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'healthy',
                'components': {},
                'configuration': {
                    'telegram_bot': 'configured' if os.environ.get('TELEGRAM_BOT_TOKEN') else 'not_configured',
                    'telegram_channel': 'configured' if os.environ.get('TELEGRAM_CHANNEL_ID') else 'not_configured',
                    'telegram_admin_chat': 'configured' if os.environ.get('TELEGRAM_ADMIN_CHAT_ID') else 'not_configured',
                    'redis': 'configured' if os.environ.get('REDIS_URL') else 'not_configured'
                }
            }
            
            # Database health
            try:
                health_data['components']['database'] = {
                    'status': 'healthy',
                    'total_users': self.User.query.count(),
                    'total_content': self.Content.query.count(),
                    'total_interactions': self.UserInteraction.query.count()
                }
            except Exception as e:
                health_data['components']['database'] = {
                    'status': 'unhealthy',
                    'error': str(e)
                }
                health_data['status'] = 'degraded'
            
            # Cache health
            try:
                if self.cache:
                    self.cache.set('health_check', 'ok', timeout=10)
                    if self.cache.get('health_check') == 'ok':
                        health_data['components']['cache'] = {'status': 'healthy'}
                    else:
                        health_data['components']['cache'] = {'status': 'degraded'}
                        health_data['status'] = 'degraded'
                else:
                    health_data['components']['cache'] = {'status': 'not_configured'}
            except Exception as e:
                health_data['components']['cache'] = {'status': 'unhealthy', 'error': str(e)}
                health_data['status'] = 'degraded'
            
            # External APIs
            health_data['components']['external_apis'] = self._get_api_status()
            
            # Support system health
            if self.SupportTicket:
                try:
                    from support.tickets import TicketStatus
                    health_data['components']['support_system'] = {
                        'status': 'healthy',
                        'total_tickets': self.SupportTicket.query.count(),
                        'open_tickets': self.SupportTicket.query.filter(
                            self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                        ).count(),
                        'total_feedback': self.Feedback.query.count() if self.Feedback else 0
                    }
                except Exception as e:
                    health_data['components']['support_system'] = {
                        'status': 'error',
                        'error': str(e)
                    }
                    health_data['status'] = 'degraded'
            else:
                health_data['components']['support_system'] = {
                    'status': 'not_available'
                }
            
            return health_data
            
        except Exception as e:
            logger.error(f"System health check error: {e}")
            return {
                'status': 'unhealthy',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }
    
    # Support-specific dashboard methods
    def get_support_dashboard(self):
        """Get comprehensive support dashboard data"""
        try:
            if not self.SupportTicket:
                return {'error': 'Support system not available'}
            
            return {
                'ticket_stats': self._get_ticket_stats(),
                'metrics': self._get_support_metrics(),
                'category_breakdown': self._get_category_breakdown(),
                'priority_breakdown': self._get_priority_breakdown(),
                'recent_tickets': self._get_recent_tickets(),
                'feedback_stats': self._get_feedback_stats(),
                'recent_feedback': self._get_recent_feedback(),
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Support dashboard error: {e}")
            return {'error': 'Failed to load support dashboard'}
    
    def _get_ticket_stats(self):
        """Get ticket statistics"""
        try:
            today = datetime.utcnow().date()
            
            total_tickets = self.SupportTicket.query.count()
            today_tickets = self.SupportTicket.query.filter(
                func.date(self.SupportTicket.created_at) == today
            ).count()
            today_resolved = self.SupportTicket.query.filter(
                func.date(self.SupportTicket.resolved_at) == today
            ).count()
            
            try:
                from support.tickets import TicketStatus, TicketPriority
                
                open_tickets = self.SupportTicket.query.filter(
                    self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS, TicketStatus.WAITING_FOR_USER])
                ).count()
                
                urgent_tickets = self.SupportTicket.query.filter(
                    and_(
                        self.SupportTicket.priority == TicketPriority.URGENT,
                        self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                    )
                ).count()
                
                sla_breached = self.SupportTicket.query.filter(
                    and_(
                        self.SupportTicket.sla_breached == True,
                        self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                    )
                ).count()
                
            except ImportError:
                open_tickets = 0
                urgent_tickets = 0
                sla_breached = 0
            
            return {
                'total': total_tickets,
                'open': open_tickets,
                'urgent': urgent_tickets,
                'sla_breached': sla_breached,
                'today_created': today_tickets,
                'today_resolved': today_resolved
            }
            
        except Exception as e:
            logger.error(f"Error getting ticket stats: {e}")
            return {}
    
    def _get_support_metrics(self):
        """Get support performance metrics"""
        try:
            # Calculate average response time
            avg_response_time = self.db.session.query(
                func.avg(
                    func.extract('epoch', self.SupportTicket.first_response_at - self.SupportTicket.created_at) / 3600
                )
            ).filter(self.SupportTicket.first_response_at.isnot(None)).scalar() or 0
            
            today_tickets = self.SupportTicket.query.filter(
                func.date(self.SupportTicket.created_at) == datetime.utcnow().date()
            ).count()
            
            today_resolved = self.SupportTicket.query.filter(
                func.date(self.SupportTicket.resolved_at) == datetime.utcnow().date()
            ).count()
            
            return {
                'avg_response_time_hours': round(avg_response_time, 2),
                'resolution_rate': round((today_resolved / max(today_tickets, 1)) * 100, 1)
            }
            
        except Exception as e:
            logger.error(f"Error getting support metrics: {e}")
            return {}
    
    def _get_category_breakdown(self):
        """Get ticket category breakdown"""
        try:
            if not self.SupportCategory:
                return []
            
            category_stats = self.db.session.query(
                self.SupportCategory.name,
                func.count(self.SupportTicket.id).label('count')
            ).join(self.SupportTicket).group_by(self.SupportCategory.name).all()
            
            return [
                {'category': stat.name, 'count': stat.count} 
                for stat in category_stats
            ]
            
        except Exception as e:
            logger.error(f"Error getting category breakdown: {e}")
            return []
    
    def _get_priority_breakdown(self):
        """Get ticket priority breakdown"""
        try:
            from support.tickets import TicketStatus, TicketPriority
            
            priority_stats = self.db.session.query(
                self.SupportTicket.priority,
                func.count(self.SupportTicket.id).label('count')
            ).filter(
                self.SupportTicket.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
            ).group_by(self.SupportTicket.priority).all()
            
            return [
                {'priority': stat.priority.value if hasattr(stat.priority, 'value') else str(stat.priority), 'count': stat.count} 
                for stat in priority_stats
            ]
            
        except ImportError:
            return []
        except Exception as e:
            logger.error(f"Error getting priority breakdown: {e}")
            return []
    
    def _get_recent_tickets(self):
        """Get recent tickets for dashboard"""
        try:
            recent_tickets = self.SupportTicket.query.order_by(
                self.SupportTicket.created_at.desc()
            ).limit(10).all()
            
            tickets_data = []
            for ticket in recent_tickets:
                category = None
                if self.SupportCategory and ticket.category_id:
                    category = self.SupportCategory.query.get(ticket.category_id)
                
                tickets_data.append({
                    'id': ticket.id,
                    'ticket_number': ticket.ticket_number,
                    'subject': ticket.subject,
                    'user_name': ticket.user_name,
                    'priority': ticket.priority.value if hasattr(ticket, 'priority') and ticket.priority else 'normal',
                    'status': ticket.status.value if hasattr(ticket, 'status') and ticket.status else 'open',
                    'category': category.name if category else 'Unknown',
                    'created_at': ticket.created_at.isoformat(),
                    'is_sla_breached': ticket.sla_breached
                })
            
            return tickets_data
            
        except Exception as e:
            logger.error(f"Error getting recent tickets: {e}")
            return []
    
    def _get_feedback_stats(self):
        """Get feedback statistics"""
        try:
            if not self.Feedback:
                return {'total': 0, 'unread': 0}
            
            total_feedback = self.Feedback.query.count()
            unread_feedback = self.Feedback.query.filter_by(is_read=False).count()
            
            return {
                'total': total_feedback,
                'unread': unread_feedback
            }
            
        except Exception as e:
            logger.error(f"Error getting feedback stats: {e}")
            return {'total': 0, 'unread': 0}
    
    def _get_recent_feedback(self):
        """Get recent feedback for dashboard"""
        try:
            if not self.Feedback:
                return []
            
            recent_feedback = self.Feedback.query.order_by(
                self.Feedback.created_at.desc()
            ).limit(5).all()
            
            feedback_data = []
            for feedback in recent_feedback:
                feedback_data.append({
                    'id': feedback.id,
                    'subject': feedback.subject,
                    'user_name': feedback.user_name,
                    'feedback_type': feedback.feedback_type.value if hasattr(feedback, 'feedback_type') and feedback.feedback_type else 'general',
                    'rating': feedback.rating,
                    'is_read': feedback.is_read,
                    'created_at': feedback.created_at.isoformat()
                })
            
            return feedback_data
            
        except Exception as e:
            logger.error(f"Error getting recent feedback: {e}")
            return []
    
    # Additional dashboard methods for other admin functions
    def get_support_tickets(self, page, per_page, status, priority, category_id, search):
        """Get filtered support tickets"""
        try:
            if not self.SupportTicket:
                return {'error': 'Support system not available'}
            
            # Implementation would go here - similar to the original function
            # but moved to dashboard service for better organization
            
            return {'tickets': [], 'pagination': {}}
            
        except Exception as e:
            logger.error(f"Error getting support tickets: {e}")
            return {'error': 'Failed to get support tickets'}
    
    def get_feedback_list(self, page, per_page, feedback_type, is_read, search):
        """Get filtered feedback list"""
        try:
            if not self.Feedback:
                return {'error': 'Feedback system not available'}
            
            # Implementation would go here
            return {'feedback': [], 'pagination': {}}
            
        except Exception as e:
            logger.error(f"Error getting feedback list: {e}")
            return {'error': 'Failed to get feedback list'}
    
    def get_users_management(self, page, per_page, search):
        """Get users for management interface"""
        try:
            # Implementation would go here
            return {'users': [], 'pagination': {}}
            
        except Exception as e:
            logger.error(f"Error getting users management: {e}")
            return {'error': 'Failed to get users'}
    
    def get_content_management(self, page, per_page, content_type, search):
        """Get content for management interface"""
        try:
            # Implementation would go here
            return {'content': [], 'pagination': {}}
            
        except Exception as e:
            logger.error(f"Error getting content management: {e}")
            return {'error': 'Failed to get content'}

def init_dashboard_service(app, db, models, services):
    """Initialize dashboard service"""
    return AdminDashboard(app, db, models, services)



3. # admin/routes.py

from flask import Blueprint, request, jsonify
from datetime import datetime
import json
import logging
import jwt
from functools import wraps

logger = logging.getLogger(__name__)

admin_bp = Blueprint('admin', __name__)

# Global services - will be initialized by init_admin_routes
admin_service = None
dashboard_service = None
telegram_service = None
app = None
db = None
User = None
Content = None
UserInteraction = None
AdminRecommendation = None
cache = None

def get_user_from_token():
    """Extract user from JWT token"""
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return None
    
    token = auth_header.split(' ')[1]
    try:
        payload = jwt.decode(token, app.secret_key, algorithms=['HS256'])
        return User.query.get(payload.get('user_id'))
    except:
        return None

def require_admin(f):
    """Decorator for admin-only endpoints"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user = get_user_from_token()
        if not user or not getattr(user, 'is_admin', False):
            return jsonify({'error': 'Admin access required'}), 403
        return f(user, *args, **kwargs)
    return decorated_function

# Content Management Routes
@admin_bp.route('/api/admin/search', methods=['GET'])
@require_admin
def admin_search(current_user):
    """Search for content in external APIs"""
    try:
        query = request.args.get('query', '')
        source = request.args.get('source', 'tmdb')
        page = int(request.args.get('page', 1))
        
        if not query:
            return jsonify({'error': 'Query parameter required'}), 400
        
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        results = admin_service.search_external_content(query, source, page)
        return jsonify({'results': results}), 200
        
    except Exception as e:
        logger.error(f"Admin search error: {e}")
        return jsonify({'error': 'Search failed'}), 500

@admin_bp.route('/api/admin/content', methods=['POST'])
@require_admin
def save_external_content(current_user):
    """Save external content to database"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No content data provided'}), 400
        
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        result = admin_service.save_external_content(data)
        return jsonify(result), 201 if result.get('created') else 200
        
    except Exception as e:
        logger.error(f"Save content error: {e}")
        return jsonify({'error': 'Failed to process content'}), 500

# Admin Recommendations
@admin_bp.route('/api/admin/recommendations', methods=['POST'])
@require_admin
def create_admin_recommendation(current_user):
    """Create admin recommendation"""
    try:
        data = request.get_json()
        
        required_fields = ['content_id', 'recommendation_type', 'description']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields'}), 400
        
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        result = admin_service.create_recommendation(
            current_user, 
            data['content_id'],
            data['recommendation_type'],
            data['description']
        )
        
        return jsonify(result), 201
        
    except Exception as e:
        logger.error(f"Admin recommendation error: {e}")
        return jsonify({'error': 'Failed to create recommendation'}), 500

@admin_bp.route('/api/admin/recommendations', methods=['GET'])
@require_admin
def get_admin_recommendations(current_user):
    """Get admin recommendations"""
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        result = admin_service.get_recommendations(page, per_page)
        return jsonify(result), 200
        
    except Exception as e:
        logger.error(f"Get admin recommendations error: {e}")
        return jsonify({'error': 'Failed to get recommendations'}), 500

# Dashboard and Analytics Routes
@admin_bp.route('/api/admin/dashboard', methods=['GET'])
@require_admin
def get_admin_dashboard(current_user):
    """Get admin dashboard data"""
    try:
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        dashboard_data = dashboard_service.get_overview()
        return jsonify(dashboard_data), 200
        
    except Exception as e:
        logger.error(f"Dashboard error: {e}")
        return jsonify({'error': 'Failed to load dashboard'}), 500

@admin_bp.route('/api/admin/analytics', methods=['GET'])
@require_admin
def get_analytics(current_user):
    """Get detailed analytics"""
    try:
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        analytics_data = dashboard_service.get_analytics()
        return jsonify(analytics_data), 200
        
    except Exception as e:
        logger.error(f"Analytics error: {e}")
        return jsonify({'error': 'Failed to get analytics'}), 500

@admin_bp.route('/api/admin/system-health', methods=['GET'])
@require_admin
def get_system_health(current_user):
    """Get system health status"""
    try:
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        health_data = dashboard_service.get_system_health()
        return jsonify(health_data), 200
        
    except Exception as e:
        logger.error(f"System health check error: {e}")
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# Support Management Routes
@admin_bp.route('/api/admin/support/dashboard', methods=['GET'])
@require_admin
def get_support_dashboard(current_user):
    """Get support dashboard data"""
    try:
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        support_data = dashboard_service.get_support_dashboard()
        return jsonify(support_data), 200
        
    except Exception as e:
        logger.error(f"Support dashboard error: {e}")
        return jsonify({'error': 'Failed to load support dashboard'}), 500

@admin_bp.route('/api/admin/support/tickets', methods=['GET'])
@require_admin
def get_support_tickets(current_user):
    """Get support tickets list"""
    try:
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 20)), 100)
        status = request.args.get('status')
        priority = request.args.get('priority')
        category_id = request.args.get('category_id', type=int)
        search = request.args.get('search', '').strip()
        
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        tickets_data = dashboard_service.get_support_tickets(
            page, per_page, status, priority, category_id, search
        )
        return jsonify(tickets_data), 200
        
    except Exception as e:
        logger.error(f"Get support tickets error: {e}")
        return jsonify({'error': 'Failed to get support tickets'}), 500

@admin_bp.route('/api/admin/support/feedback', methods=['GET'])
@require_admin
def get_feedback_list(current_user):
    """Get feedback list"""
    try:
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 20)), 100)
        feedback_type = request.args.get('type')
        is_read = request.args.get('is_read')
        search = request.args.get('search', '').strip()
        
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        feedback_data = dashboard_service.get_feedback_list(
            page, per_page, feedback_type, is_read, search
        )
        return jsonify(feedback_data), 200
        
    except Exception as e:
        logger.error(f"Get feedback list error: {e}")
        return jsonify({'error': 'Failed to get feedback list'}), 500

# User Management Routes
@admin_bp.route('/api/admin/users', methods=['GET'])
@require_admin
def get_users_management(current_user):
    """Get users management data"""
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        search = request.args.get('search', '')
        
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        users_data = dashboard_service.get_users_management(page, per_page, search)
        return jsonify(users_data), 200
        
    except Exception as e:
        logger.error(f"Users management error: {e}")
        return jsonify({'error': 'Failed to get users'}), 500

# Content Management Routes
@admin_bp.route('/api/admin/content/manage', methods=['GET'])
@require_admin
def get_content_management(current_user):
    """Get content management data"""
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        content_type = request.args.get('type', 'all')
        search = request.args.get('search', '')
        
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        content_data = dashboard_service.get_content_management(
            page, per_page, content_type, search
        )
        return jsonify(content_data), 200
        
    except Exception as e:
        logger.error(f"Content management error: {e}")
        return jsonify({'error': 'Failed to get content'}), 500

# Notification Routes
@admin_bp.route('/api/admin/notifications', methods=['GET'])
@require_admin
def get_admin_notifications(current_user):
    """Get admin notifications"""
    try:
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 20)), 100)
        unread_only = request.args.get('unread_only', 'false').lower() == 'true'
        
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        notifications_data = admin_service.get_notifications(page, per_page, unread_only)
        return jsonify(notifications_data), 200
        
    except Exception as e:
        logger.error(f"Get admin notifications error: {e}")
        return jsonify({'error': 'Failed to get notifications'}), 500

@admin_bp.route('/api/admin/notifications/mark-all-read', methods=['PUT'])
@require_admin
def mark_all_notifications_read(current_user):
    """Mark all notifications as read"""
    try:
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        result = admin_service.mark_all_notifications_read()
        return jsonify(result), 200
        
    except Exception as e:
        logger.error(f"Mark all notifications read error: {e}")
        return jsonify({'error': 'Failed to mark all notifications as read'}), 500

# Cache Management Routes
@admin_bp.route('/api/admin/cache/clear', methods=['POST'])
@require_admin
def clear_cache(current_user):
    """Clear application cache"""
    try:
        cache_type = request.args.get('type', 'all')
        
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        result = admin_service.clear_cache(cache_type)
        return jsonify(result), 200
        
    except Exception as e:
        logger.error(f"Cache clear error: {e}")
        return jsonify({'error': 'Failed to clear cache'}), 500

@admin_bp.route('/api/admin/cache/stats', methods=['GET'])
@require_admin
def get_cache_stats(current_user):
    """Get cache statistics"""
    try:
        if not dashboard_service:
            return jsonify({'error': 'Dashboard service not available'}), 503
        
        cache_stats = dashboard_service.get_cache_stats()
        return jsonify(cache_stats), 200
        
    except Exception as e:
        logger.error(f"Cache stats error: {e}")
        return jsonify({'error': 'Failed to get cache stats'}), 500

# Slug Management Routes (moved from app.py)
@admin_bp.route('/api/admin/slugs/migrate', methods=['POST'])
@require_admin
def migrate_all_slugs(current_user):
    """Migrate all content slugs"""
    try:
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        data = request.get_json() or {}
        batch_size = int(data.get('batch_size', 50))
        
        result = admin_service.migrate_all_slugs(batch_size)
        
        return jsonify({
            'success': True,
            'migration_stats': result,
            'cinebrain_service': 'slug_migration'
        }), 200
        
    except Exception as e:
        logger.error(f"Error migrating slugs: {e}")
        return jsonify({'error': 'Failed to migrate slugs'}), 500

@admin_bp.route('/api/admin/content/<int:content_id>/slug', methods=['PUT'])
@require_admin
def update_content_slug(current_user, content_id):
    """Update content slug"""
    try:
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        data = request.get_json() or {}
        force_update = data.get('force_update', False)
        result = admin_service.update_content_slug(content_id, force_update)
        
        if result:
            return jsonify({
                'success': True,
                'new_slug': result,
                'cinebrain_service': 'slug_update'
            }), 200
        else:
            return jsonify({'error': 'Content not found or update failed'}), 404
            
    except Exception as e:
        logger.error(f"Error updating content slug: {e}")
        return jsonify({'error': 'Failed to update slug'}), 500

@admin_bp.route('/api/admin/populate-cast-crew', methods=['POST'])
@require_admin
def populate_all_cast_crew(current_user):
    """Populate cast and crew data"""
    try:
        if not admin_service:
            return jsonify({'error': 'Admin service not available'}), 503
        
        data = request.get_json() or {}
        batch_size = int(data.get('batch_size', 10))
        result = admin_service.populate_cast_crew(batch_size)
        
        return jsonify({
            'success': True,
            'processed': result.get('processed', 0),
            'errors': result.get('errors', 0),
            'message': f"Successfully populated cast/crew for {result.get('processed', 0)} content items",
            'cinebrain_service': 'cast_crew_population'
        }), 200
        
    except Exception as e:
        logger.error(f"Error in bulk cast/crew population: {e}")
        return jsonify({'error': 'Failed to populate cast/crew'}), 500

# Error Handlers
@admin_bp.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Admin endpoint not found'}), 404

@admin_bp.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error in admin service'}), 500

# CORS Headers
@admin_bp.after_request
def after_request(response):
    """Add CORS headers"""
    origin = request.headers.get('Origin')
    allowed_origins = [
        'https://cinebrain.vercel.app',
        'http://127.0.0.1:5500', 
        'http://127.0.0.1:5501',
        'http://localhost:3000',
        'http://localhost:5173'
    ]
    
    if origin in allowed_origins:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type,Authorization'
        response.headers['Access-Control-Allow-Methods'] = 'GET,PUT,POST,DELETE,OPTIONS'
        response.headers['Access-Control-Allow-Credentials'] = 'true'
    
    return response

# Initialization Function
def init_admin_routes(flask_app, database, models, services):
    """Initialize admin routes with dependencies"""
    global admin_service, dashboard_service, telegram_service
    global app, db, User, Content, UserInteraction, AdminRecommendation, cache
    
    app = flask_app
    db = database
    User = models.get('User')
    Content = models.get('Content')
    UserInteraction = models.get('UserInteraction')
    AdminRecommendation = models.get('AdminRecommendation')
    cache = services.get('cache')
    
    # Initialize individual services
    try:
        from .service import init_admin_service
        from .dashboard import init_dashboard_service
        from .telegram import init_telegram_service
        
        admin_service = init_admin_service(app, db, models, services)
        dashboard_service = init_dashboard_service(app, db, models, services)
        telegram_service = init_telegram_service(app, db, models, services)
        
        logger.info("âœ… Admin routes initialized successfully")
        logger.info(f"   - Admin service: {'âœ“' if admin_service else 'âœ—'}")
        logger.info(f"   - Dashboard service: {'âœ“' if dashboard_service else 'âœ—'}")
        logger.info(f"   - Telegram service: {'âœ“' if telegram_service else 'âœ—'}")
        
    except Exception as e:
        logger.error(f"âŒ Failed to initialize admin routes: {e}")
        raise e



4.# admin/service.py

import os
import json
import logging
import redis
import uuid
from datetime import datetime, timedelta
from urllib.parse import urlparse
from sqlalchemy import func, desc, and_, or_
from collections import defaultdict

logger = logging.getLogger(__name__)

# Redis Configuration
REDIS_URL = os.environ.get('REDIS_URL')

class NotificationType:
    """Notification types as constants to avoid enum issues"""
    NEW_TICKET = "new_ticket"
    URGENT_TICKET = "urgent_ticket"
    TICKET_ESCALATION = "ticket_escalation"
    SLA_BREACH = "sla_breach"
    FEEDBACK_RECEIVED = "feedback_received"
    SYSTEM_ALERT = "system_alert"
    USER_ACTIVITY = "user_activity"
    CONTENT_ADDED = "content_added"

class AdminEmailService:
    """Email service for admin notifications using auth email service"""
    
    def __init__(self, services):
        # Use the existing auth email service
        self.email_service = services.get('email_service')  # Brevo service from auth
        
        # Better fallback checking
        if not self.email_service:
            try:
                from auth.service import email_service as auth_email_service
                self.email_service = auth_email_service
                logger.info("âœ… Email service loaded from auth module for admin")
            except Exception as e:
                logger.warning(f"Could not load auth email service for admin: {e}")
        
        # Improved configuration check
        self.is_configured = (
            self.email_service is not None and 
            hasattr(self.email_service, 'email_enabled') and 
            self.email_service.email_enabled and
            hasattr(self.email_service, 'queue_email')
        )
        
        if self.is_configured:
            logger.info("âœ… Admin email service configured successfully with Brevo")
        else:
            logger.warning("âš ï¸ Admin email service not configured - using fallback mode")
    
    def send_admin_notification(self, subject: str, content: str, admin_emails: list, is_urgent: bool = False):
        """Send notification email to admins"""
        try:
            if not self.is_configured:
                logger.warning("Email service not configured, skipping admin email notification")
                return False
            
            if not admin_emails:
                logger.warning("No admin emails provided")
                return False
            
            # Import template function
            from auth.admin_mail_templates import get_admin_template
            
            html, text = get_admin_template(
                'admin_notification',
                subject=subject,
                content=content,
                is_urgent=is_urgent,
                timestamp=datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
            )
            
            # Send to each admin
            success_count = 0
            for email in admin_emails:
                try:
                    admin_name = email.split('@')[0].replace('.', ' ').title()
                    
                    self.email_service.queue_email(
                        to=email,
                        subject=f"[CineBrain Admin] {subject}",
                        html=html,
                        text=text,
                        priority='urgent' if is_urgent else 'high',
                        to_name=admin_name
                    )
                    success_count += 1
                    logger.info(f"âœ… Admin notification email queued for {email}: {subject}")
                except Exception as e:
                    logger.error(f"âŒ Failed to queue email for {email}: {e}")
            
            if success_count > 0:
                logger.info(f"âœ… Admin notification emails queued successfully: {subject} ({success_count}/{len(admin_emails)})")
                return True
            else:
                logger.error(f"âŒ Failed to queue any admin notification emails")
                return False
            
        except Exception as e:
            logger.error(f"âŒ Admin email error: {e}")
            return False

class AdminNotificationService:
    """Service for managing admin notifications"""
    
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.email_service = AdminEmailService(services)
        self.redis_client = self._init_redis()
        
        # Get admin models from the models dictionary instead of creating them
        self.AdminNotification = models.get('AdminNotification')
        self.CannedResponse = models.get('CannedResponse')
        self.SupportMetrics = models.get('SupportMetrics')
        
        # Validate model availability
        if not self.AdminNotification:
            logger.warning("âš ï¸ AdminNotification model not available")
        if not self.CannedResponse:
            logger.warning("âš ï¸ CannedResponse model not available")
        if not self.SupportMetrics:
            logger.warning("âš ï¸ SupportMetrics model not available")
        
        # Telegram service
        try:
            from admin.telegram import TelegramAdminService
            self.telegram_service = TelegramAdminService
        except ImportError:
            self.telegram_service = None
            logger.warning("Telegram service not available for admin notifications")
        
        logger.info("âœ… Admin notification service initialized")
    
    def _init_redis(self):
        """Initialize Redis connection for admin notifications"""
        try:
            if not REDIS_URL:
                logger.warning("Redis URL not configured for admin notifications")
                return None
            
            url = urlparse(REDIS_URL)
            redis_client = redis.StrictRedis(
                host=url.hostname,
                port=url.port,
                password=url.password,
                decode_responses=True,
                socket_connect_timeout=5,
                socket_timeout=5,
                retry_on_timeout=True,
                health_check_interval=30
            )
            redis_client.ping()
            logger.info("âœ… Admin Redis connected successfully")
            return redis_client
            
        except Exception as e:
            logger.error(f"âŒ Admin Redis connection failed: {e}")
            return None
    
    def create_notification(self, notification_type: str, title: str, message: str, 
                          admin_id: int = None, related_ticket_id: int = None, 
                          related_content_id: int = None, is_urgent: bool = False,
                          action_required: bool = False, action_url: str = None,
                          metadata: dict = None):
        """Create a new admin notification"""
        try:
            if not self.AdminNotification:
                logger.warning("AdminNotification model not available, skipping database notification")
                # Still proceed with other notification methods
            else:
                # Create database notification
                notification = self.AdminNotification(
                    notification_type=notification_type,
                    title=title,
                    message=message,
                    admin_id=admin_id,
                    related_ticket_id=related_ticket_id,
                    related_content_id=related_content_id,
                    is_urgent=is_urgent,
                    action_required=action_required,
                    action_url=action_url,
                    notification_metadata=metadata or {}
                )
                
                self.db.session.add(notification)
                self.db.session.commit()
                logger.info(f"âœ… Database notification created: {title}")
            
            # Send Telegram notification
            if self.telegram_service:
                try:
                    self.telegram_service.send_admin_notification(
                        notification_type, 
                        f"{title}\n\n{message}", 
                        is_urgent
                    )
                    logger.info(f"âœ… Telegram notification sent: {title}")
                except Exception as e:
                    logger.warning(f"Telegram notification failed: {e}")
            
            # Send email notification
            if self.email_service and self.email_service.is_configured:
                try:
                    # Get admin emails
                    admin_users = self.User.query.filter_by(is_admin=True).all()
                    admin_emails = [user.email for user in admin_users if user.email]
                    
                    # Also include environment variable admin email
                    env_admin_email = os.environ.get('ADMIN_EMAIL')
                    if env_admin_email and env_admin_email not in admin_emails:
                        admin_emails.append(env_admin_email)
                    
                    if admin_emails:
                        self.email_service.send_admin_notification(title, message, admin_emails, is_urgent)
                        logger.info(f"âœ… Email notifications sent to {len(admin_emails)} admins")
                except Exception as e:
                    logger.warning(f"Admin email notification failed: {e}")
            
            # Store in Redis for real-time updates
            if self.redis_client:
                try:
                    notification_data = {
                        'id': notification.id if self.AdminNotification else f"temp_{int(datetime.utcnow().timestamp())}",
                        'type': notification_type,
                        'title': title,
                        'message': message,
                        'is_urgent': is_urgent,
                        'action_required': action_required,
                        'action_url': action_url,
                        'timestamp': datetime.utcnow().isoformat()
                    }
                    self.redis_client.lpush('admin_notifications', json.dumps(notification_data))
                    self.redis_client.ltrim('admin_notifications', 0, 99)  # Keep last 100
                    self.redis_client.expire('admin_notifications', 86400)  # 24 hours
                    logger.info(f"âœ… Redis notification stored: {title}")
                except Exception as e:
                    logger.error(f"Redis notification error: {e}")
            
            logger.info(f"âœ… Admin notification created successfully: {title}")
            return notification if self.AdminNotification else True
            
        except Exception as e:
            logger.error(f"âŒ Error creating admin notification: {e}")
            if self.db:
                self.db.session.rollback()
            return None
    
    def notify_new_ticket(self, ticket):
        """Notify admins about new support ticket"""
        try:
            is_urgent = ticket.priority == 'urgent'
            
            self.create_notification(
                NotificationType.NEW_TICKET if not is_urgent else NotificationType.URGENT_TICKET,
                f"New {'Urgent ' if is_urgent else ''}Support Ticket",
                f"Ticket #{ticket.ticket_number} created by {ticket.user_name}\n"
                f"Subject: {ticket.subject}\n"
                f"Priority: {ticket.priority.upper()}\n"
                f"Category: {ticket.category.name if hasattr(ticket, 'category') and ticket.category else 'Unknown'}",
                related_ticket_id=ticket.id,
                is_urgent=is_urgent,
                action_required=True,
                action_url=f"/admin/support/tickets/{ticket.id}",
                metadata={
                    'ticket_number': ticket.ticket_number,
                    'priority': ticket.priority,
                    'user_email': ticket.user_email
                }
            )
            logger.info(f"âœ… New ticket notification sent for #{ticket.ticket_number}")
        except Exception as e:
            logger.error(f"âŒ Error notifying new ticket: {e}")
    
    def notify_sla_breach(self, ticket):
        """Notify admins about SLA breach"""
        try:
            self.create_notification(
                NotificationType.SLA_BREACH,
                f"SLA Breach - Ticket #{ticket.ticket_number}",
                f"Ticket #{ticket.ticket_number} has exceeded its SLA deadline\n"
                f"Created: {ticket.created_at.strftime('%Y-%m-%d %H:%M UTC')}\n"
                f"Deadline: {ticket.sla_deadline.strftime('%Y-%m-%d %H:%M UTC') if ticket.sla_deadline else 'N/A'}\n"
                f"Priority: {ticket.priority.upper()}",
                related_ticket_id=ticket.id,
                is_urgent=True,
                action_required=True,
                action_url=f"/admin/support/tickets/{ticket.id}",
                metadata={
                    'ticket_number': ticket.ticket_number,
                    'sla_deadline': ticket.sla_deadline.isoformat() if ticket.sla_deadline else None
                }
            )
            logger.info(f"âœ… SLA breach notification sent for #{ticket.ticket_number}")
        except Exception as e:
            logger.error(f"âŒ Error notifying SLA breach: {e}")
    
    def notify_feedback_received(self, feedback):
        """Notify admins about new feedback"""
        try:
            feedback_type = getattr(feedback, 'feedback_type', 'general')
            rating = getattr(feedback, 'rating', 0)
            
            self.create_notification(
                NotificationType.FEEDBACK_RECEIVED,
                "New User Feedback Received",
                f"Feedback from {feedback.user_name}\n"
                f"Type: {feedback_type.replace('_', ' ').title() if isinstance(feedback_type, str) else 'General'}\n"
                f"Subject: {feedback.subject}\n"
                f"Rating: {'â­' * rating if rating else 'No rating'}",
                action_required=False,
                action_url=f"/admin/support/feedback/{feedback.id}",
                metadata={
                    'feedback_type': feedback_type if isinstance(feedback_type, str) else 'general',
                    'user_email': feedback.user_email,
                    'rating': rating
                }
            )
            logger.info(f"âœ… Feedback notification sent for feedback #{feedback.id}")
        except Exception as e:
            logger.error(f"âŒ Error notifying feedback: {e}")
    
    def notify_system_alert(self, alert_type: str, title: str, details: str, is_urgent: bool = False):
        """Notify admins about system alerts"""
        try:
            self.create_notification(
                NotificationType.SYSTEM_ALERT,
                f"System Alert: {title}",
                f"Alert Type: {alert_type}\n"
                f"Details: {details}\n"
                f"Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}",
                is_urgent=is_urgent,
                action_required=True,
                action_url="/admin/system-health",
                metadata={
                    'alert_type': alert_type,
                    'timestamp': datetime.utcnow().isoformat()
                }
            )
            logger.info(f"âœ… System alert notification sent: {title}")
        except Exception as e:
            logger.error(f"âŒ Error notifying system alert: {e}")

class AdminService:
    """Main admin service for content and recommendation management"""
    
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.Content = models['Content']
        self.UserInteraction = models['UserInteraction']
        self.AdminRecommendation = models['AdminRecommendation']
        
        # Get admin models from models dictionary
        self.AdminNotification = models.get('AdminNotification')
        self.CannedResponse = models.get('CannedResponse')
        self.SupportMetrics = models.get('SupportMetrics')
        
        self.TMDBService = services.get('TMDBService')
        self.JikanService = services.get('JikanService')
        self.ContentService = services.get('ContentService')
        self.cache = services.get('cache')
        
        # Telegram service for recommendations
        try:
            from admin.telegram import TelegramService
            self.telegram_service = TelegramService
        except ImportError:
            self.telegram_service = None
        
        # Notification service
        self.notification_service = AdminNotificationService(app, db, models, services)
        
        logger.info("âœ… Admin service initialized")
    
    def search_external_content(self, query: str, source: str, page: int = 1):
        """Search for content in external APIs"""
        try:
            results = []
            
            if source == 'tmdb':
                tmdb_results = self.TMDBService.search_content(query, page=page)
                if tmdb_results:
                    for item in tmdb_results.get('results', []):
                        results.append({
                            'id': item['id'],
                            'title': item.get('title') or item.get('name'),
                            'content_type': 'movie' if 'title' in item else 'tv',
                            'release_date': item.get('release_date') or item.get('first_air_date'),
                            'poster_path': f"https://image.tmdb.org/t/p/w300{item['poster_path']}" if item.get('poster_path') else None,
                            'overview': item.get('overview'),
                            'rating': item.get('vote_average'),
                            'source': 'tmdb'
                        })
            
            elif source == 'anime':
                anime_results = self.JikanService.search_anime(query, page=page)
                if anime_results:
                    for anime in anime_results.get('data', []):
                        results.append({
                            'id': anime['mal_id'],
                            'title': anime.get('title'),
                            'content_type': 'anime',
                            'release_date': anime.get('aired', {}).get('from'),
                            'poster_path': anime.get('images', {}).get('jpg', {}).get('image_url'),
                            'overview': anime.get('synopsis'),
                            'rating': anime.get('score'),
                            'source': 'anime'
                        })
            
            logger.info(f"âœ… External content search completed: {len(results)} results for '{query}'")
            return results
            
        except Exception as e:
            logger.error(f"External search error: {e}")
            return []
    
    def save_external_content(self, data):
        """Save external content to database"""
        try:
            # Check if content already exists
            existing_content = None
            
            if data.get('source') == 'anime' and data.get('id'):
                mal_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                existing_content = self.Content.query.filter_by(mal_id=mal_id).first()
            elif data.get('id'):
                tmdb_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                existing_content = self.Content.query.filter_by(tmdb_id=tmdb_id).first()
            
            if existing_content:
                logger.info(f"Content already exists: {existing_content.title}")
                return {
                    'message': 'Content already exists',
                    'content_id': existing_content.id,
                    'created': False
                }
            
            # Parse release date
            release_date = None
            if data.get('release_date'):
                try:
                    from datetime import datetime
                    release_date = datetime.strptime(data['release_date'][:10], '%Y-%m-%d').date()
                except:
                    release_date = None
            
            # Get YouTube trailer
            youtube_trailer_id = None
            if self.ContentService:
                youtube_trailer_id = self.ContentService.get_youtube_trailer(
                    data.get('title'), 
                    data.get('content_type')
                )
            
            # Create content object
            if data.get('source') == 'anime':
                mal_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                content = self.Content(
                    mal_id=mal_id,
                    title=data.get('title'),
                    original_title=data.get('original_title'),
                    content_type='anime',
                    genres=json.dumps(data.get('genres', [])),
                    anime_genres=json.dumps([]),
                    languages=json.dumps(['japanese']),
                    release_date=release_date,
                    rating=data.get('rating'),
                    overview=data.get('overview'),
                    poster_path=data.get('poster_path'),
                    youtube_trailer_id=youtube_trailer_id
                )
            else:
                tmdb_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                content = self.Content(
                    tmdb_id=tmdb_id,
                    title=data.get('title'),
                    original_title=data.get('original_title'),
                    content_type=data.get('content_type', 'movie'),
                    genres=json.dumps(data.get('genres', [])),
                    languages=json.dumps(data.get('languages', ['en'])),
                    release_date=release_date,
                    runtime=data.get('runtime'),
                    rating=data.get('rating'),
                    vote_count=data.get('vote_count'),
                    popularity=data.get('popularity'),
                    overview=data.get('overview'),
                    poster_path=data.get('poster_path'),
                    backdrop_path=data.get('backdrop_path'),
                    youtube_trailer_id=youtube_trailer_id
                )
            
            # Ensure slug
            content.ensure_slug()
            
            # Save to database
            self.db.session.add(content)
            self.db.session.commit()
            
            # Send notification
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"New {content.content_type.title()} Added",
                        f"'{content.title}' has been added to CineBrain\n"
                        f"Rating: {content.rating or 'N/A'}/10\n"
                        f"Type: {content.content_type}",
                        related_content_id=content.id,
                        action_url=f"/admin/content/{content.id}"
                    )
                except Exception as e:
                    logger.warning(f"Failed to create content notification: {e}")
            
            logger.info(f"âœ… External content saved: {content.title}")
            return {
                'message': 'Content saved successfully',
                'content_id': content.id,
                'created': True
            }
            
        except Exception as e:
            self.db.session.rollback()
            logger.error(f"Error saving content: {e}")
            raise e
    
    def create_recommendation(self, admin_user, content_id, recommendation_type, description):
        """Create admin recommendation"""
        try:
            # Get or find content
            content = self.Content.query.get(content_id)
            if not content:
                content = self.Content.query.filter_by(tmdb_id=content_id).first()
            
            if not content:
                logger.warning(f"Content not found for ID: {content_id}")
                return {'error': 'Content not found. Please save content first.'}
            
            # Create recommendation
            admin_rec = self.AdminRecommendation(
                content_id=content.id,
                admin_id=admin_user.id,
                recommendation_type=recommendation_type,
                description=description
            )
            
            self.db.session.add(admin_rec)
            self.db.session.commit()
            
            # Send to Telegram channel
            telegram_success = False
            if self.telegram_service:
                try:
                    telegram_success = self.telegram_service.send_admin_recommendation(
                        content, admin_user.username, description
                    )
                    logger.info(f"âœ… Telegram recommendation sent: {content.title}")
                except Exception as e:
                    logger.warning(f"Telegram send failed: {e}")
            
            # Create notification
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"New Admin Recommendation Created",
                        f"Admin {admin_user.username} recommended '{content.title}'\n"
                        f"Type: {recommendation_type}\n"
                        f"Description: {description[:100]}...",
                        admin_id=admin_user.id,
                        related_content_id=content.id,
                        action_url=f"/admin/recommendations/{admin_rec.id}"
                    )
                except Exception as e:
                    logger.warning(f"Failed to create recommendation notification: {e}")
            
            logger.info(f"âœ… Admin recommendation created: {content.title} by {admin_user.username}")
            return {
                'message': 'Admin recommendation created successfully',
                'telegram_sent': telegram_success,
                'recommendation_id': admin_rec.id
            }
            
        except Exception as e:
            self.db.session.rollback()
            logger.error(f"Admin recommendation error: {e}")
            raise e
    
    def get_recommendations(self, page=1, per_page=20):
        """Get admin recommendations"""
        try:
            admin_recs = self.AdminRecommendation.query.filter_by(is_active=True)\
                .order_by(self.AdminRecommendation.created_at.desc())\
                .paginate(page=page, per_page=per_page, error_out=False)
            
            result = []
            for rec in admin_recs.items:
                content = self.Content.query.get(rec.content_id)
                admin = self.User.query.get(rec.admin_id)
                
                if content and admin:
                    result.append({
                        'id': rec.id,
                        'recommendation_type': rec.recommendation_type,
                        'description': rec.description,
                        'created_at': rec.created_at.isoformat(),
                        'admin_name': admin.username,
                        'content': {
                            'id': content.id,
                            'title': content.title,
                            'content_type': content.content_type,
                            'rating': content.rating,
                            'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path
                        }
                    })
            
            logger.info(f"âœ… Retrieved {len(result)} admin recommendations")
            return {
                'recommendations': result,
                'total': admin_recs.total,
                'pages': admin_recs.pages,
                'current_page': page
            }
            
        except Exception as e:
            logger.error(f"Get admin recommendations error: {e}")
            return {'error': 'Failed to get recommendations'}
    
    def migrate_all_slugs(self, batch_size=50):
        """Migrate all content slugs"""
        try:
            from services.details import SlugManager
            
            stats = {
                'content_updated': 0,
                'persons_updated': 0,
                'total_processed': 0,
                'errors': 0
            }
            
            # Migrate content slugs that don't have slugs
            content_items = self.Content.query.filter(
                or_(self.Content.slug == None, self.Content.slug == '')
            ).limit(batch_size).all()
            
            for content in content_items:
                try:
                    if hasattr(content, 'ensure_slug'):
                        content.ensure_slug()
                        stats['content_updated'] += 1
                    else:
                        # Generate basic slug if method doesn't exist
                        if content.title:
                            import re
                            slug = re.sub(r'[^\w\s-]', '', content.title.lower())
                            slug = re.sub(r'[-\s]+', '-', slug)
                            content.slug = slug[:150]  # Limit length
                            stats['content_updated'] += 1
                except Exception as e:
                    logger.error(f"Error updating slug for content {content.id}: {e}")
                    stats['errors'] += 1
            
            self.db.session.commit()
            stats['total_processed'] = stats['content_updated'] + stats['persons_updated']
            
            logger.info(f"âœ… Slug migration completed: {stats['content_updated']} content items updated")
            return stats
            
        except Exception as e:
            logger.error(f"Slug migration error: {e}")
            self.db.session.rollback()
            raise e
    
    def update_content_slug(self, content_id, force_update=False):
        """Update specific content slug"""
        try:
            content = self.Content.query.get(content_id)
            if not content:
                return None
            
            if content.slug and not force_update:
                return content.slug
            
            if hasattr(content, 'ensure_slug'):
                content.ensure_slug()
            else:
                # Generate basic slug if method doesn't exist
                if content.title:
                    import re
                    slug = re.sub(r'[^\w\s-]', '', content.title.lower())
                    slug = re.sub(r'[-\s]+', '-', slug)
                    content.slug = slug[:150]  # Limit length
            
            self.db.session.commit()
            logger.info(f"âœ… Content slug updated: {content.title} -> {content.slug}")
            return content.slug
            
        except Exception as e:
            logger.error(f"Error updating content slug: {e}")
            self.db.session.rollback()
            return None
    
    def populate_cast_crew(self, batch_size=10):
        """Populate cast and crew data for content without it"""
        try:
            result = {
                'processed': 0,
                'errors': 0
            }
            content_items = self.Content.query.filter(
                self.Content.tmdb_id.isnot(None)
            ).limit(batch_size).all()
            
            for content in content_items:
                try:
                    # This would use your existing details service or TMDB service
                    # For now, just increment processed count
                    result['processed'] += 1
                    logger.info(f"Would populate cast/crew for {content.title}")
                except Exception as e:
                    logger.error(f"Error processing cast/crew for {content.title}: {e}")
                    result['errors'] += 1
            
            logger.info(f"âœ… Cast/crew population completed: {result['processed']} items processed")
            return result
            
        except Exception as e:
            logger.error(f"Cast/crew population error: {e}")
            raise e
    
    def get_notifications(self, page=1, per_page=20, unread_only=False):
        """Get admin notifications"""
        try:
            # Get recent notifications from Redis
            recent_notifications = []
            if self.notification_service.redis_client:
                try:
                    notifications_json = self.notification_service.redis_client.lrange('admin_notifications', 0, 19)
                    for notif_json in notifications_json:
                        recent_notifications.append(json.loads(notif_json))
                    logger.info(f"âœ… Retrieved {len(recent_notifications)} recent notifications from Redis")
                except Exception as e:
                    logger.error(f"Redis notification retrieval error: {e}")
            
            # Get database notifications
            db_notifications = []
            pagination_info = {
                'current_page': 1,
                'per_page': per_page,
                'total': 0,
                'pages': 0,
                'has_prev': False,
                'has_next': False
            }
            
            if self.AdminNotification:
                try:
                    query = self.AdminNotification.query
                    
                    if unread_only:
                        query = query.filter_by(is_read=False)
                    
                    notifications = query.order_by(
                        self.AdminNotification.created_at.desc()
                    ).paginate(page=page, per_page=per_page, error_out=False)
                    
                    for notif in notifications.items:
                        db_notifications.append({
                            'id': notif.id,
                            'type': notif.notification_type,
                            'title': notif.title,
                            'message': notif.message,
                            'is_read': notif.is_read,
                            'is_urgent': notif.is_urgent,
                            'action_required': notif.action_required,
                            'action_url': notif.action_url,
                            'metadata': notif.notification_metadata,
                            'created_at': notif.created_at.isoformat(),
                            'read_at': notif.read_at.isoformat() if notif.read_at else None
                        })
                    
                    pagination_info = {
                        'current_page': page,
                        'per_page': per_page,
                        'total': notifications.total,
                        'pages': notifications.pages,
                        'has_prev': notifications.has_prev,
                        'has_next': notifications.has_next
                    }
                    
                    logger.info(f"âœ… Retrieved {len(db_notifications)} database notifications")
                    
                except Exception as e:
                    logger.error(f"Database notification retrieval error: {e}")
            
            return {
                'recent_notifications': recent_notifications,
                'notifications': db_notifications,
                'pagination': pagination_info
            }
            
        except Exception as e:
            logger.error(f"Get admin notifications error: {e}")
            return {'error': 'Failed to get notifications'}
    
    def mark_all_notifications_read(self):
        """Mark all notifications as read"""
        try:
            if not self.AdminNotification:
                logger.warning("AdminNotification model not available")
                return {'error': 'Notification system not available'}
            
            updated_count = self.AdminNotification.query.filter_by(is_read=False).update({
                'is_read': True,
                'read_at': datetime.utcnow()
            })
            
            self.db.session.commit()
            
            logger.info(f"âœ… Marked {updated_count} notifications as read")
            return {
                'success': True,
                'message': f'Marked {updated_count} notifications as read'
            }
            
        except Exception as e:
            logger.error(f"Mark all notifications read error: {e}")
            self.db.session.rollback()
            return {'error': 'Failed to mark all notifications as read'}
    
    def clear_cache(self, cache_type='all'):
        """Clear application cache"""
        try:
            if cache_type == 'all':
                self.cache.clear()
                message = 'All cache cleared'
            elif cache_type == 'search':
                self.cache.delete_memoized(self.TMDBService.search_content)
                self.cache.delete_memoized(self.JikanService.search_anime)
                message = 'Search cache cleared'
            elif cache_type == 'recommendations':
                # Clear recommendation-related cache
                message = 'Recommendations cache cleared'
            else:
                return {'error': 'Invalid cache type'}
            
            logger.info(f"âœ… Cache cleared: {cache_type}")
            return {
                'success': True,
                'message': message,
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Cache clear error: {e}")
            return {'error': 'Failed to clear cache'}
    
    def get_canned_responses(self, category_id=None):
        """Get canned responses for support"""
        try:
            if not self.CannedResponse:
                logger.warning("CannedResponse model not available")
                return []
            
            query = self.CannedResponse.query.filter_by(is_active=True)
            
            if category_id:
                query = query.filter_by(category_id=category_id)
            
            responses = query.order_by(self.CannedResponse.usage_count.desc()).all()
            
            result = []
            for response in responses:
                result.append({
                    'id': response.id,
                    'title': response.title,
                    'content': response.content,
                    'tags': response.tags or [],
                    'usage_count': response.usage_count,
                    'created_at': response.created_at.isoformat()
                })
            
            logger.info(f"âœ… Retrieved {len(result)} canned responses")
            return result
            
        except Exception as e:
            logger.error(f"Get canned responses error: {e}")
            return []
    
    def create_canned_response(self, admin_user, title, content, category_id=None, tags=None):
        """Create new canned response"""
        try:
            if not self.CannedResponse:
                return {'error': 'Canned response system not available'}
            
            response = self.CannedResponse(
                title=title,
                content=content,
                category_id=category_id,
                tags=tags or [],
                created_by=admin_user.id
            )
            
            self.db.session.add(response)
            self.db.session.commit()
            
            logger.info(f"âœ… Canned response created: {title}")
            return {
                'success': True,
                'response_id': response.id,
                'message': 'Canned response created successfully'
            }
            
        except Exception as e:
            logger.error(f"Create canned response error: {e}")
            self.db.session.rollback()
            return {'error': 'Failed to create canned response'}

def init_admin_service(app, db, models, services):
    """Initialize admin service"""
    try:
        admin_service = AdminService(app, db, models, services)
        logger.info("âœ… Admin service initialized successfully")
        return admin_service
    except Exception as e:
        logger.error(f"âŒ Failed to initialize admin service: {e}")
        return None


5. # admin/telegram.py

import os
import json
import logging
import threading
import time
import telebot
from datetime import datetime, timedelta
from sqlalchemy import func, and_
from dotenv import load_dotenv

load_dotenv()

logger = logging.getLogger(__name__)

# Telegram Configuration
TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
TELEGRAM_CHANNEL_ID = os.environ.get('TELEGRAM_CHANNEL_ID')
TELEGRAM_ADMIN_CHAT_ID = os.environ.get('TELEGRAM_ADMIN_CHAT_ID')

# Initialize bot
bot = None
if TELEGRAM_BOT_TOKEN:
    try:
        bot = telebot.TeleBot(TELEGRAM_BOT_TOKEN)
        logger.info("âœ… Telegram bot initialized successfully")
    except Exception as e:
        logger.warning(f"Failed to initialize Telegram bot: {e}")
        bot = None
else:
    logger.warning("TELEGRAM_BOT_TOKEN not set - Telegram notifications disabled")

class TelegramAdminService:
    """Service for sending admin notifications via Telegram"""
    
    @staticmethod
    def send_admin_notification(notification_type: str, message: str, is_urgent: bool = False):
        """Send notification to admin chat"""
        try:
            if not bot or not TELEGRAM_ADMIN_CHAT_ID:
                logger.warning("Telegram admin notification skipped - not configured")
                return False
            
            icon_map = {
                'new_ticket': 'ðŸŽ«',
                'urgent_ticket': 'ðŸš¨',
                'sla_breach': 'âš ï¸',
                'feedback': 'ðŸ“',
                'system_alert': 'ðŸ””',
                'recommendation': 'ðŸŽ¬',
                'user_activity': 'ðŸ‘¤',
                'content_added': 'ðŸŽ­',
                'daily_summary': 'ðŸ“Š'
            }
            
            icon = icon_map.get(notification_type, 'ðŸ“¢')
            priority = "ðŸš¨ URGENT" if is_urgent else "ðŸ“‹ NORMAL"
            
            formatted_message = f"""
{icon} **CineBrain Admin Alert**

**Priority:** {priority}
**Type:** {notification_type.replace('_', ' ').title()}
**Time:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}

**Message:**
{message}

**Dashboard:** [View Admin Panel](https://cinebrain.vercel.app/admin)

#AdminAlert #CineBrain #{notification_type}
            """
            
            bot.send_message(
                chat_id=TELEGRAM_ADMIN_CHAT_ID,
                text=formatted_message,
                parse_mode='Markdown'
            )
            
            logger.info(f"âœ… Telegram admin notification sent: {notification_type}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Telegram admin notification error: {e}")
            return False
    
    @staticmethod
    def send_support_summary(support_ticket_model, feedback_model):
        """Send daily support summary"""
        try:
            if not bot or not TELEGRAM_ADMIN_CHAT_ID:
                logger.warning("Support summary skipped - Telegram not configured")
                return False
            
            if not support_ticket_model:
                logger.warning("Support summary skipped - support system not available")
                return False
            
            today = datetime.utcnow().date()
            
            # Get ticket statistics
            new_tickets = support_ticket_model.query.filter(
                func.date(support_ticket_model.created_at) == today
            ).count()
            
            resolved_tickets = support_ticket_model.query.filter(
                func.date(support_ticket_model.resolved_at) == today
            ).count()
            
            try:
                from support.tickets import TicketStatus, TicketPriority
                
                open_tickets = support_ticket_model.query.filter(
                    support_ticket_model.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                ).count()
                
                urgent_tickets = support_ticket_model.query.filter(
                    and_(
                        support_ticket_model.priority == TicketPriority.URGENT,
                        support_ticket_model.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS])
                    )
                ).count()
                
            except ImportError:
                open_tickets = 0
                urgent_tickets = 0
            
            # Get feedback count
            new_feedback = 0
            if feedback_model:
                new_feedback = feedback_model.query.filter(
                    func.date(feedback_model.created_at) == today
                ).count()
            
            message = f"""ðŸ“Š **Daily Support Summary**

**Today's Activity:**
ðŸŽ« New Tickets: {new_tickets}
âœ… Resolved: {resolved_tickets}
ðŸ“‹ Open Tickets: {open_tickets}
ðŸš¨ Urgent: {urgent_tickets}
ðŸ’¬ New Feedback: {new_feedback}

**Status:** {'ðŸŸ¢ Good' if urgent_tickets == 0 else 'ðŸŸ¡ Attention Needed' if urgent_tickets < 5 else 'ðŸ”´ Critical'}

#DailySummary #Support #CineBrain"""
            
            return TelegramAdminService.send_admin_notification('daily_summary', message)
            
        except Exception as e:
            logger.error(f"âŒ Support summary error: {e}")
            return False
    
    @staticmethod
    def send_system_alert(alert_type: str, title: str, details: str):
        """Send system alert notification"""
        try:
            if not bot or not TELEGRAM_ADMIN_CHAT_ID:
                logger.warning("System alert skipped - Telegram not configured")
                return False
            
            alert_icons = {
                'database_error': 'ðŸ”´',
                'cache_error': 'ðŸŸ¡',
                'api_error': 'ðŸ”Œ',
                'high_load': 'ðŸ“ˆ',
                'security_alert': 'ðŸ”’',
                'backup_failed': 'ðŸ’¾'
            }
            
            icon = alert_icons.get(alert_type, 'âš ï¸')
            
            message = f"""
{icon} **System Alert**

**Alert Type:** {title}
**Time:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}

**Details:**
{details}

**Action Required:** Please check the admin dashboard for more details.

#SystemAlert #CineBrain #{alert_type}
            """
            
            return TelegramAdminService.send_admin_notification('system_alert', message, is_urgent=True)
            
        except Exception as e:
            logger.error(f"âŒ System alert error: {e}")
            return False

class TelegramService:
    """Service for sending public content recommendations to Telegram channel"""
    
    @staticmethod
    def send_admin_recommendation(content, admin_name, description):
        """Send admin recommendation to public channel"""
        try:
            if not bot or not TELEGRAM_CHANNEL_ID:
                logger.warning("Telegram recommendation skipped - channel not configured")
                return False
            
            # Parse genres
            genres_list = []
            if content.genres:
                try:
                    genres_list = json.loads(content.genres)
                except:
                    genres_list = []
            
            # Handle poster URL
            poster_url = None
            if content.poster_path:
                if content.poster_path.startswith('http'):
                    poster_url = content.poster_path
                else:
                    poster_url = f"https://image.tmdb.org/t/p/w500{content.poster_path}"
            
            # Format message
            message = f"""ðŸŽ¬ **Admin's Choice** by {admin_name}

**{content.title}**
â­ Rating: {content.rating or 'N/A'}/10
ðŸ“… Release: {content.release_date or 'N/A'}
ðŸŽ­ Genres: {', '.join(genres_list[:3]) if genres_list else 'N/A'}
ðŸŽ¬ Type: {content.content_type.upper()}

ðŸ“ **Admin's Note:** {description}

ðŸ“– **Synopsis:** {(content.overview[:200] + '...') if content.overview else 'No synopsis available'}

#AdminChoice #MovieRecommendation #CineBrain"""
            
            # Send with photo if available
            if poster_url:
                try:
                    bot.send_photo(
                        chat_id=TELEGRAM_CHANNEL_ID,
                        photo=poster_url,
                        caption=message,
                        parse_mode='Markdown'
                    )
                except Exception as photo_error:
                    logger.error(f"Failed to send photo, sending text only: {photo_error}")
                    bot.send_message(TELEGRAM_CHANNEL_ID, message, parse_mode='Markdown')
            else:
                bot.send_message(TELEGRAM_CHANNEL_ID, message, parse_mode='Markdown')
            
            logger.info(f"âœ… Admin recommendation sent to Telegram: {content.title}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Telegram send error: {e}")
            return False
    
    @staticmethod
    def send_new_content_alert(content, content_count):
        """Send alert about new content added"""
        try:
            if not bot or not TELEGRAM_CHANNEL_ID:
                return False
            
            if content_count > 1:
                message = f"""ðŸŽ¬ **New Content Added!**

Added {content_count} new {content.content_type}s to CineBrain!

Latest addition: **{content.title}**
â­ Rating: {content.rating or 'N/A'}/10

Check out all the new content on CineBrain! ðŸ¿

#NewContent #CineBrain"""
            else:
                message = f"""ðŸŽ¬ **New {content.content_type.title()} Added!**

**{content.title}**
â­ Rating: {content.rating or 'N/A'}/10
ðŸ“… Release: {content.release_date or 'N/A'}

Now available on CineBrain! ðŸ¿

#NewContent #CineBrain"""
            
            bot.send_message(TELEGRAM_CHANNEL_ID, message, parse_mode='Markdown')
            logger.info(f"âœ… New content alert sent: {content.title}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ New content alert error: {e}")
            return False

class TelegramScheduler:
    """Background scheduler for Telegram notifications"""
    
    def __init__(self, support_models=None):
        self.support_ticket_model = support_models.get('SupportTicket') if support_models else None
        self.feedback_model = support_models.get('Feedback') if support_models else None
        self.running = False
    
    def start_scheduler(self):
        """Start the background scheduler"""
        if self.running:
            return
        
        self.running = True
        
        def scheduler_worker():
            while self.running:
                try:
                    now = datetime.utcnow()
                    
                    # Send daily summary at 9:00 UTC
                    if now.hour == 9 and now.minute == 0:
                        if self.support_ticket_model:
                            TelegramAdminService.send_support_summary(
                                self.support_ticket_model, 
                                self.feedback_model
                            )
                    
                    # Check for urgent tickets every 30 minutes during work hours
                    if 8 <= now.hour <= 20 and now.minute % 30 == 0:
                        self._check_urgent_tickets()
                    
                    time.sleep(60)  # Check every minute
                    
                except Exception as e:
                    logger.error(f"Telegram scheduler error: {e}")
                    time.sleep(300)  # Wait 5 minutes on error
        
        thread = threading.Thread(target=scheduler_worker, daemon=True, name="TelegramScheduler")
        thread.start()
        logger.info("âœ… Telegram scheduler started")
    
    def stop_scheduler(self):
        """Stop the scheduler"""
        self.running = False
        logger.info("ðŸ›‘ Telegram scheduler stopped")
    
    def _check_urgent_tickets(self):
        """Check for urgent tickets and send alerts"""
        try:
            if not self.support_ticket_model:
                return
            
            from support.tickets import TicketStatus, TicketPriority
            
            # Check for urgent tickets without response in last hour
            hour_ago = datetime.utcnow() - timedelta(hours=1)
            urgent_tickets = self.support_ticket_model.query.filter(
                and_(
                    self.support_ticket_model.priority == TicketPriority.URGENT,
                    self.support_ticket_model.status.in_([TicketStatus.OPEN, TicketStatus.IN_PROGRESS]),
                    self.support_ticket_model.first_response_at.is_(None),
                    self.support_ticket_model.created_at >= hour_ago
                )
            ).all()
            
            for ticket in urgent_tickets:
                message = f"""Urgent ticket #{ticket.ticket_number} needs immediate attention!

Subject: {ticket.subject}
From: {ticket.user_name}
Created: {ticket.created_at.strftime('%H:%M UTC')}

No response yet - SLA deadline approaching!"""
                
                TelegramAdminService.send_admin_notification(
                    'urgent_ticket', 
                    message, 
                    is_urgent=True
                )
            
        except ImportError:
            pass  # Support system not available
        except Exception as e:
            logger.error(f"Error checking urgent tickets: {e}")

# Global scheduler instance
telegram_scheduler = None

def init_telegram_service(app, db, models, services):
    """Initialize Telegram service"""
    global telegram_scheduler
    
    try:
        # Initialize scheduler with support models
        support_models = {
            'SupportTicket': models.get('SupportTicket'),
            'Feedback': models.get('Feedback')
        }
        
        telegram_scheduler = TelegramScheduler(support_models)
        
        # Start scheduler if bot is configured
        if bot:
            telegram_scheduler.start_scheduler()
            logger.info("âœ… Telegram service initialized successfully")
        else:
            logger.warning("âš ï¸ Telegram service initialized but bot not configured")
        
        return {
            'telegram_admin_service': TelegramAdminService,
            'telegram_service': TelegramService,
            'telegram_scheduler': telegram_scheduler
        }
        
    except Exception as e:
        logger.error(f"âŒ Failed to initialize Telegram service: {e}")
        return None

def cleanup_telegram_service():
    """Cleanup Telegram service"""
    global telegram_scheduler
    if telegram_scheduler:
        telegram_scheduler.stop_scheduler()