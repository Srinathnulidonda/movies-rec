1. # user/__init__.py
"""
CineBrain User Module
Comprehensive user management system with modular architecture
"""

from .routes import user_bp

__all__ = ['user_bp']
__version__ = '1.0.0'


2. # user/activity.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from .utils import require_auth, db, UserInteraction, Content, create_minimal_content_record, content_service, recommendation_engine

logger = logging.getLogger(__name__)

@require_auth
def record_interaction(current_user):
    """Record user interaction with content"""
    try:
        data = request.get_json()
        
        required_fields = ['content_id', 'interaction_type']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields for CineBrain interaction'}), 400
        
        content_id = data['content_id']
        
        content_exists = Content.query.filter_by(id=content_id).first()
        if not content_exists:
            logger.warning(f"CineBrain: Content {content_id} not found in database, attempting to create")
            
            try:
                content_metadata = data.get('metadata', {})
                content_info = content_metadata.get('content_info')
                
                if content_info:
                    if content_service and content_info.get('tmdb_id'):
                        try:
                            from app import CineBrainTMDBService
                            tmdb_data = CineBrainTMDBService.get_content_details(
                                content_info['tmdb_id'], 
                                content_info.get('content_type', 'movie').strip()
                            )
                            if tmdb_data:
                                content_exists = content_service.save_content_from_tmdb(
                                    tmdb_data, 
                                    content_info.get('content_type', 'movie').strip()
                                )
                                logger.info(f"CineBrain: Created content from TMDB for ID {content_id}")
                        except Exception as e:
                            logger.warning(f"Failed to fetch from TMDB: {e}")
                    
                    if not content_exists:
                        content_exists = create_minimal_content_record(content_id, content_info)
                
                if not content_exists:
                    return jsonify({
                        'error': 'Content not found in CineBrain database',
                        'details': 'Unable to create or fetch content record. Please try again.'
                    }), 404
                    
            except Exception as e:
                logger.error(f"Failed to create content record: {e}")
                return jsonify({
                    'error': 'Content not found in CineBrain database',
                    'details': 'Unable to create content record due to data validation error'
                }), 404
        
        # Handle removal interactions
        if data['interaction_type'] in ['remove_watchlist', 'remove_favorite']:
            interaction_type = 'watchlist' if data['interaction_type'] == 'remove_watchlist' else 'favorite'
            interaction = UserInteraction.query.filter_by(
                user_id=current_user.id,
                content_id=data['content_id'],
                interaction_type=interaction_type
            ).first()
            
            if interaction:
                db.session.delete(interaction)
                db.session.commit()
                
                if recommendation_engine:
                    try:
                        recommendation_engine.update_user_preferences_realtime(
                            current_user.id,
                            {
                                'content_id': data['content_id'],
                                'interaction_type': data['interaction_type'],
                                'metadata': data.get('metadata', {})
                            }
                        )
                    except Exception as e:
                        logger.warning(f"Failed to update CineBrain real-time preferences: {e}")
                
                message = f'Removed from CineBrain {"watchlist" if interaction_type == "watchlist" else "favorites"}'
                return jsonify({
                    'success': True,
                    'message': message
                }), 200
            else:
                item_type = "watchlist" if interaction_type == "watchlist" else "favorites"
                return jsonify({
                    'success': False,
                    'message': f'Content not in CineBrain {item_type}'
                }), 404
        
        # Check for existing interaction
        if data['interaction_type'] in ['watchlist', 'favorite']:
            existing = UserInteraction.query.filter_by(
                user_id=current_user.id,
                content_id=data['content_id'],
                interaction_type=data['interaction_type']
            ).first()
            
            if existing:
                item_type = "watchlist" if data['interaction_type'] == "watchlist" else "favorites"
                return jsonify({
                    'success': True,
                    'message': f'Already in CineBrain {item_type}'
                }), 200
        
        # Create new interaction
        interaction = UserInteraction(
            user_id=current_user.id,
            content_id=data['content_id'],
            interaction_type=data['interaction_type'],
            rating=data.get('rating'),
            interaction_metadata=json.dumps(data.get('metadata', {}))
        )
        
        db.session.add(interaction)
        db.session.commit()
        
        if recommendation_engine:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'content_id': data['content_id'],
                        'interaction_type': data['interaction_type'],
                        'rating': data.get('rating'),
                        'metadata': data.get('metadata', {})
                    }
                )
            except Exception as e:
                logger.warning(f"Failed to update CineBrain real-time preferences: {e}")
        
        return jsonify({
            'success': True,
            'message': 'CineBrain interaction recorded successfully',
            'interaction_id': interaction.id
        }), 201
        
    except Exception as e:
        logger.error(f"CineBrain interaction recording error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to record CineBrain interaction'}), 500

def get_public_activity(username):
    """Get public activity for a username"""
    try:
        from .utils import User
        user = User.query.filter_by(username=username).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        # Return limited public activity
        public_interactions = UserInteraction.query.filter_by(
            user_id=user.id,
            interaction_type='rating'  # Only show ratings publicly
        ).order_by(UserInteraction.timestamp.desc()).limit(10).all()
        
        formatted_activity = []
        for interaction in public_interactions:
            content = Content.query.get(interaction.content_id)
            if content:
                formatted_activity.append({
                    'interaction_type': interaction.interaction_type,
                    'rating': interaction.rating,
                    'timestamp': interaction.timestamp.isoformat(),
                    'content': {
                        'id': content.id,
                        'title': content.title,
                        'content_type': content.content_type,
                        'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path
                    }
                })
        
        return jsonify({'recent_activity': formatted_activity}), 200
    except Exception as e:
        logger.error(f"Error getting public activity: {e}")
        return jsonify({'error': 'Failed to get activity'}), 500

def get_public_stats(username):
    """Get public stats for a username"""
    try:
        from .utils import User
        user = User.query.filter_by(username=username).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        # Return limited public stats
        interactions = UserInteraction.query.filter_by(user_id=user.id).all()
        
        public_stats = {
            'total_interactions': len(interactions),
            'favorites': len([i for i in interactions if i.interaction_type == 'favorite']),
            'ratings_given': len([i for i in interactions if i.interaction_type == 'rating'])
        }
        
        return jsonify({'stats': public_stats}), 200
    except Exception as e:
        logger.error(f"Error getting public stats: {e}")
        return jsonify({'error': 'Failed to get stats'}), 500


3. # user/avatar.py
from flask import request, jsonify
from datetime import datetime
import logging
import cloudinary
import cloudinary.uploader
import cloudinary.api
import os
import base64
import io
from PIL import Image
import re
from .utils import require_auth, db, User

logger = logging.getLogger(__name__)

# Configure Cloudinary
cloudinary.config(
    cloud_name=os.environ.get('CLOUDINARY_CLOUD_NAME'),
    api_key=os.environ.get('CLOUDINARY_API_KEY'),
    api_secret=os.environ.get('CLOUDINARY_API_SECRET'),
    secure=True
)

def validate_avatar_upload(file_data):
    """Validate uploaded avatar file"""
    try:
        if file_data.startswith('data:image/'):
            header, encoded = file_data.split(',', 1)
            file_data = base64.b64decode(encoded)
        
        image = Image.open(io.BytesIO(file_data))
        
        if image.format not in ['JPEG', 'PNG', 'WEBP']:
            return False, "Invalid image format. Only JPEG, PNG, and WEBP are allowed."
        
        if len(file_data) > 5 * 1024 * 1024:
            return False, "Image size too large. Maximum 5MB allowed."
        
        width, height = image.size
        if width > 2048 or height > 2048:
            return False, "Image dimensions too large. Maximum 2048x2048 pixels."
        
        if width < 50 or height < 50:
            return False, "Image too small. Minimum 50x50 pixels required."
        
        return True, "Valid image"
        
    except Exception as e:
        return False, f"Invalid image data: {str(e)}"

def process_avatar_image(file_data):
    """Process and optimize avatar image"""
    try:
        if isinstance(file_data, str) and file_data.startswith('data:image/'):
            header, encoded = file_data.split(',', 1)
            file_data = base64.b64decode(encoded)
        
        image = Image.open(io.BytesIO(file_data))
        
        if image.mode in ('RGBA', 'LA', 'P'):
            background = Image.new('RGB', image.size, (255, 255, 255))
            if image.mode == 'P':
                image = image.convert('RGBA')
            background.paste(image, mask=image.split()[-1] if image.mode == 'RGBA' else None)
            image = background
        
        image = image.resize((300, 300), Image.Resampling.LANCZOS)
        
        output = io.BytesIO()
        image.save(output, format='JPEG', quality=85, optimize=True)
        output.seek(0)
        
        return output.getvalue()
        
    except Exception as e:
        logger.error(f"Error processing avatar image: {e}")
        return None

def clean_username_for_storage(username):
    """Clean username for safe storage"""
    return re.sub(r'[^a-zA-Z0-9_-]', '_', username.lower())

def delete_old_avatar(current_user):
    """Delete old avatar from Cloudinary"""
    if not current_user.avatar_url:
        return
        
    if 'cloudinary' in current_user.avatar_url:
        try:
            clean_username = clean_username_for_storage(current_user.username)
            old_public_id = f"cinebrain/avatars/cinebrain_avatar_{clean_username}"
            cloudinary.uploader.destroy(old_public_id)
            
            url_parts = current_user.avatar_url.split('/')
            if len(url_parts) > 2:
                public_id = url_parts[-1].split('.')[0]
                if public_id.startswith('cinebrain_avatar_'):
                    cloudinary.uploader.destroy(f"cinebrain/avatars/{public_id}")
        except Exception as e:
            logger.warning(f"Failed to delete old avatar: {e}")

def upload_avatar_to_cloudinary(processed_image, username):
    """Upload avatar to Cloudinary"""
    clean_username = clean_username_for_storage(username)
    
    upload_result = cloudinary.uploader.upload(
        processed_image,
        folder="cinebrain/avatars",
        public_id=f"cinebrain_avatar_{clean_username}",
        transformation=[
            {'width': 300, 'height': 300, 'crop': 'fill', 'gravity': 'face'},
            {'quality': 'auto:good'},
            {'format': 'jpg'}
        ],
        tags=['cinebrain', 'avatar', f'username_{clean_username}'],
        overwrite=True,
        resource_type="image"
    )
    
    return upload_result

def is_cloudinary_configured():
    """Check if Cloudinary is configured"""
    return all([
        os.environ.get('CLOUDINARY_CLOUD_NAME'),
        os.environ.get('CLOUDINARY_API_KEY'),
        os.environ.get('CLOUDINARY_API_SECRET')
    ])

@require_auth
def upload_avatar(current_user):
    """Handle avatar upload"""
    try:
        data = request.get_json()
        
        if not data or 'image' not in data:
            return jsonify({'error': 'No image data provided'}), 400
        
        if not is_cloudinary_configured():
            return jsonify({'error': 'CineBrain avatar upload not configured'}), 503
        
        image_data = data['image']
        
        is_valid, message = validate_avatar_upload(image_data)
        if not is_valid:
            return jsonify({'error': message}), 400
        
        processed_image = process_avatar_image(image_data)
        if not processed_image:
            return jsonify({'error': 'Failed to process image'}), 400
        
        delete_old_avatar(current_user)
        
        try:
            upload_result = upload_avatar_to_cloudinary(processed_image, current_user.username)
            
            current_user.avatar_url = upload_result['secure_url']
            db.session.commit()
            
            logger.info(f"CineBrain: Avatar uploaded successfully for user {current_user.username} (ID: {current_user.id})")
            
            return jsonify({
                'success': True,
                'message': 'Avatar uploaded successfully',
                'avatar_url': upload_result['secure_url'],
                'username': current_user.username,
                'cloudinary_data': {
                    'public_id': upload_result['public_id'],
                    'version': upload_result['version'],
                    'width': upload_result['width'],
                    'height': upload_result['height'],
                    'format': upload_result['format'],
                    'bytes': upload_result['bytes'],
                    'stored_as': f"cinebrain_avatar_{clean_username_for_storage(current_user.username)}"
                }
            }), 200
            
        except cloudinary.exceptions.Error as e:
            logger.error(f"Cloudinary upload error for user {current_user.username}: {e}")
            return jsonify({'error': 'Failed to upload image to cloud storage'}), 500
            
    except Exception as e:
        logger.error(f"CineBrain avatar upload error for user {current_user.username}: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to upload avatar'}), 500

@require_auth
def delete_avatar(current_user):
    """Handle avatar deletion"""
    try:
        if not current_user.avatar_url:
            return jsonify({'error': 'No avatar to delete'}), 400
        
        if 'cloudinary' in current_user.avatar_url:
            delete_old_avatar(current_user)
        
        current_user.avatar_url = None
        db.session.commit()
        
        logger.info(f"CineBrain: Avatar deleted for user {current_user.username} (ID: {current_user.id})")
        
        return jsonify({
            'success': True,
            'message': 'Avatar deleted successfully',
            'username': current_user.username
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain avatar deletion error for user {current_user.username}: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to delete avatar'}), 500

@require_auth
def get_avatar_url(current_user):
    """Get current avatar URL"""
    try:
        return jsonify({
            'success': True,
            'avatar_url': current_user.avatar_url,
            'has_avatar': bool(current_user.avatar_url),
            'username': current_user.username
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain get avatar URL error: {e}")
        return jsonify({'error': 'Failed to get avatar URL'}), 500


4. # user/dashboard.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from .utils import require_auth, get_enhanced_user_stats, recommendation_engine

logger = logging.getLogger(__name__)

@require_auth
def get_user_analytics(current_user):
    """Get comprehensive user analytics"""
    try:
        analytics = get_enhanced_user_stats(current_user.id)
        
        insights = {
            'recommendations': {
                'total_generated': analytics.get('total_interactions', 0),
                'accuracy_score': analytics.get('engagement_metrics', {}).get('engagement_score', 0),
                'improvement_tips': []
            },
            'content_preferences': {
                'diversity_level': 'high' if analytics.get('content_diversity', {}).get('diversity_score', 0) > 0.7 else 'medium',
                'exploration_tendency': analytics.get('discovery_score', 0),
                'quality_preference': analytics.get('quality_preferences', {}).get('quality_preference', 'balanced')
            },
            'engagement_level': 'high' if analytics.get('engagement_metrics', {}).get('engagement_score', 0) > 0.7 else 'moderate'
        }
        
        if analytics.get('total_interactions', 0) < 10:
            insights['recommendations']['improvement_tips'].append(
                "Interact with more CineBrain content (like, favorite, rate) to improve recommendations"
            )
        
        if analytics.get('ratings_given', 0) < 5:
            insights['recommendations']['improvement_tips'].append(
                "Rate CineBrain content to help our AI understand your preferences better"
            )
        
        if analytics.get('content_diversity', {}).get('genre_diversity_count', 0) < 5:
            insights['recommendations']['improvement_tips'].append(
                "Explore different genres on CineBrain to discover new content you might love"
            )
        
        return jsonify({
            'success': True,
            'analytics': analytics,
            'insights': insights,
            'generated_at': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain analytics error: {e}")
        return jsonify({'error': 'Failed to get CineBrain analytics'}), 500

@require_auth
def get_profile_insights(current_user):
    """Get profile insights for user dashboard"""
    try:
        if not recommendation_engine:
            return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
        
        user_profile = recommendation_engine.user_profiler.build_comprehensive_user_profile(current_user.id)
        
        if not user_profile:
            return jsonify({
                'success': False,
                'message': 'Could not build CineBrain user profile - insufficient interaction data',
                'suggestion': 'Interact with more CineBrain content to build your profile'
            }), 404
        
        insights = {
            'profile_strength': {
                'completeness': user_profile.get('profile_completeness', 0),
                'confidence': user_profile.get('confidence_score', 0),
                'status': 'strong' if user_profile.get('confidence_score', 0) > 0.7 else 'developing',
                'interactions_needed': max(0, 20 - user_profile.get('implicit_preferences', {}).get('total_interactions', 0))
            },
            'preferences': {
                'top_genres': user_profile.get('genre_preferences', {}).get('top_genres', [])[:5],
                'preferred_languages': user_profile.get('language_preferences', {}).get('preferred_languages', [])[:3],
                'content_types': user_profile.get('content_type_preferences', {}).get('content_type_scores', {}),
                'quality_threshold': user_profile.get('quality_preferences', {}).get('min_rating', 6.0)
            },
            'behavior': {
                'engagement_score': user_profile.get('engagement_score', 0),
                'viewing_style': user_profile.get('implicit_preferences', {}).get('most_common_interaction', 'explorer'),
                'exploration_tendency': user_profile.get('exploration_tendency', 0),
                'total_interactions': user_profile.get('implicit_preferences', {}).get('total_interactions', 0),
                'consistency': user_profile.get('temporal_patterns', {}).get('activity_consistency', 0)
            },
            'recent_activity': user_profile.get('recent_activity', {}),
            'recommendations_quality': {
                'accuracy_estimate': min(user_profile.get('confidence_score', 0) * 100, 95),
                'personalization_level': 'high' if user_profile.get('confidence_score', 0) > 0.8 else 'moderate',
                'next_improvement': _get_improvement_suggestion(user_profile)
            }
        }
        
        return jsonify({
            'success': True,
            'insights': insights,
            'last_updated': user_profile.get('last_updated', datetime.utcnow()).isoformat(),
            'profile_version': '3.0'
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain Profile insights error: {e}")
        return jsonify({'error': 'Failed to get CineBrain profile insights'}), 500

def _get_improvement_suggestion(user_profile):
    """Get personalized improvement suggestion"""
    completeness = user_profile.get('profile_completeness', 0)
    total_interactions = user_profile.get('implicit_preferences', {}).get('total_interactions', 0)
    ratings_count = user_profile.get('explicit_preferences', {}).get('ratings_count', 0)
    
    if completeness < 0.3:
        return 'Interact with more CineBrain content (like, favorite, add to watchlist) to improve accuracy'
    elif ratings_count < 5:
        return 'Rate more CineBrain content to help our AI understand your taste better'
    elif completeness < 0.8:
        return 'Explore different genres on CineBrain to get more diverse recommendations'
    else:
        return 'Your CineBrain recommendations are highly accurate! Keep discovering new content'


5.# user/favorites.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from .utils import require_auth, db, UserInteraction, Content, format_content_for_response, recommendation_engine

logger = logging.getLogger(__name__)

@require_auth
def get_favorites(current_user):
    """Get user's favorites"""
    try:
        favorite_interactions = UserInteraction.query.filter_by(
            user_id=current_user.id,
            interaction_type='favorite'
        ).order_by(UserInteraction.timestamp.desc()).all()
        
        content_ids = [interaction.content_id for interaction in favorite_interactions]
        contents = Content.query.filter(Content.id.in_(content_ids)).all()
        content_map = {content.id: content for content in contents}
        
        result = []
        for interaction in favorite_interactions:
            content = content_map.get(interaction.content_id)
            if content:
                formatted_content = format_content_for_response(content, interaction)
                formatted_content['favorited_at'] = interaction.timestamp.isoformat()
                formatted_content['user_rating'] = interaction.rating
                result.append(formatted_content)
        
        return jsonify({
            'favorites': result,
            'total_count': len(result),
            'last_updated': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain favorites error: {e}")
        return jsonify({'error': 'Failed to get CineBrain favorites'}), 500

@require_auth
def add_to_favorites(current_user):
    """Add content to favorites"""
    try:
        data = request.get_json()
        content_id = data.get('content_id')
        rating = data.get('rating')
        
        if not content_id:
            return jsonify({'error': 'Content ID required'}), 400
        
        # Check if already in favorites
        existing = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='favorite'
        ).first()
        
        if existing:
            # Update rating if provided
            if rating:
                existing.rating = rating
                db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Already in CineBrain favorites'
            }), 200
        
        # Add to favorites
        interaction = UserInteraction(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='favorite',
            rating=rating
        )
        
        db.session.add(interaction)
        db.session.commit()
        
        # Update recommendation engine
        if recommendation_engine:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'content_id': content_id,
                        'interaction_type': 'favorite',
                        'rating': rating
                    }
                )
            except Exception as e:
                logger.warning(f"Failed to update CineBrain recommendations: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Added to CineBrain favorites'
        }), 201
        
    except Exception as e:
        logger.error(f"Add to CineBrain favorites error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to add to CineBrain favorites'}), 500

@require_auth
def remove_from_favorites(current_user, content_id):
    """Remove content from favorites"""
    try:
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='favorite'
        ).first()
        
        if interaction:
            db.session.delete(interaction)
            db.session.commit()
            
            if recommendation_engine:
                try:
                    recommendation_engine.update_user_preferences_realtime(
                        current_user.id,
                        {
                            'content_id': content_id,
                            'interaction_type': 'remove_favorite'
                        }
                    )
                except Exception as e:
                    logger.warning(f"Failed to update CineBrain recommendations: {e}")
            
            return jsonify({
                'success': True,
                'message': 'Removed from CineBrain favorites'
            }), 200
        else:
            return jsonify({
                'success': False,
                'message': 'Content not in CineBrain favorites'
            }), 404
            
    except Exception as e:
        logger.error(f"Remove from CineBrain favorites error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to remove from CineBrain favorites'}), 500

@require_auth
def check_favorite_status(current_user, content_id):
    """Check if content is in favorites"""
    try:
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='favorite'
        ).first()
        
        return jsonify({
            'in_favorites': interaction is not None,
            'favorited_at': interaction.timestamp.isoformat() if interaction else None,
            'user_rating': interaction.rating if interaction else None
        }), 200
        
    except Exception as e:
        logger.error(f"Check CineBrain favorite status error: {e}")
        return jsonify({'error': 'Failed to check CineBrain favorite status'}), 500


6. # user/profile.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from .utils import require_auth, db, User, UserInteraction, Content, get_enhanced_user_stats, recommendation_engine

logger = logging.getLogger(__name__)

@require_auth
def get_user_profile(current_user):
    """Get comprehensive user profile"""
    try:
        stats = get_enhanced_user_stats(current_user.id)
        
        recent_interactions = []
        if UserInteraction:
            try:
                recent = UserInteraction.query.filter_by(
                    user_id=current_user.id
                ).order_by(UserInteraction.timestamp.desc()).limit(10).all()
                
                for interaction in recent:
                    content = Content.query.get(interaction.content_id) if Content else None
                    recent_interactions.append({
                        'id': interaction.id,
                        'interaction_type': interaction.interaction_type,
                        'timestamp': interaction.timestamp.isoformat(),
                        'rating': interaction.rating,
                        'content': {
                            'id': content.id,
                            'title': content.title,
                            'content_type': content.content_type,
                            'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path,
                            'slug': content.slug
                        } if content else None
                    })
            except Exception as e:
                logger.warning(f"Could not get CineBrain recent activity: {e}")
        
        rec_effectiveness = {}
        try:
            if recommendation_engine:
                rec_effectiveness = recommendation_engine.get_user_recommendation_metrics(current_user.id)
        except Exception as e:
            logger.warning(f"Could not get CineBrain recommendation effectiveness: {e}")
        
        profile_fields = {
            'preferred_languages': current_user.preferred_languages,
            'preferred_genres': current_user.preferred_genres,
            'location': current_user.location,
            'avatar_url': current_user.avatar_url
        }
        
        completed_fields = [field for field, value in profile_fields.items() if value]
        completion_score = min(100, len(completed_fields) * 25)
        missing_fields = [field for field, value in profile_fields.items() if not value]
        
        profile_data = {
            'user': {
                'id': current_user.id,
                'username': current_user.username,
                'email': current_user.email,
                'is_admin': current_user.is_admin,
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location,
                'avatar_url': current_user.avatar_url,
                'created_at': current_user.created_at.isoformat(),
                'last_active': current_user.last_active.isoformat() if current_user.last_active else None
            },
            'stats': stats,
            'recent_activity': recent_interactions,
            'recommendation_effectiveness': rec_effectiveness,
            'profile_completion': {
                'score': completion_score,
                'missing_fields': missing_fields,
                'suggestions': [
                    'Add preferred languages to get better CineBrain recommendations',
                    'Select favorite genres to improve CineBrain content discovery',
                    'Add your location for regional CineBrain content suggestions',
                    'Upload an avatar to personalize your CineBrain profile'
                ][:len(missing_fields)]
            }
        }
        
        return jsonify(profile_data), 200
        
    except Exception as e:
        logger.error(f"CineBrain profile error: {e}")
        return jsonify({'error': 'Failed to get CineBrain user profile'}), 500

@require_auth
def update_user_profile(current_user):
    """Update user profile"""
    try:
        data = request.get_json()
        
        updated_fields = []
        
        if 'preferred_languages' in data:
            current_user.preferred_languages = json.dumps(data['preferred_languages'])
            updated_fields.append('preferred_languages')
        
        if 'preferred_genres' in data:
            current_user.preferred_genres = json.dumps(data['preferred_genres'])
            updated_fields.append('preferred_genres')
        
        if 'location' in data:
            current_user.location = data['location']
            updated_fields.append('location')
        
        if 'avatar_url' in data:
            current_user.avatar_url = data['avatar_url']
            updated_fields.append('avatar_url')
        
        db.session.commit()
        
        if recommendation_engine and updated_fields:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'interaction_type': 'profile_update',
                        'metadata': {
                            'updated_fields': updated_fields,
                            'data': data
                        }
                    }
                )
                logger.info(f"Updated CineBrain recommendation engine for user {current_user.id}")
            except Exception as e:
                logger.warning(f"Failed to update CineBrain recommendation engine: {e}")
        
        return jsonify({
            'success': True,
            'message': f'CineBrain profile updated successfully. Updated: {", ".join(updated_fields)}',
            'updated_fields': updated_fields,
            'user': {
                'id': current_user.id,
                'username': current_user.username,
                'email': current_user.email,
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location,
                'avatar_url': current_user.avatar_url
            }
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain profile update error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update CineBrain profile'}), 500

def get_public_profile(username):
    """Get public profile for a username"""
    try:
        user = User.query.filter_by(username=username).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        return jsonify({
            'user': {
                'id': user.id,
                'username': user.username,
                'avatar_url': user.avatar_url,
                'created_at': user.created_at.isoformat(),
                'last_active': user.last_active.isoformat() if user.last_active else None
            }
        }), 200
    except Exception as e:
        logger.error(f"Error getting public profile: {e}")
        return jsonify({'error': 'Failed to get profile'}), 500

@require_auth
def update_user_preferences(current_user):
    """Update user preferences for personalization"""
    try:
        data = request.get_json()
        
        if 'preferred_languages' in data:
            current_user.preferred_languages = json.dumps(data['preferred_languages'])
        
        if 'preferred_genres' in data:
            current_user.preferred_genres = json.dumps(data['preferred_genres'])
        
        db.session.commit()
        
        if recommendation_engine:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'interaction_type': 'preference_update',
                        'metadata': {
                            'updated_languages': data.get('preferred_languages'),
                            'updated_genres': data.get('preferred_genres'),
                            'source': 'explicit_preference_update'
                        }
                    }
                )
                logger.info(f"Successfully updated CineBrain preferences for user {current_user.id}")
            except Exception as e:
                logger.warning(f"Failed to update CineBrain recommendation engine: {e}")
        
        return jsonify({
            'success': True,
            'message': 'CineBrain preferences updated successfully',
            'user': {
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]')
            },
            'recommendation_refresh': 'triggered'
        }), 200
        
    except Exception as e:
        logger.error(f"Update CineBrain preferences error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update CineBrain preferences'}), 500



7. # user/ratings.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
import numpy as np
from .utils import require_auth, db, UserInteraction, Content

logger = logging.getLogger(__name__)

@require_auth
def get_user_ratings(current_user):
    """Get user's ratings"""
    try:
        rating_interactions = UserInteraction.query.filter_by(
            user_id=current_user.id,
            interaction_type='rating'
        ).filter(UserInteraction.rating.isnot(None)).order_by(
            UserInteraction.timestamp.desc()
        ).all()
        
        content_ids = [interaction.content_id for interaction in rating_interactions]
        contents = Content.query.filter(Content.id.in_(content_ids)).all()
        content_map = {content.id: content for content in contents}
        
        result = []
        for interaction in rating_interactions:
            content = content_map.get(interaction.content_id)
            if content:
                result.append({
                    'id': content.id,
                    'slug': content.slug,
                    'title': content.title,
                    'content_type': content.content_type,
                    'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path,
                    'user_rating': interaction.rating,
                    'imdb_rating': content.rating,
                    'rated_at': interaction.timestamp.isoformat()
                })
        
        ratings = [interaction.rating for interaction in rating_interactions]
        stats = {
            'total_ratings': len(ratings),
            'average_rating': round(sum(ratings) / len(ratings), 1) if ratings else 0,
            'highest_rating': max(ratings) if ratings else 0,
            'lowest_rating': min(ratings) if ratings else 0
        }
        
        return jsonify({
            'ratings': result,
            'stats': stats,
            'last_updated': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain user ratings error: {e}")
        return jsonify({'error': 'Failed to get CineBrain user ratings'}), 500

@require_auth
def add_rating(current_user):
    """Add or update a rating"""
    try:
        data = request.get_json()
        content_id = data.get('content_id')
        rating = data.get('rating')
        
        if not content_id or rating is None:
            return jsonify({'error': 'Content ID and rating required'}), 400
        
        if not (1 <= rating <= 10):
            return jsonify({'error': 'Rating must be between 1 and 10'}), 400
        
        # Check if rating already exists
        existing = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='rating'
        ).first()
        
        if existing:
            existing.rating = rating
            existing.timestamp = datetime.utcnow()
            message = 'Rating updated successfully'
        else:
            interaction = UserInteraction(
                user_id=current_user.id,
                content_id=content_id,
                interaction_type='rating',
                rating=rating
            )
            db.session.add(interaction)
            message = 'Rating added successfully'
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': message,
            'rating': rating
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain add rating error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to add rating'}), 500

@require_auth
def remove_rating(current_user, content_id):
    """Remove a rating"""
    try:
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='rating'
        ).first()
        
        if interaction:
            db.session.delete(interaction)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Rating removed successfully'
            }), 200
        else:
            return jsonify({
                'success': False,
                'message': 'No rating found for this content'
            }), 404
            
    except Exception as e:
        logger.error(f"Remove rating error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to remove rating'}), 500

@require_auth
def get_rating_for_content(current_user, content_id):
    """Get user's rating for specific content"""
    try:
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='rating'
        ).first()
        
        return jsonify({
            'has_rating': interaction is not None,
            'rating': interaction.rating if interaction else None,
            'rated_at': interaction.timestamp.isoformat() if interaction else None
        }), 200
        
    except Exception as e:
        logger.error(f"Get rating error: {e}")
        return jsonify({'error': 'Failed to get rating'}), 500



8. # user/routes.py
from flask import Blueprint, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
import json
import logging
import jwt
from sqlalchemy import or_

from .utils import init_user_module, add_cors_headers
from . import avatar
from . import profile
from . import watchlist
from . import favorites
from . import activity
from . import ratings
from . import dashboard
from . import settings

# Create the user blueprint
user_bp = Blueprint('user', __name__)

logger = logging.getLogger(__name__)

# Global variables (will be set by init function)
db = None
User = None
app = None

def init_user_routes(flask_app, database, models, services):
    """Initialize the user routes with dependencies"""
    global db, User, app
    
    app = flask_app
    db = database
    User = models['User']
    
    # Initialize the user module
    init_user_module(flask_app, database, models, services)
    
    logger.info("âœ… CineBrain user routes initialized successfully")

# ============================================================================
# AUTHENTICATION ROUTES
# ============================================================================

@user_bp.route('/api/register', methods=['POST', 'OPTIONS'])
def register():
    """User registration"""
    if request.method == 'OPTIONS':
        return '', 200
    
    try:
        data = request.get_json()
        
        if not data.get('username') or not data.get('email') or not data.get('password'):
            return jsonify({'error': 'Missing required fields for CineBrain account'}), 400
        
        if User.query.filter_by(username=data['username']).first():
            return jsonify({'error': 'CineBrain username already exists'}), 400
        
        if User.query.filter_by(email=data['email']).first():
            return jsonify({'error': 'CineBrain email already exists'}), 400
        
        user = User(
            username=data['username'],
            email=data['email'],
            password_hash=generate_password_hash(data['password']),
            preferred_languages=json.dumps(data.get('preferred_languages', ['english', 'telugu'])),
            preferred_genres=json.dumps(data.get('preferred_genres', [])),
            location=data.get('location', ''),
            avatar_url=data.get('avatar_url', '')
        )
        
        db.session.add(user)
        db.session.commit()
        
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(days=30)
        }, app.secret_key, algorithm='HS256')
        
        from .utils import get_enhanced_user_stats
        stats = get_enhanced_user_stats(user.id)
        
        return jsonify({
            'message': 'CineBrain user registered successfully',
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_admin': user.is_admin,
                'preferred_languages': json.loads(user.preferred_languages or '[]'),
                'preferred_genres': json.loads(user.preferred_genres or '[]'),
                'location': user.location,
                'avatar_url': user.avatar_url,
                'created_at': user.created_at.isoformat(),
                'stats': stats
            }
        }), 201
        
    except Exception as e:
        logger.error(f"CineBrain registration error: {e}")
        db.session.rollback()
        return jsonify({'error': 'CineBrain registration failed'}), 500

@user_bp.route('/api/login', methods=['POST', 'OPTIONS'])
def login():
    """User login"""
    if request.method == 'OPTIONS':
        return '', 200
    
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return jsonify({'error': 'Missing username or password'}), 400
        
        user = None
        
        if '@' in username:
            user = User.query.filter(User.email.ilike(username)).first()
        else:
            user = User.query.filter(User.username.ilike(username)).first()
        
        if not user:
            user = User.query.filter(
                or_(
                    User.username.ilike(username),
                    User.email.ilike(username)
                )
            ).first()
        
        if not user:
            return jsonify({'error': 'Invalid credentials'}), 401
        
        password_valid = check_password_hash(user.password_hash, password)
        
        if not password_valid:
            return jsonify({'error': 'Invalid credentials'}), 401
        
        user.last_active = datetime.utcnow()
        db.session.commit()
        
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(days=30)
        }, app.secret_key, algorithm='HS256')
        
        from .utils import get_enhanced_user_stats, recommendation_engine
        stats = get_enhanced_user_stats(user.id)
        
        rec_effectiveness = {}
        try:
            if recommendation_engine:
                rec_effectiveness = recommendation_engine.get_user_recommendation_metrics(user.id)
        except Exception as e:
            logger.warning(f"Could not get CineBrain recommendation effectiveness: {e}")
        
        return jsonify({
            'message': 'CineBrain login successful',
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_admin': user.is_admin,
                'preferred_languages': json.loads(user.preferred_languages or '[]'),
                'preferred_genres': json.loads(user.preferred_genres or '[]'),
                'location': user.location,
                'avatar_url': user.avatar_url,
                'last_active': user.last_active.isoformat() if user.last_active else None,
                'stats': stats,
                'recommendation_effectiveness': rec_effectiveness
            }
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain Login error: {e}")
        return jsonify({'error': 'CineBrain login failed'}), 500

# ============================================================================
# PROFILE ROUTES
# ============================================================================

@user_bp.route('/api/users/profile', methods=['GET', 'OPTIONS'])
def get_profile():
    return profile.get_user_profile()

@user_bp.route('/api/users/profile', methods=['PUT', 'OPTIONS'])
def update_profile():
    return profile.update_user_profile()

@user_bp.route('/api/users/profile/public/<username>', methods=['GET'])
def get_public_profile_route(username):
    return profile.get_public_profile(username)

@user_bp.route('/api/personalized/update-preferences', methods=['POST', 'OPTIONS'])
def update_preferences():
    return profile.update_user_preferences()

# ============================================================================
# AVATAR ROUTES
# ============================================================================

@user_bp.route('/api/users/avatar/upload', methods=['POST', 'OPTIONS'])
def upload_avatar_route():
    return avatar.upload_avatar()

@user_bp.route('/api/users/avatar/delete', methods=['DELETE', 'OPTIONS'])
def delete_avatar_route():
    return avatar.delete_avatar()

@user_bp.route('/api/users/avatar/url', methods=['GET', 'OPTIONS'])
def get_avatar_url_route():
    return avatar.get_avatar_url()

# ============================================================================
# WATCHLIST ROUTES
# ============================================================================

@user_bp.route('/api/user/watchlist', methods=['GET', 'OPTIONS'])
def get_watchlist_route():
    return watchlist.get_watchlist()

@user_bp.route('/api/user/watchlist', methods=['POST', 'OPTIONS'])
def add_to_watchlist_route():
    return watchlist.add_to_watchlist()

@user_bp.route('/api/user/watchlist/<int:content_id>', methods=['DELETE', 'OPTIONS'])
def remove_from_watchlist_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return watchlist.remove_from_watchlist(current_user, content_id)
    return wrapper()

@user_bp.route('/api/user/watchlist/<int:content_id>', methods=['GET', 'OPTIONS'])
def check_watchlist_status_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return watchlist.check_watchlist_status(current_user, content_id)
    return wrapper()

# ============================================================================
# FAVORITES ROUTES
# ============================================================================

@user_bp.route('/api/user/favorites', methods=['GET', 'OPTIONS'])
def get_favorites_route():
    return favorites.get_favorites()

@user_bp.route('/api/user/favorites', methods=['POST', 'OPTIONS'])
def add_to_favorites_route():
    return favorites.add_to_favorites()

@user_bp.route('/api/user/favorites/<int:content_id>', methods=['DELETE', 'OPTIONS'])
def remove_from_favorites_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return favorites.remove_from_favorites(current_user, content_id)
    return wrapper()

@user_bp.route('/api/user/favorites/<int:content_id>', methods=['GET', 'OPTIONS'])
def check_favorite_status_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return favorites.check_favorite_status(current_user, content_id)
    return wrapper()

# ============================================================================
# RATINGS ROUTES
# ============================================================================

@user_bp.route('/api/user/ratings', methods=['GET', 'OPTIONS'])
def get_ratings_route():
    return ratings.get_user_ratings()

@user_bp.route('/api/user/ratings', methods=['POST', 'OPTIONS'])
def add_rating_route():
    return ratings.add_rating()

@user_bp.route('/api/user/ratings/<int:content_id>', methods=['DELETE', 'OPTIONS'])
def remove_rating_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return ratings.remove_rating(current_user, content_id)
    return wrapper()

@user_bp.route('/api/user/ratings/<int:content_id>', methods=['GET', 'OPTIONS'])
def get_rating_for_content_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return ratings.get_rating_for_content(current_user, content_id)
    return wrapper()

# ============================================================================
# ACTIVITY ROUTES
# ============================================================================

@user_bp.route('/api/interactions', methods=['POST', 'OPTIONS'])
def record_interaction_route():
    return activity.record_interaction()

@user_bp.route('/api/users/<username>/activity/public', methods=['GET'])
def get_public_activity_route(username):
    return activity.get_public_activity(username)

@user_bp.route('/api/users/<username>/stats/public', methods=['GET'])
def get_public_stats_route(username):
    return activity.get_public_stats(username)

# ============================================================================
# DASHBOARD ROUTES
# ============================================================================

@user_bp.route('/api/users/analytics', methods=['GET', 'OPTIONS'])
def get_analytics_route():
    return dashboard.get_user_analytics()

@user_bp.route('/api/personalized/profile-insights', methods=['GET', 'OPTIONS'])
def get_profile_insights_route():
    return dashboard.get_profile_insights()

# ============================================================================
# PERSONALIZED RECOMMENDATION ROUTES
# ============================================================================

@user_bp.route('/api/personalized/', methods=['GET', 'OPTIONS'])
def get_personalized_recommendations():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({
                    'error': 'CineBrain recommendation engine not available',
                    'recommendations': {},
                    'fallback': True
                }), 503
            
            limit = min(int(request.args.get('limit', 50)), 100)
            categories = request.args.get('categories')
            
            if categories:
                category_list = [cat.strip() for cat in categories.split(',')]
            else:
                category_list = None
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=category_list
            )
            
            recommendations['platform'] = 'cinebrain'
            recommendations['user_tier'] = 'premium'
            recommendations['personalization_level'] = 'high'
            
            return jsonify({
                'success': True,
                'data': recommendations,
                'message': 'CineBrain personalized recommendations generated successfully',
                'user': {
                    'id': current_user.id,
                    'username': current_user.username
                },
                'metadata': {
                    'generated_at': datetime.utcnow().isoformat(),
                    'algorithm_version': '3.0',
                    'personalization_strength': recommendations.get('recommendation_metadata', {}).get('confidence_score', 0.8)
                }
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain personalized recommendations error for user {current_user.id}: {e}")
            return jsonify({
                'error': 'Failed to generate CineBrain personalized recommendations',
                'success': False,
                'data': {}
            }), 500
    
    return wrapper()

@user_bp.route('/api/personalized/for-you', methods=['GET', 'OPTIONS'])
def get_for_you_recommendations():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 30)), 50)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['for_you']
            )
            
            for_you_recs = recommendations.get('recommendations', {}).get('for_you', [])
            
            return jsonify({
                'success': True,
                'recommendations': for_you_recs,
                'total_count': len(for_you_recs),
                'user_insights': recommendations.get('profile_insights', {}),
                'metadata': recommendations.get('recommendation_metadata', {}),
                'generated_at': datetime.utcnow().isoformat()
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain For You recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain For You recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/because-you-watched', methods=['GET', 'OPTIONS'])
def get_because_you_watched():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 20)), 30)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['because_you_watched']
            )
            
            because_recs = recommendations.get('recommendations', {}).get('because_you_watched', [])
            
            return jsonify({
                'success': True,
                'recommendations': because_recs,
                'total_count': len(because_recs),
                'explanation': 'Based on your recently watched CineBrain content',
                'algorithm': 'content_similarity_and_collaborative_filtering'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Because you watched recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain because you watched recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/trending-for-you', methods=['GET', 'OPTIONS'])
def get_trending_for_you():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 25)), 40)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['trending_for_you']
            )
            
            trending_recs = recommendations.get('recommendations', {}).get('trending_for_you', [])
            
            return jsonify({
                'success': True,
                'recommendations': trending_recs,
                'total_count': len(trending_recs),
                'explanation': 'Trending CineBrain content personalized for your taste',
                'algorithm': 'hybrid_trending_personalization'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Trending for you recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain trending recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/your-language', methods=['GET', 'OPTIONS'])
def get_your_language_recommendations():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 25)), 40)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['your_language']
            )
            
            language_recs = recommendations.get('recommendations', {}).get('your_language', [])
            
            preferred_languages = json.loads(current_user.preferred_languages or '[]')
            
            return jsonify({
                'success': True,
                'recommendations': language_recs,
                'total_count': len(language_recs),
                'explanation': 'CineBrain content in your preferred languages',
                'preferred_languages': preferred_languages,
                'algorithm': 'language_preference_filtering'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Language recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain language recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/hidden-gems', methods=['GET', 'OPTIONS'])
def get_hidden_gems():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 15)), 25)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['hidden_gems']
            )
            
            gems_recs = recommendations.get('recommendations', {}).get('hidden_gems', [])
            
            return jsonify({
                'success': True,
                'recommendations': gems_recs,
                'total_count': len(gems_recs),
                'explanation': 'High-quality CineBrain content you might have missed',
                'algorithm': 'hidden_gem_discovery'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Hidden gems recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain hidden gems recommendations'}), 500
    
    return wrapper()

# ============================================================================
# SETTINGS ROUTES
# ============================================================================

@user_bp.route('/api/users/settings', methods=['GET', 'OPTIONS'])
def get_settings_route():
    return settings.get_user_settings()

@user_bp.route('/api/users/settings/account', methods=['PUT', 'OPTIONS'])
def update_account_settings_route():
    return settings.update_account_settings()

@user_bp.route('/api/users/settings/password', methods=['PUT', 'OPTIONS'])
def change_password_route():
    return settings.change_password()

@user_bp.route('/api/users/settings/delete-account', methods=['DELETE', 'OPTIONS'])
def delete_account_route():
    return settings.delete_account()

@user_bp.route('/api/users/settings/export-data', methods=['GET', 'OPTIONS'])
def export_data_route():
    return settings.export_user_data()

# ============================================================================
# HEALTH ROUTE
# ============================================================================

@user_bp.route('/api/users/health', methods=['GET'])
def users_health():
    try:
        health_info = {
            'status': 'healthy',
            'service': 'cinebrain_users',
            'timestamp': datetime.utcnow().isoformat(),
            'version': '3.1.0'
        }
        
        try:
            User.query.limit(1).first()
            health_info['database'] = 'connected'
        except Exception as e:
            health_info['database'] = f'error: {str(e)}'
            health_info['status'] = 'degraded'
        
        from .utils import recommendation_engine
        health_info['recommendation_engine'] = 'connected' if recommendation_engine else 'not_available'
        
        try:
            total_users = User.query.count()
            active_users = User.query.filter(
                User.last_active >= datetime.utcnow() - timedelta(days=7)
            ).count()
            users_with_avatars = User.query.filter(User.avatar_url.isnot(None)).count()
            
            health_info['user_metrics'] = {
                'total_users': total_users,
                'active_users_7d': active_users,
                'users_with_avatars': users_with_avatars,
                'activity_rate': round((active_users / total_users * 100), 1) if total_users > 0 else 0,
                'avatar_adoption_rate': round((users_with_avatars / total_users * 100), 1) if total_users > 0 else 0
            }
        except Exception as e:
            health_info['user_metrics'] = {'error': str(e)}
        
        health_info['features'] = {
            'personalized_recommendations': True,
            'user_analytics': True,
            'profile_management': True,
            'watchlist_favorites': True,
            'real_time_updates': True,
            'email_username_login': True,
            'avatar_service': True,
            'modular_architecture': True
        }
        
        return jsonify(health_info), 200
        
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'service': 'cinebrain_users',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# Add CORS headers to all responses
@user_bp.after_request
def after_request(response):
    return add_cors_headers(response)

# Export the initialization function
__all__ = ['user_bp', 'init_user_routes']



9. # user/settings.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from werkzeug.security import generate_password_hash, check_password_hash
from .utils import require_auth, db

logger = logging.getLogger(__name__)

@require_auth
def get_user_settings(current_user):
    """Get user account settings"""
    try:
        settings = {
            'account': {
                'username': current_user.username,
                'email': current_user.email,
                'created_at': current_user.created_at.isoformat(),
                'last_active': current_user.last_active.isoformat() if current_user.last_active else None
            },
            'preferences': {
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location
            },
            'privacy': {
                'profile_visibility': 'public',  # This could be expanded
                'activity_visibility': 'public'
            },
            'notifications': {
                'email_recommendations': True,  # These could be database fields
                'new_release_alerts': True,
                'watchlist_updates': True
            }
        }
        
        return jsonify({
            'success': True,
            'settings': settings
        }), 200
        
    except Exception as e:
        logger.error(f"Get user settings error: {e}")
        return jsonify({'error': 'Failed to get user settings'}), 500

@require_auth
def update_account_settings(current_user):
    """Update account settings"""
    try:
        data = request.get_json()
        updated_fields = []
        
        # Update email if provided
        if 'email' in data and data['email'] != current_user.email:
            # Check if email is already taken
            from .utils import User
            existing_email = User.query.filter_by(email=data['email']).first()
            if existing_email and existing_email.id != current_user.id:
                return jsonify({'error': 'Email already in use'}), 400
            
            current_user.email = data['email']
            updated_fields.append('email')
        
        # Update username if provided
        if 'username' in data and data['username'] != current_user.username:
            # Check if username is already taken
            from .utils import User
            existing_username = User.query.filter_by(username=data['username']).first()
            if existing_username and existing_username.id != current_user.id:
                return jsonify({'error': 'Username already in use'}), 400
            
            current_user.username = data['username']
            updated_fields.append('username')
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Account settings updated: {", ".join(updated_fields)}',
            'updated_fields': updated_fields
        }), 200
        
    except Exception as e:
        logger.error(f"Update account settings error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update account settings'}), 500

@require_auth
def change_password(current_user):
    """Change user password"""
    try:
        data = request.get_json()
        
        current_password = data.get('current_password')
        new_password = data.get('new_password')
        
        if not current_password or not new_password:
            return jsonify({'error': 'Current password and new password required'}), 400
        
        # Verify current password
        if not check_password_hash(current_user.password_hash, current_password):
            return jsonify({'error': 'Current password is incorrect'}), 400
        
        # Validate new password
        if len(new_password) < 6:
            return jsonify({'error': 'New password must be at least 6 characters'}), 400
        
        # Update password
        current_user.password_hash = generate_password_hash(new_password)
        db.session.commit()
        
        logger.info(f"Password changed for user {current_user.username}")
        
        return jsonify({
            'success': True,
            'message': 'Password changed successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Change password error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to change password'}), 500

@require_auth
def delete_account(current_user):
    """Delete user account (soft delete for now)"""
    try:
        data = request.get_json()
        password = data.get('password')
        
        if not password:
            return jsonify({'error': 'Password required to delete account'}), 400
        
        # Verify password
        if not check_password_hash(current_user.password_hash, password):
            return jsonify({'error': 'Incorrect password'}), 400
        
        # For now, just mark as inactive instead of actual deletion
        # In production, you might want to anonymize data instead
        current_user.username = f"deleted_user_{current_user.id}"
        current_user.email = f"deleted_{current_user.id}@cinebrain.deleted"
        current_user.avatar_url = None
        current_user.preferred_languages = None
        current_user.preferred_genres = None
        current_user.location = None
        
        db.session.commit()
        
        logger.info(f"Account deleted for user ID {current_user.id}")
        
        return jsonify({
            'success': True,
            'message': 'Account deleted successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Delete account error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to delete account'}), 500

@require_auth
def export_user_data(current_user):
    """Export user data"""
    try:
        from .utils import UserInteraction
        
        # Get user interactions
        interactions = UserInteraction.query.filter_by(user_id=current_user.id).all()
        
        user_data = {
            'account': {
                'username': current_user.username,
                'email': current_user.email,
                'created_at': current_user.created_at.isoformat(),
                'last_active': current_user.last_active.isoformat() if current_user.last_active else None
            },
            'preferences': {
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location
            },
            'interactions': [
                {
                    'content_id': interaction.content_id,
                    'interaction_type': interaction.interaction_type,
                    'rating': interaction.rating,
                    'timestamp': interaction.timestamp.isoformat(),
                    'metadata': json.loads(interaction.interaction_metadata or '{}')
                }
                for interaction in interactions
            ],
            'exported_at': datetime.utcnow().isoformat()
        }
        
        return jsonify({
            'success': True,
            'data': user_data
        }), 200
        
    except Exception as e:
        logger.error(f"Export user data error: {e}")
        return jsonify({'error': 'Failed to export user data'}), 500


10. # user/utils.py
from flask import request, jsonify
from datetime import datetime, timedelta
import json
import logging
import jwt
from functools import wraps
from collections import defaultdict, Counter
import numpy as np

logger = logging.getLogger(__name__)

# Global variables (will be set by init function)
db = None
User = None
Content = None
UserInteraction = None
Review = None
app = None
recommendation_engine = None
cache = None
content_service = None

def init_user_module(flask_app, database, models, services):
    """Initialize the user module with dependencies"""
    global db, User, Content, UserInteraction, Review, app, recommendation_engine, cache, content_service
    
    app = flask_app
    db = database
    User = models['User']
    Content = models['Content']
    UserInteraction = models['UserInteraction']
    Review = models.get('Review')
    cache = services.get('cache')
    content_service = services.get('ContentService')
    
    try:
        from services.personalized import get_recommendation_engine
        recommendation_engine = get_recommendation_engine()
        logger.info("âœ… CineBrain personalized recommendation engine connected to user module")
    except Exception as e:
        logger.warning(f"Could not connect to CineBrain recommendation engine: {e}")

def require_auth(f):
    """Authentication decorator for user routes"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method == 'OPTIONS':
            return '', 200
            
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'error': 'No CineBrain token provided'}), 401
        
        try:
            token = token.replace('Bearer ', '')
            data = jwt.decode(token, app.secret_key, algorithms=['HS256'])
            current_user = User.query.get(data['user_id'])
            if not current_user:
                return jsonify({'error': 'Invalid CineBrain token'}), 401
            
            current_user.last_active = datetime.utcnow()
            try:
                db.session.commit()
            except Exception as e:
                logger.warning(f"Failed to update CineBrain user last_active: {e}")
                db.session.rollback()
                
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'CineBrain token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid CineBrain token'}), 401
        except Exception as e:
            logger.error(f"CineBrain authentication error: {e}")
            return jsonify({'error': 'CineBrain authentication failed'}), 401
        
        return f(current_user, *args, **kwargs)
    return decorated_function

def get_enhanced_user_stats(user_id):
    """Get comprehensive user statistics"""
    try:
        try:
            from services.auth import EnhancedUserAnalytics
            return EnhancedUserAnalytics.get_comprehensive_user_stats(user_id)
        except ImportError:
            logger.warning("CineBrain enhanced analytics not available, using basic stats")
            return get_basic_user_stats(user_id)
    except Exception as e:
        logger.error(f"Error getting CineBrain user stats: {e}")
        return {}

def get_basic_user_stats(user_id):
    """Get basic user statistics"""
    try:
        if not UserInteraction:
            return {
                'total_interactions': 0,
                'content_watched': 0,
                'favorites': 0,
                'watchlist_items': 0,
                'ratings_given': 0
            }
        
        interactions = UserInteraction.query.filter_by(user_id=user_id).all()
        
        stats = {
            'total_interactions': len(interactions),
            'content_watched': len([i for i in interactions if i.interaction_type == 'view']),
            'favorites': len([i for i in interactions if i.interaction_type == 'favorite']),
            'watchlist_items': len([i for i in interactions if i.interaction_type == 'watchlist']),
            'ratings_given': len([i for i in interactions if i.interaction_type == 'rating']),
            'likes_given': len([i for i in interactions if i.interaction_type == 'like']),
            'searches_made': len([i for i in interactions if i.interaction_type == 'search'])
        }
        
        ratings = [i.rating for i in interactions if i.rating is not None]
        stats['average_rating'] = round(sum(ratings) / len(ratings), 1) if ratings else 0
        
        return stats
        
    except Exception as e:
        logger.error(f"Error calculating CineBrain basic stats: {e}")
        return {}

def create_minimal_content_record(content_id, content_info):
    """Create minimal content record if content doesn't exist"""
    try:
        content_type = str(content_info.get('content_type', 'movie')).strip().lower()
        content_type = ' '.join(content_type.split())
        if content_type not in ['movie', 'tv', 'anime']:
            content_type = 'movie'
        
        title = str(content_info.get('title', 'Unknown Title')).strip()[:255]
        if not title:
            title = 'Unknown Title'
        
        timestamp = int(datetime.utcnow().timestamp())
        slug = f"content-{content_id}-{timestamp}"
        if len(slug) > 150:
            slug = slug[:150]
        
        overview = str(content_info.get('overview', '')).strip()[:1000]
        
        poster_path = content_info.get('poster_path')
        if poster_path and len(str(poster_path)) > 255:
            poster_path = str(poster_path)[:255]
        
        content_record = Content(
            id=content_id,
            title=title,
            content_type=content_type,
            poster_path=poster_path,
            rating=float(content_info.get('rating', 0)) if content_info.get('rating') else 0,
            overview=overview,
            release_date=None,
            tmdb_id=content_info.get('tmdb_id'),
            genres='[]',
            languages='[]',
            slug=slug
        )
        
        if content_info.get('release_date'):
            try:
                release_date_str = str(content_info['release_date'])[:10]
                content_record.release_date = datetime.strptime(
                    release_date_str, '%Y-%m-%d'
                ).date()
            except (ValueError, TypeError):
                logger.warning(f"Invalid release date format: {content_info.get('release_date')}")
        
        db.session.add(content_record)
        db.session.commit()
        logger.info(f"CineBrain: Created minimal content record for ID {content_id}")
        return content_record
        
    except Exception as e:
        logger.error(f"Failed to create minimal content record for ID {content_id}: {e}")
        db.session.rollback()
        return None

def format_content_for_response(content, interaction=None):
    """Format content object for API response"""
    youtube_url = None
    if content.youtube_trailer_id:
        youtube_url = f"https://www.youtube.com/watch?v={content.youtube_trailer_id}"
    
    formatted = {
        'id': content.id,
        'slug': content.slug,
        'title': content.title,
        'content_type': content.content_type,
        'genres': json.loads(content.genres or '[]'),
        'rating': content.rating,
        'release_date': content.release_date.isoformat() if content.release_date else None,
        'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path,
        'youtube_trailer': youtube_url,
        'is_new_release': content.is_new_release,
        'is_trending': content.is_trending
    }
    
    if interaction:
        formatted['added_at'] = interaction.timestamp.isoformat()
        if hasattr(interaction, 'rating') and interaction.rating:
            formatted['user_rating'] = interaction.rating
    
    return formatted

def add_cors_headers(response):
    """Add CORS headers to response"""
    origin = request.headers.get('Origin')
    allowed_origins = [
        'https://cinebrain.vercel.app',
        'http://127.0.0.1:5500',
        'http://127.0.0.1:5501',
        'http://localhost:3000',
        'http://localhost:5173'
    ]
    
    if origin in allowed_origins:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type,Authorization'
        response.headers['Access-Control-Allow-Methods'] = 'GET,PUT,POST,DELETE,OPTIONS'
        response.headers['Access-Control-Allow-Credentials'] = 'true'
    
    return response


11. # user/watchlist.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from .utils import require_auth, db, UserInteraction, Content, format_content_for_response, recommendation_engine

logger = logging.getLogger(__name__)

@require_auth
def get_watchlist(current_user):
    """Get user's watchlist"""
    try:
        watchlist_interactions = UserInteraction.query.filter_by(
            user_id=current_user.id,
            interaction_type='watchlist'
        ).order_by(UserInteraction.timestamp.desc()).all()
        
        content_ids = [interaction.content_id for interaction in watchlist_interactions]
        contents = Content.query.filter(Content.id.in_(content_ids)).all()
        content_map = {content.id: content for content in contents}
        
        result = []
        for interaction in watchlist_interactions:
            content = content_map.get(interaction.content_id)
            if content:
                formatted_content = format_content_for_response(content, interaction)
                result.append(formatted_content)
        
        return jsonify({
            'watchlist': result,
            'total_count': len(result),
            'last_updated': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain watchlist error: {e}")
        return jsonify({'error': 'Failed to get CineBrain watchlist'}), 500

@require_auth
def add_to_watchlist(current_user):
    """Add content to watchlist"""
    try:
        data = request.get_json()
        content_id = data.get('content_id')
        
        if not content_id:
            return jsonify({'error': 'Content ID required'}), 400
        
        # Check if already in watchlist
        existing = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='watchlist'
        ).first()
        
        if existing:
            return jsonify({
                'success': True,
                'message': 'Already in CineBrain watchlist'
            }), 200
        
        # Add to watchlist
        interaction = UserInteraction(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='watchlist'
        )
        
        db.session.add(interaction)
        db.session.commit()
        
        # Update recommendation engine
        if recommendation_engine:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'content_id': content_id,
                        'interaction_type': 'watchlist'
                    }
                )
            except Exception as e:
                logger.warning(f"Failed to update CineBrain recommendations: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Added to CineBrain watchlist'
        }), 201
        
    except Exception as e:
        logger.error(f"Add to CineBrain watchlist error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to add to CineBrain watchlist'}), 500

@require_auth
def remove_from_watchlist(current_user, content_id):
    """Remove content from watchlist"""
    try:
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='watchlist'
        ).first()
        
        if interaction:
            db.session.delete(interaction)
            db.session.commit()
            
            if recommendation_engine:
                try:
                    recommendation_engine.update_user_preferences_realtime(
                        current_user.id,
                        {
                            'content_id': content_id,
                            'interaction_type': 'remove_watchlist'
                        }
                    )
                except Exception as e:
                    logger.warning(f"Failed to update CineBrain recommendations: {e}")
            
            return jsonify({
                'success': True,
                'message': 'Removed from CineBrain watchlist'
            }), 200
        else:
            return jsonify({
                'success': False,
                'message': 'Content not in CineBrain watchlist'
            }), 404
            
    except Exception as e:
        logger.error(f"Remove from CineBrain watchlist error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to remove from CineBrain watchlist'}), 500

@require_auth
def check_watchlist_status(current_user, content_id):
    """Check if content is in watchlist"""
    try:
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,
            interaction_type='watchlist'
        ).first()
        
        return jsonify({
            'in_watchlist': interaction is not None,
            'added_at': interaction.timestamp.isoformat() if interaction else None
        }), 200
        
    except Exception as e:
        logger.error(f"Check CineBrain watchlist status error: {e}")
        return jsonify({'error': 'Failed to check CineBrain watchlist status'}), 500