memorize my remaining admin folder files


4. # admin/service.py

import os
import json
import logging
import redis
import uuid
from datetime import datetime, timedelta
from urllib.parse import urlparse
from sqlalchemy import func, desc, and_, or_
from collections import defaultdict

logger = logging.getLogger(__name__)

REDIS_URL = os.environ.get('REDIS_URL')

class NotificationType:
    NEW_TICKET = "NEW_TICKET"
    URGENT_TICKET = "URGENT_TICKET"
    TICKET_ESCALATION = "TICKET_ESCALATION"
    SLA_BREACH = "SLA_BREACH"
    FEEDBACK_RECEIVED = "FEEDBACK_RECEIVED"
    SYSTEM_ALERT = "SYSTEM_ALERT"
    USER_ACTIVITY = "user_activity"
    CONTENT_ADDED = "content_added"

class AdminEmailPreferences:
    """Email preference model for database integration"""
    def __init__(self, db):
        self.db = db
        
        class AdminEmailPreferencesModel(db.Model):
            __tablename__ = 'admin_email_preferences'
            
            id = db.Column(db.Integer, primary_key=True)
            admin_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
            
            # Support System Alerts (Critical - usually ON)
            urgent_tickets = db.Column(db.Boolean, default=True)
            sla_breaches = db.Column(db.Boolean, default=True)
            system_alerts = db.Column(db.Boolean, default=True)
            
            # Content Management Alerts (Configurable)
            content_added = db.Column(db.Boolean, default=True)
            recommendation_created = db.Column(db.Boolean, default=True)
            recommendation_updated = db.Column(db.Boolean, default=False)  # OFF by default
            recommendation_deleted = db.Column(db.Boolean, default=False)  # OFF by default
            recommendation_published = db.Column(db.Boolean, default=True)
            
            # User Activity Alerts (Configurable)
            user_feedback = db.Column(db.Boolean, default=True)
            regular_tickets = db.Column(db.Boolean, default=False)  # OFF by default
            
            # System Operations (Usually OFF)
            cache_operations = db.Column(db.Boolean, default=False)
            bulk_operations = db.Column(db.Boolean, default=False)
            slug_updates = db.Column(db.Boolean, default=False)
            
            created_at = db.Column(db.DateTime, default=datetime.utcnow)
            updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
            
            __table_args__ = (db.UniqueConstraint('admin_id'),)
        
        self.Model = AdminEmailPreferencesModel

class AdminEmailService:
    def __init__(self, services):
        self.email_service = services.get('email_service')
        
        if not self.email_service:
            try:
                from auth.service import email_service as auth_email_service
                self.email_service = auth_email_service
                logger.info("‚úÖ Email service loaded from auth module for admin")
            except Exception as e:
                logger.warning(f"Could not load auth email service for admin: {e}")
        
        self.is_configured = (
            self.email_service is not None and 
            hasattr(self.email_service, 'email_enabled') and 
            self.email_service.email_enabled and
            hasattr(self.email_service, 'queue_email')
        )
        
        if self.is_configured:
            logger.info("‚úÖ Admin email service configured successfully with Brevo")
        else:
            logger.warning("‚ö†Ô∏è Admin email service not configured - using fallback mode")
    
    def send_admin_notification(self, subject: str, content: str, admin_emails: list, is_urgent: bool = False):
        try:
            if not self.is_configured:
                logger.warning("Email service not configured, skipping admin email notification")
                return False
            
            if not admin_emails:
                logger.warning("No admin emails provided")
                return False
            
            from auth.admin_mail_templates import get_admin_template
            
            html, text = get_admin_template(
                'admin_notification',
                subject=subject,
                content=content,
                is_urgent=is_urgent,
                timestamp=datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
            )
            
            success_count = 0
            for email in admin_emails:
                try:
                    admin_name = email.split('@')[0].replace('.', ' ').title()
                    
                    self.email_service.queue_email(
                        to=email,
                        subject=f"[CineBrain Admin] {subject}",
                        html=html,
                        text=text,
                        priority='urgent' if is_urgent else 'high',
                        to_name=admin_name
                    )
                    success_count += 1
                    logger.info(f"‚úÖ Admin notification email queued for {email}: {subject}")
                except Exception as e:
                    logger.error(f"‚ùå Failed to queue email for {email}: {e}")
            
            if success_count > 0:
                logger.info(f"‚úÖ Admin notification emails queued successfully: {subject} ({success_count}/{len(admin_emails)})")
                return True
            else:
                logger.error(f"‚ùå Failed to queue any admin notification emails")
                return False
            
        except Exception as e:
            logger.error(f"‚ùå Admin email error: {e}")
            return False

class AdminNotificationService:
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.email_service = AdminEmailService(services)
        self.redis_client = self._init_redis()
        
        self.AdminNotification = models.get('AdminNotification')
        self.CannedResponse = models.get('CannedResponse')
        self.SupportMetrics = models.get('SupportMetrics')
        self.AdminEmailPreferences = models.get('AdminEmailPreferences')
        
        # Create AdminEmailPreferences model if not provided
        if not self.AdminEmailPreferences:
            try:
                email_prefs = AdminEmailPreferences(db)
                self.AdminEmailPreferences = email_prefs.Model
                logger.info("‚úÖ AdminEmailPreferences model created dynamically")
            except Exception as e:
                logger.error(f"‚ùå Failed to create AdminEmailPreferences model: {e}")
                self.AdminEmailPreferences = None
        
        if not self.AdminNotification:
            logger.warning("‚ö†Ô∏è AdminNotification model not available")
        if not self.CannedResponse:
            logger.warning("‚ö†Ô∏è CannedResponse model not available")
        if not self.SupportMetrics:
            logger.warning("‚ö†Ô∏è SupportMetrics model not available")
        if not self.AdminEmailPreferences:
            logger.warning("‚ö†Ô∏è AdminEmailPreferences model not available")
        
        logger.info("‚úÖ Admin notification service initialized (EMAIL ONLY)")
    
    def _init_redis(self):
        try:
            if not REDIS_URL:
                logger.warning("Redis URL not configured for admin notifications")
                return None
            
            url = urlparse(REDIS_URL)
            redis_client = redis.StrictRedis(
                host=url.hostname,
                port=url.port,
                password=url.password,
                decode_responses=True,
                socket_connect_timeout=5,
                socket_timeout=5,
                retry_on_timeout=True,
                health_check_interval=30
            )
            redis_client.ping()
            logger.info("‚úÖ Admin Redis connected successfully")
            return redis_client
            
        except Exception as e:
            logger.error(f"‚ùå Admin Redis connection failed: {e}")
            return None
    
    def _should_send_email(self, admin_id: int, alert_type: str) -> bool:
        """Check if email should be sent based on admin preferences"""
        try:
            if not self.AdminEmailPreferences:
                return True  # Default to sending if preferences not available
            
            preferences = self.AdminEmailPreferences.query.filter_by(admin_id=admin_id).first()
            if not preferences:
                # Create default preferences for new admin
                preferences = self._create_default_preferences(admin_id)
                if not preferences:
                    return True  # Default to sending if creation failed
            
            # Map alert types to preference fields
            alert_mapping = {
                'urgent_ticket': preferences.urgent_tickets,
                'new_ticket': preferences.regular_tickets,
                'sla_breach': preferences.sla_breaches,
                'system_alert': preferences.system_alerts,
                'content_added': preferences.content_added,
                'recommendation_created': preferences.recommendation_created,
                'recommendation_updated': preferences.recommendation_updated,
                'recommendation_deleted': preferences.recommendation_deleted,
                'recommendation_published': preferences.recommendation_published,
                'feedback_received': preferences.user_feedback,
                'cache_operation': preferences.cache_operations,
                'bulk_operation': preferences.bulk_operations,
                'slug_update': preferences.slug_updates
            }
            
            return alert_mapping.get(alert_type, True)  # Default to True for unknown types
            
        except Exception as e:
            logger.error(f"Error checking email preferences: {e}")
            return True  # Default to sending on error
    
    def _create_default_preferences(self, admin_id: int):
        """Create default preferences for new admin"""
        try:
            preferences = self.AdminEmailPreferences(admin_id=admin_id)
            self.db.session.add(preferences)
            self.db.session.commit()
            logger.info(f"‚úÖ Default email preferences created for admin {admin_id}")
            return preferences
        except Exception as e:
            logger.error(f"Error creating default preferences for admin {admin_id}: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            return None
    
    def create_notification(self, notification_type: str, title: str, message: str, 
                          admin_id: int = None, related_ticket_id: int = None, 
                          related_content_id: int = None, is_urgent: bool = False,
                          action_required: bool = False, action_url: str = None,
                          metadata: dict = None, alert_type: str = None):
        """Enhanced notification creation with email preferences"""
        try:
            notification = None
            if not self.AdminNotification:
                logger.warning("AdminNotification model not available, skipping database notification")
            else:
                try:
                    notification = self.AdminNotification(
                        notification_type=notification_type,
                        title=title,
                        message=message,
                        admin_id=admin_id,
                        related_ticket_id=related_ticket_id,
                        related_content_id=related_content_id,
                        is_urgent=is_urgent,
                        action_required=action_required,
                        action_url=action_url,
                        notification_metadata=metadata or {}
                    )
                    
                    self.db.session.add(notification)
                    self.db.session.commit()
                    logger.info(f"‚úÖ Database notification created: {title}")
                except Exception as e:
                    logger.error(f"Database notification creation failed: {e}")
                    try:
                        self.db.session.rollback()
                    except:
                        pass
            
            # Email notifications with preference checking
            if self.email_service and self.email_service.is_configured:
                try:
                    admin_users = self.User.query.filter_by(is_admin=True).all()
                    
                    # Filter admins based on their email preferences
                    admins_to_notify = []
                    for admin in admin_users:
                        if admin.email and self._should_send_email(admin.id, alert_type or notification_type.lower()):
                            admins_to_notify.append(admin.email)
                    
                    # Add environment admin email if configured
                    env_admin_email = os.environ.get('ADMIN_EMAIL')
                    if env_admin_email and env_admin_email not in admins_to_notify:
                        # Check preferences for environment admin too
                        env_admin = self.User.query.filter_by(email=env_admin_email).first()
                        if env_admin and self._should_send_email(env_admin.id, alert_type or notification_type.lower()):
                            admins_to_notify.append(env_admin_email)
                        elif not env_admin:
                            # Environment admin not in database, send for critical alerts only
                            critical_alerts = ['urgent_ticket', 'sla_breach', 'system_alert']
                            if (alert_type or notification_type.lower()) in critical_alerts:
                                admins_to_notify.append(env_admin_email)
                    
                    if admins_to_notify:
                        self.email_service.send_admin_notification(title, message, admins_to_notify, is_urgent)
                        logger.info(f"‚úÖ Email notifications sent to {len(admins_to_notify)} admins: {title}")
                    else:
                        logger.info(f"üìß No admins configured to receive '{alert_type or notification_type}' emails")
                        
                except Exception as e:
                    logger.warning(f"Admin email notification failed: {e}")
            
            if self.redis_client:
                try:
                    notification_data = {
                        'id': notification.id if notification else f"temp_{int(datetime.utcnow().timestamp())}",
                        'type': notification_type,
                        'title': title,
                        'message': message,
                        'is_urgent': is_urgent,
                        'action_required': action_required,
                        'action_url': action_url,
                        'timestamp': datetime.utcnow().isoformat()
                    }
                    self.redis_client.lpush('admin_notifications', json.dumps(notification_data))
                    self.redis_client.ltrim('admin_notifications', 0, 99)
                    self.redis_client.expire('admin_notifications', 86400)
                    logger.info(f"‚úÖ Redis notification stored: {title}")
                except Exception as e:
                    logger.error(f"Redis notification error: {e}")
            
            logger.info(f"‚úÖ Admin notification created successfully (EMAIL ONLY): {title}")
            return notification if notification else True
            
        except Exception as e:
            logger.error(f"‚ùå Error creating admin notification: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            return None
    
    def notify_new_ticket(self, ticket):
        try:
            is_urgent = ticket.priority == 'urgent'
            alert_type = 'urgent_ticket' if is_urgent else 'new_ticket'
            
            self.create_notification(
                NotificationType.NEW_TICKET if not is_urgent else NotificationType.URGENT_TICKET,
                f"New {'Urgent ' if is_urgent else ''}Support Ticket",
                f"Ticket #{ticket.ticket_number} created by {ticket.user_name}\n"
                f"Subject: {ticket.subject}\n"
                f"Priority: {ticket.priority.upper()}\n"
                f"Category: {ticket.category.name if hasattr(ticket, 'category') and ticket.category else 'Unknown'}",
                related_ticket_id=ticket.id,
                is_urgent=is_urgent,
                action_required=True,
                action_url=f"/admin/support/tickets/{ticket.id}",
                metadata={
                    'ticket_number': ticket.ticket_number,
                    'priority': ticket.priority,
                    'user_email': ticket.user_email
                },
                alert_type=alert_type
            )
            logger.info(f"‚úÖ New ticket notification sent (EMAIL): #{ticket.ticket_number}")
        except Exception as e:
            logger.error(f"‚ùå Error notifying new ticket: {e}")
    
    def notify_sla_breach(self, ticket):
        try:
            self.create_notification(
                NotificationType.SLA_BREACH,
                f"SLA Breach - Ticket #{ticket.ticket_number}",
                f"Ticket #{ticket.ticket_number} has exceeded its SLA deadline\n"
                f"Created: {ticket.created_at.strftime('%Y-%m-%d %H:%M UTC')}\n"
                f"Deadline: {ticket.sla_deadline.strftime('%Y-%m-%d %H:%M UTC') if ticket.sla_deadline else 'N/A'}\n"
                f"Priority: {ticket.priority.upper()}",
                related_ticket_id=ticket.id,
                is_urgent=True,
                action_required=True,
                action_url=f"/admin/support/tickets/{ticket.id}",
                metadata={
                    'ticket_number': ticket.ticket_number,
                    'sla_deadline': ticket.sla_deadline.isoformat() if ticket.sla_deadline else None
                },
                alert_type='sla_breach'
            )
            logger.info(f"‚úÖ SLA breach notification sent (EMAIL): #{ticket.ticket_number}")
        except Exception as e:
            logger.error(f"‚ùå Error notifying SLA breach: {e}")
    
    def notify_feedback_received(self, feedback):
        try:
            feedback_type = getattr(feedback, 'feedback_type', 'general')
            rating = getattr(feedback, 'rating', 0)
            
            self.create_notification(
                NotificationType.FEEDBACK_RECEIVED,
                "New User Feedback Received",
                f"Feedback from {feedback.user_name}\n"
                f"Type: {feedback_type.replace('_', ' ').title() if isinstance(feedback_type, str) else 'General'}\n"
                f"Subject: {feedback.subject}\n"
                f"Rating: {'‚≠ê' * rating if rating else 'No rating'}",
                action_required=False,
                action_url=f"/admin/support/feedback/{feedback.id}",
                metadata={
                    'feedback_type': feedback_type if isinstance(feedback_type, str) else 'general',
                    'user_email': feedback.user_email,
                    'rating': rating
                },
                alert_type='feedback_received'
            )
            logger.info(f"‚úÖ Feedback notification sent (EMAIL): feedback #{feedback.id}")
        except Exception as e:
            logger.error(f"‚ùå Error notifying feedback: {e}")
    
    def notify_system_alert(self, alert_type_param: str, title: str, details: str, is_urgent: bool = False):
        try:
            self.create_notification(
                NotificationType.SYSTEM_ALERT,
                f"System Alert: {title}",
                f"Alert Type: {alert_type_param}\n"
                f"Details: {details}\n"
                f"Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}",
                is_urgent=is_urgent,
                action_required=True,
                action_url="/admin/system-health",
                metadata={
                    'alert_type': alert_type_param,
                    'timestamp': datetime.utcnow().isoformat()
                },
                alert_type='system_alert'
            )
            logger.info(f"‚úÖ System alert notification sent (EMAIL): {title}")
        except Exception as e:
            logger.error(f"‚ùå Error notifying system alert: {e}")

class AdminService:
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.Content = models['Content']
        self.UserInteraction = models['UserInteraction']
        self.AdminRecommendation = models['AdminRecommendation']
        
        self.AdminNotification = models.get('AdminNotification')
        self.CannedResponse = models.get('CannedResponse')
        self.SupportMetrics = models.get('SupportMetrics')
        self.AdminEmailPreferences = models.get('AdminEmailPreferences')
        
        self.TMDBService = services.get('TMDBService')
        self.JikanService = services.get('JikanService')
        self.ContentService = services.get('ContentService')
        self.cache = services.get('cache')
        
        try:
            from admin.telegram import TelegramService
            self.telegram_service = TelegramService
        except ImportError:
            self.telegram_service = None
        
        self.notification_service = AdminNotificationService(app, db, models, services)
        
        logger.info("‚úÖ Admin service initialized")
    
    def search_external_content(self, query: str, source: str, page: int = 1):
        try:
            results = []
            
            if source == 'tmdb':
                tmdb_results = self.TMDBService.search_content(query, page=page)
                if tmdb_results:
                    for item in tmdb_results.get('results', []):
                        results.append({
                            'id': item['id'],
                            'title': item.get('title') or item.get('name'),
                            'content_type': 'movie' if 'title' in item else 'tv',
                            'release_date': item.get('release_date') or item.get('first_air_date'),
                            'poster_path': f"https://image.tmdb.org/t/p/w300{item['poster_path']}" if item.get('poster_path') else None,
                            'overview': item.get('overview'),
                            'rating': item.get('vote_average'),
                            'vote_average': item.get('vote_average'),
                            'vote_count': item.get('vote_count'),
                            'popularity': item.get('popularity'),
                            'genre_ids': item.get('genre_ids', []),
                            'original_language': item.get('original_language'),
                            'backdrop_path': item.get('backdrop_path'),
                            'source': 'tmdb'
                        })
            
            elif source == 'anime':
                anime_results = self.JikanService.search_anime(query, page=page)
                if anime_results:
                    for anime in anime_results.get('data', []):
                        results.append({
                            'id': anime['mal_id'],
                            'title': anime.get('title'),
                            'content_type': 'anime',
                            'release_date': anime.get('aired', {}).get('from'),
                            'poster_path': anime.get('images', {}).get('jpg', {}).get('image_url'),
                            'overview': anime.get('synopsis'),
                            'rating': anime.get('score'),
                            'vote_average': anime.get('score'),
                            'vote_count': anime.get('scored_by'),
                            'popularity': anime.get('popularity'),
                            'genres': [genre.get('name') for genre in anime.get('genres', [])],
                            'source': 'anime'
                        })
            
            logger.info(f"‚úÖ External content search completed: {len(results)} results for '{query}'")
            return results
            
        except Exception as e:
            logger.error(f"External search error: {e}")
            return []
    
    def save_external_content(self, data):
        try:
            existing_content = None
            
            if data.get('source') == 'anime' and data.get('id'):
                mal_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                existing_content = self.Content.query.filter_by(mal_id=mal_id).first()
            elif data.get('id'):
                tmdb_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                existing_content = self.Content.query.filter_by(tmdb_id=tmdb_id).first()
            
            if existing_content:
                logger.info(f"Content already exists: {existing_content.title}")
                return {
                    'message': 'Content already exists',
                    'content_id': existing_content.id,
                    'created': False
                }
            
            release_date = None
            if data.get('release_date'):
                try:
                    from datetime import datetime
                    release_date = datetime.strptime(data['release_date'][:10], '%Y-%m-%d').date()
                except:
                    release_date = None
            
            # YouTube trailer lookup with proper error handling
            youtube_trailer_id = None
            try:
                if self.ContentService and hasattr(self.ContentService, 'get_youtube_trailer'):
                    youtube_trailer_id = self.ContentService.get_youtube_trailer(
                        data.get('title'), 
                        data.get('content_type')
                    )
                else:
                    # Fallback: try to extract from data or set to None
                    youtube_trailer_id = data.get('youtube_trailer_id') or None
                    logger.info(f"YouTube trailer lookup skipped - ContentService not available or method missing")
            except Exception as e:
                logger.warning(f"YouTube trailer lookup failed for '{data.get('title')}': {e}")
                youtube_trailer_id = None
            
            if data.get('source') == 'anime':
                mal_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                content = self.Content(
                    mal_id=mal_id,
                    title=data.get('title'),
                    original_title=data.get('original_title'),
                    content_type='anime',
                    genres=json.dumps(data.get('genres', [])),
                    anime_genres=json.dumps(data.get('anime_genres', [])),
                    languages=json.dumps(['japanese']),
                    release_date=release_date,
                    rating=data.get('rating'),
                    overview=data.get('overview'),
                    poster_path=data.get('poster_path'),
                    youtube_trailer_id=youtube_trailer_id
                )
            else:
                tmdb_id = int(data['id']) if isinstance(data['id'], str) and data['id'].isdigit() else data['id']
                content = self.Content(
                    tmdb_id=tmdb_id,
                    title=data.get('title'),
                    original_title=data.get('original_title'),
                    content_type=data.get('content_type', 'movie'),
                    genres=json.dumps(data.get('genres', [])),
                    languages=json.dumps(data.get('languages', ['en'])),
                    release_date=release_date,
                    runtime=data.get('runtime'),
                    rating=data.get('rating'),
                    vote_count=data.get('vote_count'),
                    popularity=data.get('popularity'),
                    overview=data.get('overview'),
                    poster_path=data.get('poster_path'),
                    backdrop_path=data.get('backdrop_path'),
                    youtube_trailer_id=youtube_trailer_id
                )
            
            # Ensure slug generation with proper error handling
            try:
                if hasattr(content, 'ensure_slug'):
                    content.ensure_slug()
                else:
                    # Fallback slug generation
                    if content.title:
                        import re
                        slug = re.sub(r'[^\w\s-]', '', content.title.lower())
                        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
                        content.slug = slug[:150] if slug else f"content-{content.tmdb_id or content.mal_id or 'unknown'}"
                    logger.info(f"Generated fallback slug: {content.slug}")
            except Exception as e:
                logger.warning(f"Slug generation failed for '{content.title}': {e}")
                # Set a basic slug as fallback
                content.slug = f"content-{content.tmdb_id or content.mal_id or int(datetime.utcnow().timestamp())}"
            
            self.db.session.add(content)
            self.db.session.commit()
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"New {content.content_type.title()} Added",
                        f"'{content.title}' has been added to CineBrain\n"
                        f"Rating: {content.rating or 'N/A'}/10\n"
                        f"Type: {content.content_type}",
                        related_content_id=content.id,
                        action_url=f"/admin/content/{content.id}",
                        alert_type='content_added'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create content notification: {e}")
            
            logger.info(f"‚úÖ External content saved: {content.title}")
            return {
                'message': 'Content saved successfully',
                'content_id': content.id,
                'created': True
            }
            
        except Exception as e:
            try:
                self.db.session.rollback()
            except:
                pass
            logger.error(f"Error saving content: {e}")
            raise e
    
    def create_recommendation_from_external_content(self, admin_user, content_data, recommendation_type, description, status='draft', publish_to_telegram=False, template_type='auto', template_params=None):
        """Enhanced method with template support"""
        try:
            content = None
            
            if content_data.get('source') == 'anime' and content_data.get('id'):
                mal_id = content_data['id']
                content = self.Content.query.filter_by(mal_id=mal_id).first()
            elif content_data.get('id'):
                tmdb_id = content_data['id']
                content = self.Content.query.filter_by(tmdb_id=tmdb_id).first()
            
            if not content:
                content_result = self.save_external_content(content_data)
                if content_result.get('error'):
                    return content_result
                
                content_id = content_result.get('content_id')
                content = self.Content.query.get(content_id)
            
            if not content:
                return {'error': 'Failed to create content'}
            
            admin_rec = self.AdminRecommendation(
                content_id=content.id,
                admin_id=admin_user.id,
                recommendation_type=recommendation_type,
                description=description,
                is_active=(status == 'active')
            )
            
            self.db.session.add(admin_rec)
            self.db.session.commit()
            
            telegram_sent = False
            if publish_to_telegram and status == 'active':
                if self.telegram_service:
                    try:
                        template_params = template_params or {}
                        telegram_sent = self.telegram_service.send_admin_recommendation(
                            content, admin_user.username, description, template_type, template_params
                        )
                        logger.info(f"‚úÖ Telegram recommendation sent with {template_type} template: {content.title}")
                    except Exception as e:
                        logger.warning(f"Telegram send failed: {e}")
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"New {'Published' if status == 'active' else 'Draft'} Recommendation Created",
                        f"Admin {admin_user.username} created a recommendation for '{content.title}'\n"
                        f"Type: {recommendation_type}\n"
                        f"Status: {status}\n"
                        f"Template: {template_type}\n"
                        f"Description: {description[:100]}...",
                        admin_id=admin_user.id,
                        related_content_id=content.id,
                        action_url=f"/admin/recommendations/{admin_rec.id}",
                        metadata={
                            'template_type': template_type,
                            'template_params': template_params
                        },
                        alert_type='recommendation_created'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create recommendation notification: {e}")
            
            logger.info(f"‚úÖ Recommendation created from external content with {template_type} template: {content.title} by {admin_user.username}")
            return {
                'success': True,
                'message': f'Recommendation {"published" if status == "active" else "saved as upcoming"}',
                'telegram_sent': telegram_sent,
                'recommendation_id': admin_rec.id,
                'content_id': content.id,
                'status': status,
                'template_type': template_type
            }
            
        except Exception as e:
            try:
                self.db.session.rollback()
            except:
                pass
            logger.error(f"Create recommendation from external content error: {e}")
            raise e
    
    def create_recommendation(self, admin_user, content_id, recommendation_type, description, template_type='auto', template_params=None):
        """Enhanced method with template support"""
        try:
            content = self.Content.query.get(content_id)
            if not content:
                content = self.Content.query.filter_by(tmdb_id=content_id).first()
            
            if not content:
                logger.warning(f"Content not found for ID: {content_id}")
                return {'error': 'Content not found. Please save content first.'}
            
            admin_rec = self.AdminRecommendation(
                content_id=content.id,
                admin_id=admin_user.id,
                recommendation_type=recommendation_type,
                description=description
            )
            
            self.db.session.add(admin_rec)
            self.db.session.commit()
            
            telegram_success = False
            if self.telegram_service:
                try:
                    template_params = template_params or {}
                    telegram_success = self.telegram_service.send_admin_recommendation(
                        content, admin_user.username, description, template_type, template_params
                    )
                    logger.info(f"‚úÖ Telegram recommendation sent with {template_type} template: {content.title}")
                except Exception as e:
                    logger.warning(f"Telegram send failed: {e}")
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"New Admin Recommendation Created",
                        f"Admin {admin_user.username} recommended '{content.title}'\n"
                        f"Type: {recommendation_type}\n"
                        f"Template: {template_type}\n"
                        f"Description: {description[:100]}...",
                        admin_id=admin_user.id,
                        related_content_id=content.id,
                        action_url=f"/admin/recommendations/{admin_rec.id}",
                        metadata={
                            'template_type': template_type,
                            'template_params': template_params
                        },
                        alert_type='recommendation_created'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create recommendation notification: {e}")
            
            logger.info(f"‚úÖ Admin recommendation created with {template_type} template: {content.title} by {admin_user.username}")
            return {
                'message': 'Admin recommendation created successfully',
                'telegram_sent': telegram_success,
                'recommendation_id': admin_rec.id,
                'template_type': template_type
            }
            
        except Exception as e:
            try:
                self.db.session.rollback()
            except:
                pass
            logger.error(f"Admin recommendation error: {e}")
            raise e
    
    def get_recommendations(self, page=1, per_page=20, filter_type='all', status=None):
        """Get admin recommendations with safe handling of updated_at column"""
        try:
            query = self.AdminRecommendation.query
            
            if status == 'draft':
                query = query.filter_by(is_active=False)
            elif status == 'active':
                query = query.filter_by(is_active=True)
            elif filter_type == 'active':
                query = query.filter_by(is_active=True)
            elif filter_type == 'inactive':
                query = query.filter_by(is_active=False)
            
            admin_recs = query.order_by(
                self.AdminRecommendation.created_at.desc()
            ).paginate(page=page, per_page=per_page, error_out=False)
            
            result = []
            for rec in admin_recs.items:
                try:
                    content = self.Content.query.get(rec.content_id)
                    admin = self.User.query.get(rec.admin_id)
                    
                    if content and admin:
                        # Safe access to updated_at field
                        updated_at = getattr(rec, 'updated_at', None)
                        if updated_at is None:
                            updated_at = rec.created_at
                        
                        result.append({
                            'id': rec.id,
                            'recommendation_type': rec.recommendation_type,
                            'description': rec.description,
                            'is_active': rec.is_active,
                            'created_at': rec.created_at.isoformat(),
                            'updated_at': updated_at.isoformat(),  # Safe access
                            'admin_name': admin.username,
                            'content': {
                                'id': content.id,
                                'title': content.title,
                                'content_type': content.content_type,
                                'rating': content.rating,
                                'release_date': content.release_date.isoformat() if content.release_date else None,
                                'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path
                            }
                        })
                except Exception as e:
                    logger.error(f"Error processing recommendation {rec.id}: {e}")
                    continue
            
            logger.info(f"‚úÖ Retrieved {len(result)} admin recommendations")
            return {
                'recommendations': result,
                'total': admin_recs.total,
                'pages': admin_recs.pages,
                'current_page': page,
                'per_page': per_page,
                'has_prev': admin_recs.has_prev,
                'has_next': admin_recs.has_next
            }
            
        except Exception as e:
            logger.error(f"Get admin recommendations error: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            return {'error': 'Failed to get recommendations'}
    
    def get_recommendation_details(self, recommendation_id):
        try:
            recommendation = self.AdminRecommendation.query.get(recommendation_id)
            if not recommendation:
                return None
            
            content = self.Content.query.get(recommendation.content_id)
            admin = self.User.query.get(recommendation.admin_id)
            
            if not content or not admin:
                return None
            
            # Safe access to updated_at field
            updated_at = getattr(recommendation, 'updated_at', None)
            if updated_at is None:
                updated_at = recommendation.created_at
            
            return {
                'id': recommendation.id,
                'recommendation_type': recommendation.recommendation_type,
                'description': recommendation.description,
                'is_active': recommendation.is_active,
                'created_at': recommendation.created_at.isoformat(),
                'updated_at': updated_at.isoformat(),  # Safe access
                'admin_name': admin.username,
                'admin_id': admin.id,
                'content': {
                    'id': content.id,
                    'title': content.title,
                    'content_type': content.content_type,
                    'rating': content.rating,
                    'release_date': content.release_date.isoformat() if content.release_date else None,
                    'poster_path': f"https://image.tmdb.org/t/p/w500{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path,
                    'overview': content.overview
                }
            }
            
        except Exception as e:
            logger.error(f"Get recommendation details error: {e}")
            return None
    
    def update_recommendation(self, admin_user, recommendation_id, data):
        try:
            recommendation = self.AdminRecommendation.query.get(recommendation_id)
            if not recommendation:
                return None
            
            if 'recommendation_type' in data:
                recommendation.recommendation_type = data['recommendation_type']
            if 'description' in data:
                recommendation.description = data['description']
            if 'is_active' in data:
                recommendation.is_active = data['is_active']
            
            # Safe update of updated_at field
            if hasattr(recommendation, 'updated_at'):
                recommendation.updated_at = datetime.utcnow()
            
            self.db.session.commit()
            
            if self.notification_service:
                try:
                    content = self.Content.query.get(recommendation.content_id)
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"Recommendation Updated",
                        f"Admin {admin_user.username} updated recommendation for '{content.title if content else 'Unknown'}'",
                        admin_id=admin_user.id,
                        related_content_id=recommendation.content_id,
                        action_url=f"/admin/recommendations/{recommendation.id}",
                        alert_type='recommendation_updated'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create update notification: {e}")
            
            logger.info(f"‚úÖ Recommendation updated: {recommendation.id} by {admin_user.username}")
            return {
                'success': True,
                'message': 'Recommendation updated successfully',
                'recommendation_id': recommendation.id
            }
            
        except Exception as e:
            try:
                self.db.session.rollback()
            except:
                pass
            logger.error(f"Update recommendation error: {e}")
            raise e
    
    def delete_recommendation(self, admin_user, recommendation_id):
        try:
            recommendation = self.AdminRecommendation.query.get(recommendation_id)
            if not recommendation:
                return None
            
            content = self.Content.query.get(recommendation.content_id)
            content_title = content.title if content else 'Unknown'
            
            self.db.session.delete(recommendation)
            self.db.session.commit()
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"Recommendation Deleted",
                        f"Admin {admin_user.username} deleted recommendation for '{content_title}'",
                        admin_id=admin_user.id,
                        related_content_id=recommendation.content_id if content else None,
                        alert_type='recommendation_deleted'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create delete notification: {e}")
            
            logger.info(f"‚úÖ Recommendation deleted: {recommendation_id} by {admin_user.username}")
            return {
                'success': True,
                'message': 'Recommendation deleted successfully'
            }
            
        except Exception as e:
            try:
                self.db.session.rollback()
            except:
                pass
            logger.error(f"Delete recommendation error: {e}")
            raise e
    
    def publish_recommendation(self, admin_user, recommendation_id, template_type='auto', template_params=None):
        """Enhanced method with template support"""
        try:
            recommendation = self.AdminRecommendation.query.get(recommendation_id)
            if not recommendation:
                return None
            
            content = self.Content.query.get(recommendation.content_id)
            if not content:
                return {'error': 'Associated content not found'}
            
            recommendation.is_active = True
            # Safe update of updated_at field
            if hasattr(recommendation, 'updated_at'):
                recommendation.updated_at = datetime.utcnow()
            
            self.db.session.commit()
            
            telegram_sent = False
            if self.telegram_service:
                try:
                    template_params = template_params or {}
                    telegram_sent = self.telegram_service.send_admin_recommendation(
                        content, admin_user.username, recommendation.description, template_type, template_params
                    )
                    logger.info(f"‚úÖ Telegram recommendation sent with {template_type} template: {content.title}")
                except Exception as e:
                    logger.warning(f"Telegram send failed: {e}")
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"Recommendation Published",
                        f"Admin {admin_user.username} published recommendation for '{content.title}'\n"
                        f"Type: {recommendation.recommendation_type}\n"
                        f"Template: {template_type}\n"
                        f"Telegram sent: {'Yes' if telegram_sent else 'No'}",
                        admin_id=admin_user.id,
                        related_content_id=content.id,
                        action_url=f"/admin/recommendations/{recommendation.id}",
                        metadata={
                            'template_type': template_type,
                            'template_params': template_params
                        },
                        alert_type='recommendation_published'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create publish notification: {e}")
            
            logger.info(f"‚úÖ Recommendation published with {template_type} template: {content.title} by {admin_user.username}")
            return {
                'success': True,
                'message': 'Recommendation published successfully',
                'telegram_sent': telegram_sent,
                'recommendation_id': recommendation.id,
                'template_type': template_type
            }
            
        except Exception as e:
            try:
                self.db.session.rollback()
            except:
                pass
            logger.error(f"Publish recommendation error: {e}")
            raise e
    
    def send_recommendation_to_telegram(self, admin_user, recommendation_id, template_type='auto', template_params=None):
        """Enhanced method with template support"""
        try:
            recommendation = self.AdminRecommendation.query.get(recommendation_id)
            if not recommendation:
                return None
            
            content = self.Content.query.get(recommendation.content_id)
            if not content:
                return {'error': 'Associated content not found'}
            
            telegram_sent = False
            if self.telegram_service:
                try:
                    template_params = template_params or {}
                    telegram_sent = self.telegram_service.send_admin_recommendation(
                        content, admin_user.username, recommendation.description, template_type, template_params
                    )
                    logger.info(f"‚úÖ Telegram recommendation sent with {template_type} template: {content.title}")
                except Exception as e:
                    logger.warning(f"Telegram send failed: {e}")
                    return {'error': f'Failed to send to Telegram: {str(e)}'}
            else:
                return {'error': 'Telegram service not configured'}
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"Recommendation Sent to Telegram",
                        f"Admin {admin_user.username} sent recommendation for '{content.title}' to Telegram\n"
                        f"Template: {template_type}",
                        admin_id=admin_user.id,
                        related_content_id=content.id,
                        action_url=f"/admin/recommendations/{recommendation.id}",
                        metadata={
                            'template_type': template_type,
                            'template_params': template_params
                        },
                        alert_type='recommendation_published'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create send notification: {e}")
            
            logger.info(f"‚úÖ Recommendation sent to Telegram with {template_type} template: {content.title} by {admin_user.username}")
            return {
                'success': True,
                'message': 'Recommendation sent to Telegram successfully',
                'telegram_sent': telegram_sent,
                'template_type': template_type
            }
            
        except Exception as e:
            logger.error(f"Send recommendation to Telegram error: {e}")
            raise e
    
    def send_custom_telegram_message(self, admin_user, template_type, template_params):
        """Send custom Telegram message (for lists, etc.)"""
        try:
            if not self.telegram_service:
                return {'error': 'Telegram service not configured'}
            
            if template_type == 'top_list':
                # Handle list template without content object
                telegram_sent = self.telegram_service.send_admin_recommendation(
                    None, admin_user.username, '', template_type, template_params
                )
            else:
                return {'error': 'Invalid template type for custom message'}
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.CONTENT_ADDED,
                        f"Custom {template_type.replace('_', ' ').title()} Sent",
                        f"Admin {admin_user.username} sent custom {template_type} message to Telegram\n"
                        f"Title: {template_params.get('list_title', 'Custom List')}",
                        admin_id=admin_user.id,
                        action_url="/admin/telegram/templates",
                        metadata={
                            'template_type': template_type,
                            'template_params': template_params
                        },
                        alert_type='recommendation_published'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create custom message notification: {e}")
            
            logger.info(f"‚úÖ Custom {template_type} message sent by {admin_user.username}")
            return {
                'success': True,
                'message': f'Custom {template_type.replace("_", " ").title()} sent successfully',
                'telegram_sent': telegram_sent,
                'template_type': template_type
            }
            
        except Exception as e:
            logger.error(f"Send custom telegram message error: {e}")
            return {'error': 'Failed to send custom message'}
    
    def migrate_all_slugs(self, batch_size=50):
        try:
            from services.details import SlugManager
            
            stats = {
                'content_updated': 0,
                'persons_updated': 0,
                'total_processed': 0,
                'errors': 0
            }
            
            content_items = self.Content.query.filter(
                or_(self.Content.slug == None, self.Content.slug == '')
            ).limit(batch_size).all()
            
            for content in content_items:
                try:
                    if hasattr(content, 'ensure_slug'):
                        content.ensure_slug()
                        stats['content_updated'] += 1
                    else:
                        if content.title:
                            import re
                            slug = re.sub(r'[^\w\s-]', '', content.title.lower())
                            slug = re.sub(r'[-\s]+', '-', slug)
                            content.slug = slug[:150]
                            stats['content_updated'] += 1
                except Exception as e:
                    logger.error(f"Error updating slug for content {content.id}: {e}")
                    stats['errors'] += 1
            
            self.db.session.commit()
            stats['total_processed'] = stats['content_updated'] + stats['persons_updated']
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.SYSTEM_ALERT,
                        f"Slug Migration Completed",
                        f"Migrated {stats['content_updated']} content slugs\n"
                        f"Errors: {stats['errors']}\n"
                        f"Total processed: {stats['total_processed']}",
                        action_url="/admin/content/manage",
                        alert_type='bulk_operation'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create slug migration notification: {e}")
            
            logger.info(f"‚úÖ Slug migration completed: {stats['content_updated']} content items updated")
            return stats
            
        except Exception as e:
            logger.error(f"Slug migration error: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            raise e
    
    def update_content_slug(self, content_id, force_update=False):
        try:
            content = self.Content.query.get(content_id)
            if not content:
                return None
            
            if content.slug and not force_update:
                return content.slug
            
            if hasattr(content, 'ensure_slug'):
                content.ensure_slug()
            else:
                if content.title:
                    import re
                    slug = re.sub(r'[^\w\s-]', '', content.title.lower())
                    slug = re.sub(r'[-\s]+', '-', slug)
                    content.slug = slug[:150]
            
            self.db.session.commit()
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.SYSTEM_ALERT,
                        f"Content Slug Updated",
                        f"Updated slug for '{content.title}'\n"
                        f"New slug: {content.slug}",
                        related_content_id=content.id,
                        action_url=f"/admin/content/{content.id}",
                        alert_type='slug_update'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create slug update notification: {e}")
            
            logger.info(f"‚úÖ Content slug updated: {content.title} -> {content.slug}")
            return content.slug
            
        except Exception as e:
            logger.error(f"Error updating content slug: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            return None
    
    def populate_cast_crew(self, batch_size=10):
        try:
            result = {
                'processed': 0,
                'errors': 0
            }
            content_items = self.Content.query.filter(
                self.Content.tmdb_id.isnot(None)
            ).limit(batch_size).all()
            
            for content in content_items:
                try:
                    result['processed'] += 1
                    logger.info(f"Would populate cast/crew for {content.title}")
                except Exception as e:
                    logger.error(f"Error processing cast/crew for {content.title}: {e}")
                    result['errors'] += 1
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.SYSTEM_ALERT,
                        f"Cast/Crew Population Completed",
                        f"Processed {result['processed']} content items\n"
                        f"Errors: {result['errors']}",
                        action_url="/admin/content/manage",
                        alert_type='bulk_operation'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create cast/crew notification: {e}")
            
            logger.info(f"‚úÖ Cast/crew population completed: {result['processed']} items processed")
            return result
            
        except Exception as e:
            logger.error(f"Cast/crew population error: {e}")
            raise e
    
    def get_notifications(self, page=1, per_page=20, unread_only=False):
        try:
            recent_notifications = []
            if self.notification_service.redis_client:
                try:
                    notifications_json = self.notification_service.redis_client.lrange('admin_notifications', 0, 19)
                    for notif_json in notifications_json:
                        recent_notifications.append(json.loads(notif_json))
                    logger.info(f"‚úÖ Retrieved {len(recent_notifications)} recent notifications from Redis")
                except Exception as e:
                    logger.error(f"Redis notification retrieval error: {e}")
            
            db_notifications = []
            pagination_info = {
                'current_page': 1,
                'per_page': per_page,
                'total': 0,
                'pages': 0,
                'has_prev': False,
                'has_next': False
            }
            
            if self.AdminNotification:
                try:
                    query = self.AdminNotification.query
                    
                    if unread_only:
                        query = query.filter_by(is_read=False)
                    
                    notifications = query.order_by(
                        self.AdminNotification.created_at.desc()
                    ).paginate(page=page, per_page=per_page, error_out=False)
                    
                    for notif in notifications.items:
                        db_notifications.append({
                            'id': notif.id,
                            'type': notif.notification_type,
                            'title': notif.title,
                            'message': notif.message,
                            'is_read': notif.is_read,
                            'is_urgent': notif.is_urgent,
                            'action_required': notif.action_required,
                            'action_url': notif.action_url,
                            'metadata': notif.notification_metadata,
                            'created_at': notif.created_at.isoformat(),
                            'read_at': notif.read_at.isoformat() if notif.read_at else None
                        })
                    
                    pagination_info = {
                        'current_page': page,
                        'per_page': per_page,
                        'total': notifications.total,
                        'pages': notifications.pages,
                        'has_prev': notifications.has_prev,
                        'has_next': notifications.has_next
                    }
                    
                    logger.info(f"‚úÖ Retrieved {len(db_notifications)} database notifications")
                    
                except Exception as e:
                    logger.error(f"Database notification retrieval error: {e}")
                    try:
                        self.db.session.rollback()
                    except:
                        pass
            
            return {
                'recent_notifications': recent_notifications,
                'notifications': db_notifications,
                'pagination': pagination_info
            }
            
        except Exception as e:
            logger.error(f"Get admin notifications error: {e}")
            return {'error': 'Failed to get notifications'}
    
    def mark_all_notifications_read(self):
        try:
            if not self.AdminNotification:
                logger.warning("AdminNotification model not available")
                return {'error': 'Notification system not available'}
            
            updated_count = self.AdminNotification.query.filter_by(is_read=False).update({
                'is_read': True,
                'read_at': datetime.utcnow()
            })
            
            self.db.session.commit()
            
            logger.info(f"‚úÖ Marked {updated_count} notifications as read")
            return {
                'success': True,
                'message': f'Marked {updated_count} notifications as read'
            }
            
        except Exception as e:
            logger.error(f"Mark all notifications read error: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            return {'error': 'Failed to mark all notifications as read'}
    
    def clear_cache(self, cache_type='all'):
        try:
            if cache_type == 'all':
                self.cache.clear()
                message = 'All cache cleared'
            elif cache_type == 'search':
                self.cache.delete_memoized(self.TMDBService.search_content)
                self.cache.delete_memoized(self.JikanService.search_anime)
                message = 'Search cache cleared'
            elif cache_type == 'recommendations':
                message = 'Recommendations cache cleared'
            else:
                return {'error': 'Invalid cache type'}
            
            if self.notification_service:
                try:
                    self.notification_service.create_notification(
                        NotificationType.SYSTEM_ALERT,
                        f"Cache Cleared",
                        f"Cache type '{cache_type}' has been cleared\n"
                        f"Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}",
                        action_url="/admin/cache/stats",
                        alert_type='cache_operation'
                    )
                except Exception as e:
                    logger.warning(f"Failed to create cache clear notification: {e}")
            
            logger.info(f"‚úÖ Cache cleared: {cache_type}")
            return {
                'success': True,
                'message': message,
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Cache clear error: {e}")
            return {'error': 'Failed to clear cache'}
    
    def get_canned_responses(self, category_id=None):
        try:
            if not self.CannedResponse:
                logger.warning("CannedResponse model not available")
                return []
            
            query = self.CannedResponse.query.filter_by(is_active=True)
            
            if category_id:
                query = query.filter_by(category_id=category_id)
            
            responses = query.order_by(self.CannedResponse.usage_count.desc()).all()
            
            result = []
            for response in responses:
                result.append({
                    'id': response.id,
                    'title': response.title,
                    'content': response.content,
                    'tags': response.tags or [],
                    'usage_count': response.usage_count,
                    'created_at': response.created_at.isoformat()
                })
            
            logger.info(f"‚úÖ Retrieved {len(result)} canned responses")
            return result
            
        except Exception as e:
            logger.error(f"Get canned responses error: {e}")
            return []
    
    def create_canned_response(self, admin_user, title, content, category_id=None, tags=None):
        try:
            if not self.CannedResponse:
                return {'error': 'Canned response system not available'}
            
            response = self.CannedResponse(
                title=title,
                content=content,
                category_id=category_id,
                tags=tags or [],
                created_by=admin_user.id
            )
            
            self.db.session.add(response)
            self.db.session.commit()
            
            logger.info(f"‚úÖ Canned response created: {title}")
            return {
                'success': True,
                'response_id': response.id,
                'message': 'Canned response created successfully'
            }
            
        except Exception as e:
            logger.error(f"Create canned response error: {e}")
            try:
                self.db.session.rollback()
            except:
                pass
            return {'error': 'Failed to create canned response'}

def init_admin_service(app, db, models, services):
    try:
        admin_service = AdminService(app, db, models, services)
        logger.info("‚úÖ Admin service initialized successfully")
        return admin_service
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize admin service: {e}")
        return None



5. # admin/telegram.py

"""
CineBrain Telegram Integration
Premium cinematic messaging for intelligent movie discovery
"""

import os
import json
import logging
import threading
import time
import telebot
from datetime import datetime, timedelta
from dotenv import load_dotenv
from telebot import types
from typing import Optional, List, Dict, Any

load_dotenv()

logger = logging.getLogger(__name__)

# Telegram Configuration
TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
TELEGRAM_CHANNEL_ID = os.environ.get('TELEGRAM_CHANNEL_ID')
TELEGRAM_ADMIN_CHAT_ID = os.environ.get('TELEGRAM_ADMIN_CHAT_ID')

# Visual Constants
DIVIDER = "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
CINEBRAIN_FOOTER = "<b><i>üé• Recommended by CineBrain</i></b>"

# Initialize bot
bot = None
if TELEGRAM_BOT_TOKEN:
    try:
        bot = telebot.TeleBot(TELEGRAM_BOT_TOKEN, parse_mode='HTML')
        logger.info("‚úÖ Telegram bot initialized successfully")
    except Exception as e:
        logger.warning(f"Failed to initialize Telegram bot: {e}")
        bot = None
else:
    logger.warning("TELEGRAM_BOT_TOKEN not set - Telegram notifications disabled")


def cinebrain_tracking_url(slug: str, campaign: str, content: Optional[str] = None) -> str:
    """
    Generate CineBrain URL with UTM tracking parameters for Google Analytics
    
    @param slug: Content slug for the detail page
    @param campaign: Campaign name (e.g., "movie_recommendation", "anime_recommendation")
    @param content: Optional content identifier for more detailed tracking
    @return: Full URL with tracking parameters
    """
    base = f"https://cinebrain.vercel.app/explore/details.html?{slug}"
    utm = {
        "utm_source": "telegram",
        "utm_medium": "bot",
        "utm_campaign": campaign,
    }
    if content:
        utm["utm_content"] = content

    params = "&".join([f"{k}={v}" for k, v in utm.items()])
    return f"{base}&{params}"


class TelegramTemplates:
    """
    Premium cinematic templates for CineBrain's Telegram channel
    Every message is a mini movie poster in text form
    """
    
    @staticmethod
    def get_rating_display(rating: Optional[float]) -> str:
        """Format rating display"""
        if not rating:
            return "N/A"
        return f"{rating}/10"
    
    @staticmethod
    def format_runtime(runtime: Optional[int]) -> Optional[str]:
        """Format runtime into human-readable format"""
        if not runtime:
            return None
        hours = runtime // 60
        minutes = runtime % 60
        if hours > 0:
            return f"{hours}h {minutes}m"
        return f"{minutes}m"
    
    @staticmethod
    def format_genres(genres_list: Optional[List[str]], limit: int = 3) -> str:
        """Format genres with bullet separator"""
        if not genres_list:
            return "Drama"
        return " ‚Ä¢ ".join(genres_list[:limit])
    
    @staticmethod
    def format_year(release_date: Any) -> str:
        """Extract and format year from release date"""
        if not release_date:
            return ""
        try:
            if hasattr(release_date, 'year'):
                return f" ({release_date.year})"
            return f" ({str(release_date)[:4]})"
        except:
            return ""
    
    @staticmethod
    def truncate_synopsis(text: Optional[str], limit: int = 150) -> str:
        """Elegantly truncate synopsis at word boundary"""
        if not text:
            return "A cinematic experience awaits your discovery on CineBrain."
        if len(text) <= limit:
            return text
        return text[:limit].rsplit(' ', 1)[0] + "..."
    
    @staticmethod
    def get_content_type_prefix(content_type: str) -> str:
        """Get content type prefix for templates"""
        content_type_lower = content_type.lower()
        
        if content_type_lower == 'anime':
            return "Anime:"
        elif content_type_lower in ['tv', 'series', 'tv_show', 'tv-show']:
            return "TV Show/Series:"
        else:  # movie or any other type
            return "Movie:"
    
    @staticmethod
    def get_cinebrain_url(slug: str) -> str:
        """
        Generate CineBrain detail page URL
        @deprecated Use cinebrain_tracking_url() for tracked URLs
        """
        return f"https://cinebrain.vercel.app/explore/details.html?{slug}"
    
    @staticmethod
    def movie_recommendation_template(content: Any, admin_name: str, description: str, genres_list: Optional[List[str]] = None) -> str:
        """
        Premium movie recommendation with minimalist design
        """
        
        # Parse genres if needed
        if not genres_list and content.genres:
            try:
                genres_list = json.loads(content.genres)
            except:
                genres_list = []
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        rating = TelegramTemplates.get_rating_display(content.rating)
        runtime = TelegramTemplates.format_runtime(content.runtime)
        genres = TelegramTemplates.format_genres(genres_list)
        synopsis = TelegramTemplates.truncate_synopsis(content.overview)
        
        # Build runtime display
        runtime_str = f" | ‚è± {runtime}" if runtime else ""
        
        message = f"""<b>üéûÔ∏è {content_prefix} {content.title}{year}</b>
<b>‚ú® Ratings:</b> {rating}{runtime_str}
<b>üé≠ Genre:</b> {genres}
{DIVIDER}
üí¨ <b>Synopsis</b>
<blockquote><i>{synopsis}</i></blockquote>
{DIVIDER}
<i>üçø Smart recommendations ‚Ä¢ Upcoming updates ‚Ä¢ Latest updates ‚Ä¢ New releases ‚Ä¢ Trending updates ‚Äî visit <a href="https://cinebrain.vercel.app/">CineBrain</a></i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def tv_show_recommendation_template(content: Any, admin_name: str, description: str, genres_list: Optional[List[str]] = None) -> str:
        """
        Premium TV series template with minimalist design
        """
        
        # Parse genres if needed
        if not genres_list and content.genres:
            try:
                genres_list = json.loads(content.genres)
            except:
                genres_list = []
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        rating = TelegramTemplates.get_rating_display(content.rating)
        genres = TelegramTemplates.format_genres(genres_list)
        synopsis = TelegramTemplates.truncate_synopsis(content.overview)
        
        # For TV shows, show seasons if available
        runtime_str = ""
        if hasattr(content, 'seasons') and content.seasons:
            runtime_str = f" | ‚è± {content.seasons} Seasons"
        
        message = f"""<b>üéûÔ∏è {content_prefix} {content.title}{year}</b>
<b>‚ú® Ratings:</b> {rating}{runtime_str}
<b>üé≠ Genre:</b> {genres}
{DIVIDER}
üí¨ <b>Synopsis</b>
<blockquote><i>{synopsis}</i></blockquote>
{DIVIDER}
<i>üçø Smart recommendations ‚Ä¢ Upcoming updates ‚Ä¢ Latest updates ‚Ä¢ New releases ‚Ä¢ Trending updates ‚Äî visit <a href="https://cinebrain.vercel.app/">CineBrain</a></i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def anime_recommendation_template(content: Any, admin_name: str, description: str, genres_list: Optional[List[str]] = None, anime_genres_list: Optional[List[str]] = None) -> str:
        """
        Premium anime template with minimalist design
        """
        
        # Combine all genres
        all_genres = []
        if genres_list:
            all_genres.extend(genres_list)
        elif content.genres:
            try:
                all_genres.extend(json.loads(content.genres))
            except:
                pass
        
        if anime_genres_list:
            all_genres.extend(anime_genres_list)
        elif hasattr(content, 'anime_genres') and content.anime_genres:
            try:
                all_genres.extend(json.loads(content.anime_genres))
            except:
                pass
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        rating = TelegramTemplates.get_rating_display(content.rating)
        genres = TelegramTemplates.format_genres(all_genres)
        synopsis = TelegramTemplates.truncate_synopsis(content.overview)
        
        # For anime, show status if available
        runtime_str = ""
        if hasattr(content, 'status') and content.status:
            runtime_str = f" | ‚è± {content.status}"
        else:
            runtime_str = " | ‚è± Ongoing"
        
        message = f"""<b>üéûÔ∏è {content_prefix} {content.title}{year}</b>
<b>‚ú® Ratings:</b> {rating}{runtime_str}
<b>üé≠ Genre:</b> {genres}
{DIVIDER}
üí¨ <b>Synopsis</b>
<blockquote><i>{synopsis}</i></blockquote>
{DIVIDER}
<i>üçø Smart recommendations ‚Ä¢ Upcoming updates ‚Ä¢ Latest updates ‚Ä¢ New releases ‚Ä¢ Trending updates ‚Äî visit <a href="https://cinebrain.vercel.app/">CineBrain</a></i>
{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def mind_bending_template(content: Any, admin_name: str, description: str, genres_list: Optional[List[str]] = None, overview: Optional[str] = None, if_you_like: Optional[str] = None) -> str:
        """
        üî• Mind-bending movie template for confusing, reality-breaking, psychological, sci-fi, or twist movies
        Use when: The movie is genius, underrated, brain-melting
        
        Fields: Title, Year, Genres, Rating, Runtime, Overview, If_you_like
        """
        # Parse genres if needed
        if not genres_list and content.genres:
            try:
                genres_list = json.loads(content.genres)
            except:
                genres_list = []
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        rating = TelegramTemplates.get_rating_display(content.rating)
        runtime = TelegramTemplates.format_runtime(content.runtime)
        genres = TelegramTemplates.format_genres(genres_list, limit=3)
        
        # Use provided overview or fallback to content overview (2-3 sentences, mysterious)
        overview_text = overview or TelegramTemplates.truncate_synopsis(content.overview, 200)
        
        # Runtime formatting for mind-bending template
        runtime_str = f" ‚Ä¢ ‚è± {runtime}" if runtime else ""
        
        message = f"""üî• <b>THIS MOVIE WILL MELT YOUR BRAIN</b>
<b>{content_prefix} {content.title}{year}</b>
<i>{genres} ‚Ä¢ ‚≠ê {rating}{runtime_str}</i>
{DIVIDER}
<b>Why this will break your reality:</b>
<blockquote><i>{overview_text}</i></blockquote>
‚Ä¢ A concept that bends reality
‚Ä¢ A twist that rewrites the whole story
‚Ä¢ A low-budget masterpiece with maximum impact
{DIVIDER}"""
        
        # Add if_you_like section if provided (FIXED: proper line breaks)
        if if_you_like:
            message += f"\n<b>If you like:</b> {if_you_like}\n"
        
        message += f"""
üîé <i>More hidden gems ‚Äî @cinebrain</i>
<i>üß† CineBrain ‚Äî Hidden Gems ‚Ä¢ Mind-Bending Sci-Fi ‚Ä¢ Rare Anime</i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def hidden_gem_template(content: Any, admin_name: str, description: str, genres_list: Optional[List[str]] = None, hook: Optional[str] = None, if_you_like: Optional[str] = None) -> str:
        """
        üíé Hidden gem template for underrated or lesser-known movies/series
        Use when: Movies are not mainstream but excellent
        
        Fields: Title, Year, Genres, Rating, Hook/catch-line, If_you_like (optional)
        """
        # Parse genres if needed
        if not genres_list and content.genres:
            try:
                genres_list = json.loads(content.genres)
            except:
                genres_list = []
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        rating = TelegramTemplates.get_rating_display(content.rating)
        genres = TelegramTemplates.format_genres(genres_list, limit=3)
        
        # Hook: 1-2 lines, "why nobody talks about this" feel
        hook_text = hook or "A beautifully crafted gem buried under the algorithm."
        
        message = f"""üíé <b>Hidden Gem ‚Äî {content_prefix} {content.title}{year}</b>
<i>{genres} ‚Ä¢ ‚≠ê {rating}</i>

{hook_text}"""
        
        # Add optional if_you_like section (FIXED: proper formatting)
        if if_you_like:
            message += f"\n\n<b>If you like:</b> {if_you_like}"
        
        message += f"""

üîé <i>More hidden gems ‚Äî @cinebrain</i>
<i>üß† CineBrain ‚Äî Hidden Gems ‚Ä¢ Mind-Bending Sci-Fi ‚Ä¢ Rare Anime</i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def anime_gem_template(content: Any, admin_name: str, description: str, genres_list: Optional[List[str]] = None, anime_genres_list: Optional[List[str]] = None, overview: Optional[str] = None, emotion_hook: Optional[str] = None) -> str:
        """
        üéê Anime gem template for emotional, psychological, sci-fi, or plot-heavy anime
        Use when: The anime has depth, philosophy, or a big emotional theme
        
        Fields: Title, Year, Genres, Status, Rating, Overview, Emotion_hook
        """
        # Combine all genres (2-4 combined genres)
        all_genres = []
        if genres_list:
            all_genres.extend(genres_list)
        elif content.genres:
            try:
                all_genres.extend(json.loads(content.genres))
            except:
                pass
        
        if anime_genres_list:
            all_genres.extend(anime_genres_list)
        elif hasattr(content, 'anime_genres') and content.anime_genres:
            try:
                all_genres.extend(json.loads(content.anime_genres))
            except:
                pass
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        rating = TelegramTemplates.get_rating_display(content.rating)
        genres = TelegramTemplates.format_genres(all_genres, limit=4)
        
        # Status: Completed or Ongoing
        status = "Completed"
        if hasattr(content, 'status') and content.status:
            status = content.status
        elif hasattr(content, 'release_date') and content.release_date:
            # Simple heuristic: if recent, probably ongoing
            from datetime import datetime, timedelta
            if content.release_date > datetime.now().date() - timedelta(days=365):
                status = "Ongoing"
        
        # Overview: 2-3 lines, emotional and philosophical core, focus on themes not plot
        overview_text = overview or TelegramTemplates.truncate_synopsis(content.overview, 180)
        
        # Emotion_hook: 1 strong emotional line
        emotion_hook_text = emotion_hook or "A time-loop tragedy that hits harder the more you think about it."
        
        message = f"""üî• <b>THIS ANIME WILL BLOW YOUR MIND</b>
üéê <b>Anime Gem ‚Äî {content_prefix} {content.title}{year}</b>
<i>{genres} ‚Ä¢ {status} ‚Ä¢ ‚≠ê {rating}</i>
{DIVIDER}
<b>Why this hits hard:</b>
<blockquote><i>{overview_text}</i></blockquote>
‚Ä¢ {emotion_hook_text}
{DIVIDER}
üîé <i>More rare anime ‚Äî @cinebrain</i>
<i>üß† CineBrain ‚Äî Hidden Gems ‚Ä¢ Mind-Bending Sci-Fi ‚Ä¢ Rare Anime</i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def top_list_template(list_title: str, items: List[tuple], admin_name: str = "", description: str = "", poster_url: Optional[str] = None) -> str:
        """
        üß† Top-list template for list-style posts (Top 5, Top 10)
        Use when: You want a viral post full of mini recommendations
        
        Fields per item: Movie Title, Year, Hook (short, punchy)
        Max: 5-10 items
        List Title: catchy and niche-based
        """
        # Limit to 10 items MAX as specified
        limited_items = items[:10]
        
        # Build numbered list with short, punchy hooks
        body = "\n".join([
            f"{i+1}. <b>{title}</b> ({year}) ‚Äî {hook}"
            for i, (title, year, hook) in enumerate(limited_items)
        ])
        
        message = f"""üß† <b>{list_title}</b>

{body}
{DIVIDER}
üìå <i>Save this list ‚Äî @cinebrain</i>
<i>üß† CineBrain ‚Äî Hidden Gems ‚Ä¢ Mind-Bending Sci-Fi ‚Ä¢ Rare Anime</i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def scene_clip_template(content: Any, admin_name: str, description: str, caption: str, genres_list: Optional[List[str]] = None) -> str:
        """
        üé• Scene clip template for posting a clip/video from a movie or anime
        Use when: You upload a 10-30 sec clip to Telegram
        
        Fields: Caption, Title, Year, Genres
        Caption: punchy line creating curiosity
        Keep minimal because video is main attraction
        NO POSTER SUPPORT - video is the main media
        """
        # Parse genres if needed (2-3 genres that define the tone)
        if not genres_list and content.genres:
            try:
                genres_list = json.loads(content.genres)
            except:
                genres_list = []
        
        # Format components
        content_prefix = TelegramTemplates.get_content_type_prefix(content.content_type)
        year = TelegramTemplates.format_year(content.release_date)
        genres = TelegramTemplates.format_genres(genres_list, limit=3)
        
        # Caption: punchy line creating curiosity
        caption_text = caption or "This scene will hook you instantly"
        
        message = f"""<b>{caption_text}</b>
üé• <b>{content_prefix} {content.title}{year}</b>
<i>{genres}</i>
{DIVIDER}
‚ö° Watch the clip above.
If this hooks you, the full movie will blow your mind.

üîé <i>More scenes ‚Äî @cinebrain</i>
<i>üß† CineBrain ‚Äî Hidden Gems ‚Ä¢ Mind-Bending Sci-Fi ‚Ä¢ Rare Anime</i>

{CINEBRAIN_FOOTER}"""
        
        return message
    
    @staticmethod
    def get_template_prompts() -> Dict[str, Dict[str, str]]:
        """
        Get template prompts for AI content generation or admin guidance
        """
        return {
            'mind_bending': {
                'purpose': 'For movies that are confusing, reality-breaking, psychological, sci-fi, or have a big twist.',
                'use_when': 'The movie is genius, underrated, brain-melting.',
                'poster_support': True,
                'prompt': '''Generate a mind-bending movie recommendation.
Fill these fields with strong, intense, viral-quality text:
‚Ä¢ Title: The exact movie title
‚Ä¢ Year: The release year in brackets (example: (2013))
‚Ä¢ Genres: 2‚Äì3 genres (example: Sci-Fi ‚Ä¢ Thriller ‚Ä¢ Mystery)
‚Ä¢ Rating: IMDb or TMDB rating like 7.6/10
‚Ä¢ Runtime: Format inside (‚è± 1h 32m)
‚Ä¢ Overview: 2‚Äì3 sentences, mysterious, raise questions, never spoil twists
‚Ä¢ If_you_like: 2‚Äì4 similar brain-breaking movies (example: Inception, Dark, Predestination)
Make the overview gripping, non-generic, focused on tension, confusion, and mystery.'''
            },
            'hidden_gem': {
                'purpose': 'For underrated or lesser-known movies/series.',
                'use_when': 'Movies are not mainstream but excellent.',
                'poster_support': True,
                'prompt': '''Generate a hidden gem recommendation.
Fill these fields with sharp, concise descriptions:
‚Ä¢ Title: Movie title
‚Ä¢ Year: Release year in brackets
‚Ä¢ Genres: 2‚Äì3 max
‚Ä¢ Rating: IMDb or TMDB rating
‚Ä¢ Hook/catch-line: 1‚Äì2 lines, "why nobody talks about this" feel
‚Ä¢ If_you_like (optional): 2‚Äì3 movies with similar tone
The hook must be extremely catchy. Avoid long explanations. Focus on uniqueness, vibe, style.'''
            },
            'anime_gem': {
                'purpose': 'For emotional, psychological, sci-fi, or plot-heavy anime.',
                'use_when': 'The anime has depth, philosophy, or a big emotional theme.',
                'poster_support': True,
                'prompt': '''Generate an anime gem recommendation.
Fill these fields with emotional and engaging detail:
‚Ä¢ Title: Name of the anime
‚Ä¢ Year: Release year in brackets
‚Ä¢ Genres: 2‚Äì4 combined genres
‚Ä¢ Status: Completed or Ongoing
‚Ä¢ Rating: Anime rating (MyAnimeList / TMDB)
‚Ä¢ Overview: 2‚Äì3 lines, emotional and philosophical core, focus on themes not plot
‚Ä¢ Emotion_hook: 1 strong emotional line (example: "A time-loop tragedy that hits harder the more you think about it.")
Make the tone emotional, powerful, and intense.'''
            },
            'top_list': {
                'purpose': 'For list-style posts (Top 5, Top 10).',
                'use_when': 'You want a viral post full of mini recommendations.',
                'poster_support': True,
                'prompt': '''Generate a top-list for CineBrain.
Fill each item with:
‚Ä¢ Movie Title
‚Ä¢ Year  
‚Ä¢ Hook (example: "A mind-bending paradox that will fry your brain")
Provide 5‚Äì10 items MAX. Hooks should be short, punchy, and scroll-stopping.
Also provide:
‚Ä¢ List Title: Make it catchy and niche-based
Examples: "Top 5 Mind-Bending Sci-Fi Gems", "Top 7 Psychological Thrillers You Missed"
No long paragraphs. Just title + year + short hook.'''
            },
            'scene_clip': {
                'purpose': 'For posting a clip/video from a movie or anime.',
                'use_when': 'You upload a 10‚Äì30 sec clip to Telegram.',
                'poster_support': False,
                'prompt': '''Generate text for a scene-clip post.
Fill these fields:
‚Ä¢ Caption: A punchy line creating curiosity (example: "This scene will hook you instantly")
‚Ä¢ Title: Movie or Anime title
‚Ä¢ Year: Release year in brackets
‚Ä¢ Genres: 2‚Äì3 genres that define the tone
The tone must be exciting and suspenseful. Keep text minimal because video is main attraction.'''
            }
        }
    
    @staticmethod
    def get_available_templates() -> Dict[str, str]:
        """
        Get list of available templates for frontend selection
        """
        return {
            'standard_movie': 'Standard Movie Recommendation',
            'standard_tv': 'Standard TV Show Recommendation', 
            'standard_anime': 'Standard Anime Recommendation',
            'mind_bending': 'üî• Mind-Bending Movie',
            'hidden_gem': 'üíé Hidden Gem',
            'anime_gem': 'üéê Anime Gem',
            'top_list': 'üß† Top List/Curation',
            'scene_clip': 'üé• Scene Clip with Video'
        }
    
    @staticmethod
    def get_template_fields(template_type: str) -> Dict[str, Any]:
        """
        Get required fields for each template type
        """
        field_definitions = {
            'mind_bending': {
                'required': ['title', 'year', 'genres', 'rating', 'runtime', 'overview'],
                'optional': ['if_you_like'],
                'poster_support': True,
                'field_specs': {
                    'genres': '2-3 genres (Sci-Fi ‚Ä¢ Thriller ‚Ä¢ Mystery)',
                    'overview': '2-3 sentences, mysterious, never spoil twists',
                    'if_you_like': '2-4 similar brain-breaking movies'
                }
            },
            'hidden_gem': {
                'required': ['title', 'year', 'genres', 'rating', 'hook'],
                'optional': ['if_you_like'],
                'poster_support': True,
                'field_specs': {
                    'genres': '2-3 genres max',
                    'hook': '1-2 lines, "why nobody talks about this" feel',
                    'if_you_like': '2-3 movies with similar tone'
                }
            },
            'anime_gem': {
                'required': ['title', 'year', 'genres', 'status', 'rating', 'overview', 'emotion_hook'],
                'optional': [],
                'poster_support': True,
                'field_specs': {
                    'genres': '2-4 combined genres',
                    'status': 'Completed or Ongoing',
                    'overview': '2-3 lines, emotional/philosophical core, themes not plot',
                    'emotion_hook': '1 strong emotional line'
                }
            },
            'top_list': {
                'required': ['list_title', 'items'],
                'optional': ['poster_url'],
                'poster_support': True,
                'field_specs': {
                    'list_title': 'Catchy and niche-based',
                    'items': '5-10 items MAX, each with title, year, short punchy hook',
                    'poster_url': 'Optional custom poster for the list'
                }
            },
            'scene_clip': {
                'required': ['caption', 'title', 'year', 'genres'],
                'optional': [],
                'poster_support': False,
                'field_specs': {
                    'caption': 'Punchy line creating curiosity',
                    'genres': '2-3 genres that define the tone'
                }
            }
        }
        
        return field_definitions.get(template_type, {})
    
    @staticmethod
    def render_template(template_type: str, content: Any = None, admin_name: str = "", description: str = "", **kwargs) -> str:
        """
        Dynamic template renderer for frontend integration
        
        @param template_type: Template identifier
        @param content: Content object
        @param admin_name: Admin name
        @param description: Description/hook text
        @param kwargs: Additional template-specific parameters
        """
        template_map = {
            'standard_movie': TelegramTemplates.movie_recommendation_template,
            'standard_tv': TelegramTemplates.tv_show_recommendation_template,
            'standard_anime': TelegramTemplates.anime_recommendation_template,
            'mind_bending': TelegramTemplates.mind_bending_template,
            'hidden_gem': TelegramTemplates.hidden_gem_template,
            'anime_gem': TelegramTemplates.anime_gem_template,
            'scene_clip': TelegramTemplates.scene_clip_template
        }
        
        if template_type == 'top_list':
            return TelegramTemplates.top_list_template(
                kwargs.get('list_title', 'Curated List'),
                kwargs.get('items', []),
                admin_name,
                description,
                kwargs.get('poster_url')
            )
        
        template_func = template_map.get(template_type)
        if not template_func:
            # Fallback to standard template based on content type
            if content and content.content_type == 'anime':
                template_func = TelegramTemplates.anime_recommendation_template
            elif content and content.content_type in ['tv', 'series']:
                template_func = TelegramTemplates.tv_show_recommendation_template
            else:
                template_func = TelegramTemplates.movie_recommendation_template
        
        return template_func(content, admin_name, description, **kwargs)


class TelegramService:
    """
    Service for sending beautifully formatted Telegram notifications
    Handles all public channel communications
    """
    
    @staticmethod
    def send_admin_recommendation(content: Any, admin_name: str, description: str, template_type: str = 'auto', template_params: Dict = None) -> bool:
        """
        Send admin-curated recommendation with selectable template
        
        @param content: Content object with movie/show details
        @param admin_name: Name of the admin making recommendation
        @param description: CineBrain Insight text
        @param template_type: Template to use ('auto' for automatic selection)
        @param template_params: Additional parameters for specific templates
        @return: Success status
        """
        try:
            if not bot or not TELEGRAM_CHANNEL_ID:
                logger.warning("Telegram recommendation skipped - channel not configured")
                return False
            
            template_params = template_params or {}
            
            # Auto-select template if not specified
            if template_type == 'auto':
                if content and content.content_type == 'anime':
                    template_type = 'standard_anime'
                elif content and content.content_type in ['tv', 'series']:
                    template_type = 'standard_tv'
                else:
                    template_type = 'standard_movie'
            
            # Check if template supports posters
            template_info = TelegramTemplates.get_template_fields(template_type)
            poster_support = template_info.get('poster_support', True)
            
            # Special handling for list template (no content object needed)
            if template_type == 'top_list':
                message = TelegramTemplates.top_list_template(
                    template_params.get('list_title', 'Curated List'),
                    template_params.get('items', []),
                    admin_name,
                    description,
                    template_params.get('poster_url')
                )
                poster_url = template_params.get('poster_url')
            else:
                # Render the selected template
                message = TelegramTemplates.render_template(
                    template_type, 
                    content, 
                    admin_name, 
                    description,
                    **template_params
                )
                
                # Get poster URL from content only if template supports it
                poster_url = None
                if poster_support and content and content.poster_path:
                    if content.poster_path.startswith('http'):
                        poster_url = content.poster_path
                    else:
                        poster_url = f"https://image.tmdb.org/t/p/w500{content.poster_path}"
            
            # Create inline keyboard with buttons SIDE BY SIDE
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            
            buttons = []
            
            # Add Details button for content-based templates
            if template_type != 'top_list' and content and hasattr(content, 'slug') and content.slug:
                campaign_type = f"{content.content_type}_recommendation"
                content_identifier = content.slug.replace('-', '_')
                
                detail_url = cinebrain_tracking_url(
                    content.slug, 
                    campaign_type, 
                    content_identifier
                )
                
                details_btn = types.InlineKeyboardButton(
                    text="Full Details",
                    url=detail_url
                )
                buttons.append(details_btn)
            
            # Always add explore button
            explore_btn = types.InlineKeyboardButton(
                text="Explore More",
                url=f"https://cinebrain.vercel.app/?utm_source=telegram&utm_medium=bot&utm_campaign=recommendation&utm_content=explore_more"
            )
            buttons.append(explore_btn)
            
            # Add buttons in a single row (side by side)
            if len(buttons) == 2:
                keyboard.row(buttons[0], buttons[1])  # Side by side
            elif len(buttons) == 1:
                keyboard.add(buttons[0])  # Single button
            
            # Send message with or without poster based on template support
            if poster_url and poster_support and template_type != 'scene_clip':
                try:
                    bot.send_photo(
                        chat_id=TELEGRAM_CHANNEL_ID,
                        photo=poster_url,
                        caption=message,
                        parse_mode='HTML',
                        reply_markup=keyboard
                    )
                    logger.info(f"‚úÖ {template_type} recommendation with poster sent: {content.title if content else 'List'}")
                except Exception as e:
                    logger.error(f"Photo send failed: {e}, sending text only")
                    bot.send_message(
                        chat_id=TELEGRAM_CHANNEL_ID,
                        text=message,
                        parse_mode='HTML',
                        reply_markup=keyboard
                    )
                    logger.info(f"‚úÖ {template_type} recommendation sent (text only): {content.title if content else 'List'}")
            else:
                bot.send_message(
                    chat_id=TELEGRAM_CHANNEL_ID,
                    text=message,
                    parse_mode='HTML',
                    reply_markup=keyboard
                )
                logger.info(f"‚úÖ {template_type} recommendation sent: {content.title if content else 'List'}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Telegram send error: {e}")
            return False


class TelegramAdminService:
    """
    Admin notification service for internal updates
    Handles admin-only communications
    """
    
    @staticmethod
    def send_content_notification(content_title: str, admin_name: str, action_type: str = "added") -> bool:
        """
        Send admin action notification to admin chat
        
        @param content_title: Title of the content
        @param admin_name: Admin who performed action
        @param action_type: Type of action performed
        @return: Success status
        """
        try:
            if not bot or not TELEGRAM_ADMIN_CHAT_ID:
                return False
            
            action_emoji = {
                'added': '‚ûï',
                'updated': '‚úèÔ∏è',
                'deleted': 'üóëÔ∏è',
                'recommended': '‚≠ê'
            }.get(action_type, 'üìù')
            
            message = f"""{action_emoji} <b>Admin Action</b>
{DIVIDER}

<b>Content:</b> {content_title}
<b>Admin:</b> {admin_name}
<b>Action:</b> {action_type.upper()}
<b>Time:</b> {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}

{DIVIDER}
#AdminAction #CineBrain"""
            
            bot.send_message(
                chat_id=TELEGRAM_ADMIN_CHAT_ID,
                text=message,
                parse_mode='HTML'
            )
            
            logger.info(f"‚úÖ Admin notification sent: {action_type} - {content_title}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Admin notification error: {e}")
            return False
    
    @staticmethod
    def send_recommendation_stats(stats_data: Dict[str, Any]) -> bool:
        """
        Send recommendation statistics to admin chat
        
        @param stats_data: Dictionary containing stats
        @return: Success status
        """
        try:
            if not bot or not TELEGRAM_ADMIN_CHAT_ID:
                return False
            
            message = f"""üìä <b>CineBrain Analytics</b>
{DIVIDER}
<b>üìà Recommendation Overview</b>
‚Ä¢ Total Recommendations: <b>{stats_data.get('total', 0):,}</b>
‚Ä¢ This Week: <b>{stats_data.get('this_week', 0):,}</b>
‚Ä¢ Top Admin: <b>{stats_data.get('top_admin', 'N/A')}</b>
‚Ä¢ Top Genre: <b>{stats_data.get('top_genre', 'N/A')}</b>

<b>üéØ Engagement Metrics</b>
‚Ä¢ Total Views: <b>{stats_data.get('views', 0):,}</b>
‚Ä¢ Total Clicks: <b>{stats_data.get('clicks', 0):,}</b>
‚Ä¢ Click-Through Rate: <b>{stats_data.get('ctr', 0):.2f}%</b>
‚Ä¢ Avg. Engagement: <b>{stats_data.get('avg_engagement', 0):.1f}%</b>
{DIVIDER}
<i>Generated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}</i>

#Analytics #CineBrain"""
            
            bot.send_message(
                chat_id=TELEGRAM_ADMIN_CHAT_ID,
                text=message,
                parse_mode='HTML'
            )
            
            logger.info("‚úÖ Analytics stats sent to admin")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Stats notification error: {e}")
            return False


def init_telegram_service(app, db, models, services) -> Optional[Dict[str, Any]]:
    """
    Initialize Telegram service with all components
    
    @param app: Flask application instance
    @param db: Database instance
    @param models: Database models
    @param services: Service dependencies
    @return: Dictionary of initialized services or None
    """
    try:
        if bot:
            logger.info("‚úÖ CineBrain Telegram service initialized successfully")
            logger.info("   ‚îú‚îÄ Content type prefixes: ‚úì")
            logger.info("   ‚îú‚îÄ Poster support (all except scene_clip): ‚úì")
            logger.info("   ‚îú‚îÄ 5 custom templates: ‚úì")
            logger.info("   ‚îú‚îÄ Fixed button layout (side by side): ‚úì")
            logger.info("   ‚îú‚îÄ Fixed divider formatting: ‚úì")
            logger.info("   ‚îú‚îÄ Mobile-optimized layouts: ‚úì")
            logger.info("   ‚îú‚îÄ Google Analytics tracking: ‚úì")
            logger.info("   ‚îú‚îÄ Content recommendations: ‚úì")
            logger.info("   ‚îî‚îÄ Admin notifications: ‚úì")
        else:
            logger.warning("‚ö†Ô∏è Telegram bot not configured - service disabled")
            logger.warning("   Set TELEGRAM_BOT_TOKEN to enable Telegram features")
        
        return {
            'telegram_service': TelegramService,
            'telegram_admin_service': TelegramAdminService,
            'telegram_templates': TelegramTemplates,
            'cinebrain_tracking_url': cinebrain_tracking_url
        }
        
    except Exception as e:
        logger.error(f"‚ùå Telegram initialization failed: {e}")
        return None


# Export public API
__all__ = [
    'TelegramTemplates',
    'TelegramService', 
    'TelegramAdminService',
    'cinebrain_tracking_url',
    'init_telegram_service'
]