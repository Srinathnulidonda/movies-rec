1. # system/init.py

"""
CineBrain System Module
Advanced system monitoring, health checks, admin monitoring, and performance management
"""

from .routes import system_bp
from .system import SystemService
from .admin_monitor import AdminMonitoringService

__all__ = ['system_bp', 'SystemService', 'AdminMonitoringService']
__version__ = '2.0.0'


2. # system/admin_monitor.py

import os
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List
from sqlalchemy import text, func, desc
from collections import defaultdict
import json

logger = logging.getLogger(__name__)

class AdminMonitoringService:
    """Comprehensive admin monitoring and alerting service"""
    
    db = None
    app = None
    cache = None
    models = None
    services = None
    
    @classmethod
    def init(cls, flask_app, database, app_models, app_services):
        """Initialize the admin monitoring service"""
        cls.app = flask_app
        cls.db = database
        cls.cache = app_services.get('cache')
        cls.models = app_models
        cls.services = app_services
        logger.info("✅ CineBrain Admin Monitoring Service initialized")
    
    @classmethod
    def get_admin_health_status(cls) -> Dict[str, Any]:
        """Get comprehensive admin system health status"""
        health = {
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'cinebrain_admin_monitoring': True
        }
        
        # Check core admin services
        admin_services = cls._check_core_admin_services()
        health['admin_services'] = admin_services
        
        # Check notification system
        notification_health = cls._check_notification_system()
        health['notification_system'] = notification_health
        
        # Check support system
        support_health = cls._check_support_system()
        health['support_system'] = support_health
        
        # Check admin user activity
        admin_activity = cls._check_admin_user_activity()
        health['admin_activity'] = admin_activity
        
        # Determine overall health status
        if not admin_services.get('admin_service_active', False):
            health['status'] = 'degraded'
        
        if notification_health.get('critical_issues', 0) > 0:
            health['status'] = 'degraded'
        
        if support_health.get('urgent_tickets', 0) > 10:
            health['status'] = 'degraded'
        
        return health
    
    @classmethod
    def get_monitoring_overview(cls) -> Dict[str, Any]:
        """Get comprehensive admin monitoring overview"""
        overview = {
            'timestamp': datetime.utcnow().isoformat(),
            'monitoring_status': 'active'
        }
        
        # System health summary
        overview['system_health'] = cls._get_system_health_summary()
        
        # Admin activity summary
        overview['admin_activity'] = cls._get_admin_activity_summary()
        
        # Support system summary
        overview['support_summary'] = cls._get_support_system_summary()
        
        # Notification system summary
        overview['notification_summary'] = cls._get_notification_system_summary()
        
        # Critical alerts
        overview['critical_alerts'] = cls._get_critical_alerts()
        
        # Performance indicators
        overview['performance_indicators'] = cls._get_performance_indicators()
        
        return overview
    
    @classmethod
    def get_admin_activity(cls) -> Dict[str, Any]:
        """Get detailed admin activity monitoring data"""
        activity_data = {
            'timestamp': datetime.utcnow().isoformat()
        }
        
        try:
            User = cls.models.get('User')
            AdminNotification = cls.models.get('AdminNotification')
            SupportTicket = cls.models.get('SupportTicket')
            AdminRecommendation = cls.models.get('AdminRecommendation')
            
            if User:
                # Admin user statistics
                admin_users = User.query.filter_by(is_admin=True).all()
                
                # Active admins in last 24 hours
                active_admins_24h = [
                    admin for admin in admin_users
                    if admin.last_active and admin.last_active >= datetime.utcnow() - timedelta(hours=24)
                ]
                
                # Active admins in last 7 days
                active_admins_7d = [
                    admin for admin in admin_users
                    if admin.last_active and admin.last_active >= datetime.utcnow() - timedelta(days=7)
                ]
                
                activity_data['admin_users'] = {
                    'total_admins': len(admin_users),
                    'active_24h': len(active_admins_24h),
                    'active_7d': len(active_admins_7d),
                    'activity_rate_24h': round((len(active_admins_24h) / len(admin_users) * 100), 1) if admin_users else 0,
                    'activity_rate_7d': round((len(active_admins_7d) / len(admin_users) * 100), 1) if admin_users else 0,
                    'admin_details': [
                        {
                            'id': admin.id,
                            'username': admin.username,
                            'email': admin.email,
                            'last_active': admin.last_active.isoformat() if admin.last_active else None,
                            'created_at': admin.created_at.isoformat()
                        }
                        for admin in admin_users
                    ]
                }
            
            if AdminRecommendation:
                # Admin recommendations activity
                recent_recommendations = AdminRecommendation.query.filter(
                    AdminRecommendation.created_at >= datetime.utcnow() - timedelta(days=7)
                ).all()
                
                activity_data['admin_recommendations'] = {
                    'total_recommendations': AdminRecommendation.query.count(),
                    'recent_7d': len(recent_recommendations),
                    'active_recommendations': AdminRecommendation.query.filter_by(is_active=True).count(),
                    'recent_activity': [
                        {
                            'id': rec.id,
                            'admin_id': rec.admin_id,
                            'content_id': rec.content_id,
                            'recommendation_type': rec.recommendation_type,
                            'created_at': rec.created_at.isoformat()
                        }
                        for rec in recent_recommendations[-10:]  # Last 10
                    ]
                }
            
        except Exception as e:
            activity_data['error'] = str(e)
            logger.error(f"Error getting admin activity data: {e}")
        
        return activity_data
    
    @classmethod
    def get_admin_performance(cls) -> Dict[str, Any]:
        """Get admin system performance metrics"""
        performance_data = {
            'timestamp': datetime.utcnow().isoformat()
        }
        
        try:
            # Admin service response times (simulated - in production would use real metrics)
            performance_data['response_times'] = {
                'admin_dashboard_avg_ms': 250,
                'admin_api_avg_ms': 150,
                'notification_delivery_avg_ms': 100,
                'support_ticket_load_avg_ms': 300
            }
            
            # Admin system load
            performance_data['system_load'] = {
                'admin_concurrent_users': cls._get_concurrent_admin_users(),
                'notification_queue_size': cls._get_notification_queue_size(),
                'support_ticket_processing_rate': cls._get_support_processing_rate()
            }
            
            # Performance thresholds
            performance_data['performance_status'] = 'optimal'
            
            if performance_data['response_times']['admin_dashboard_avg_ms'] > 500:
                performance_data['performance_status'] = 'degraded'
            
            if performance_data['system_load']['notification_queue_size'] > 100:
                performance_data['performance_status'] = 'degraded'
        
        except Exception as e:
            performance_data['error'] = str(e)
            logger.error(f"Error getting admin performance data: {e}")
        
        return performance_data
    
    @classmethod
    def get_security_monitoring(cls) -> Dict[str, Any]:
        """Get admin security monitoring data"""
        security_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'security_status': 'secure'
        }
        
        try:
            User = cls.models.get('User')
            
            if User:
                # Admin login patterns (last 24 hours)
                admin_users = User.query.filter_by(is_admin=True).all()
                recent_logins = [
                    admin for admin in admin_users
                    if admin.last_active and admin.last_active >= datetime.utcnow() - timedelta(hours=24)
                ]
                
                security_data['admin_access'] = {
                    'admin_logins_24h': len(recent_logins),
                    'unique_admin_sessions_24h': len(recent_logins),  # Simplified
                    'failed_admin_attempts_24h': 0,  # Would need audit log for real data
                    'suspicious_activity': False
                }
                
                # Admin privilege monitoring
                security_data['privilege_monitoring'] = {
                    'total_admin_accounts': len(admin_users),
                    'recently_created_admins': len([
                        admin for admin in admin_users
                        if admin.created_at >= datetime.utcnow() - timedelta(days=7)
                    ]),
                    'inactive_admin_accounts': len([
                        admin for admin in admin_users
                        if not admin.last_active or admin.last_active < datetime.utcnow() - timedelta(days=30)
                    ])
                }
            
            # System access monitoring
            security_data['system_access'] = {
                'admin_api_calls_24h': cls._get_admin_api_calls(),
                'admin_data_access_24h': cls._get_admin_data_access(),
                'config_changes_24h': cls._get_config_changes()
            }
            
            # Security alerts
            security_alerts = []
            
            if security_data['admin_access']['failed_admin_attempts_24h'] > 5:
                security_alerts.append({
                    'level': 'warning',
                    'message': 'Multiple failed admin login attempts detected',
                    'action': 'Review admin access logs'
                })
            
            if security_data['privilege_monitoring']['recently_created_admins'] > 0:
                security_alerts.append({
                    'level': 'info',
                    'message': f"{security_data['privilege_monitoring']['recently_created_admins']} new admin accounts created",
                    'action': 'Verify new admin account legitimacy'
                })
            
            security_data['security_alerts'] = security_alerts
            
        except Exception as e:
            security_data['error'] = str(e)
            security_data['security_status'] = 'error'
            logger.error(f"Error getting security monitoring data: {e}")
        
        return security_data
    
    @classmethod
    def get_notification_system_health(cls) -> Dict[str, Any]:
        """Get admin notification system health"""
        notification_health = {
            'timestamp': datetime.utcnow().isoformat(),
            'system_status': 'operational'
        }
        
        try:
            AdminNotification = cls.models.get('AdminNotification')
            
            # Notification service status
            notification_health['service_status'] = {
                'notification_service_active': bool(cls.services.get('admin_notification_service')),
                'email_service_active': cls._check_email_service_health(),
                'telegram_service_active': cls._check_telegram_service_health(),
                'database_notifications_active': bool(AdminNotification)
            }
            
            if AdminNotification:
                # Notification statistics
                total_notifications = AdminNotification.query.count()
                unread_notifications = AdminNotification.query.filter_by(is_read=False).count()
                urgent_notifications = AdminNotification.query.filter_by(is_urgent=True).count()
                
                # Recent notification activity
                recent_notifications = AdminNotification.query.filter(
                    AdminNotification.created_at >= datetime.utcnow() - timedelta(hours=24)
                ).count()
                
                notification_health['statistics'] = {
                    'total_notifications': total_notifications,
                    'unread_notifications': unread_notifications,
                    'urgent_notifications': urgent_notifications,
                    'notifications_24h': recent_notifications,
                    'read_rate': round(((total_notifications - unread_notifications) / total_notifications * 100), 1) if total_notifications > 0 else 0
                }
                
                # Notification delivery health
                notification_health['delivery_health'] = {
                    'email_delivery_rate': 95,  # Would be tracked from actual delivery logs
                    'telegram_delivery_rate': 98,
                    'database_storage_rate': 100,
                    'average_delivery_time_ms': 150
                }
                
                # Notification alerts
                alerts = []
                
                if unread_notifications > 50:
                    alerts.append({
                        'level': 'warning',
                        'message': f'{unread_notifications} unread admin notifications',
                        'action': 'Review and process notifications'
                    })
                
                if urgent_notifications > 10:
                    alerts.append({
                        'level': 'critical',
                        'message': f'{urgent_notifications} urgent notifications pending',
                        'action': 'Address urgent notifications immediately'
                    })
                
                notification_health['alerts'] = alerts
            
        except Exception as e:
            notification_health['error'] = str(e)
            notification_health['system_status'] = 'error'
            logger.error(f"Error getting notification system health: {e}")
        
        return notification_health
    
    @classmethod
    def get_admin_alerts(cls) -> Dict[str, Any]:
        """Get admin-specific monitoring alerts"""
        alerts_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'alerts': [],
            'alert_summary': {}
        }
        
        try:
            alerts = []
            
            # System alerts
            system_alerts = cls._get_system_alerts()
            alerts.extend(system_alerts)
            
            # Admin service alerts
            admin_alerts = cls._get_admin_service_alerts()
            alerts.extend(admin_alerts)
            
            # Support system alerts
            support_alerts = cls._get_support_system_alerts()
            alerts.extend(support_alerts)
            
            # Notification system alerts
            notification_alerts = cls._get_notification_alerts()
            alerts.extend(notification_alerts)
            
            # Performance alerts
            performance_alerts = cls._get_performance_alerts()
            alerts.extend(performance_alerts)
            
            # Security alerts
            security_alerts = cls._get_security_alerts()
            alerts.extend(security_alerts)
            
            alerts_data['alerts'] = alerts
            
            # Alert summary
            alerts_data['alert_summary'] = {
                'total_alerts': len(alerts),
                'critical_alerts': len([a for a in alerts if a.get('level') == 'critical']),
                'warning_alerts': len([a for a in alerts if a.get('level') == 'warning']),
                'info_alerts': len([a for a in alerts if a.get('level') == 'info']),
                'error_alerts': len([a for a in alerts if a.get('level') == 'error'])
            }
            
        except Exception as e:
            alerts_data['error'] = str(e)
            logger.error(f"Error getting admin alerts: {e}")
        
        return alerts_data
    
    @classmethod
    def get_detailed_admin_performance(cls) -> Dict[str, Any]:
        """Get detailed admin performance analysis"""
        performance = {
            'timestamp': datetime.utcnow().isoformat(),
            'analysis_period': '24_hours'
        }
        
        try:
            # Admin dashboard performance
            performance['dashboard_performance'] = {
                'average_load_time_ms': 280,
                'peak_load_time_ms': 450,
                'dashboard_uptime': 99.8,
                'api_response_times': {
                    'admin_overview': 150,
                    'user_management': 200,
                    'content_management': 250,
                    'support_dashboard': 300,
                    'analytics_dashboard': 400
                }
            }
            
            # Admin operation performance
            performance['operation_performance'] = {
                'content_operations': {
                    'search_external_content_avg_ms': 800,
                    'save_content_avg_ms': 150,
                    'update_content_avg_ms': 100
                },
                'user_operations': {
                    'user_search_avg_ms': 50,
                    'user_update_avg_ms': 75,
                    'bulk_operations_avg_ms': 500
                },
                'support_operations': {
                    'ticket_load_avg_ms': 100,
                    'ticket_update_avg_ms': 80,
                    'notification_send_avg_ms': 120
                }
            }
            
            # Resource utilization by admin operations
            performance['resource_utilization'] = {
                'cpu_usage_admin_ops': 15,
                'memory_usage_admin_ops': 25,
                'database_connections_admin': cls._get_admin_db_connections(),
                'cache_hit_rate_admin': 85
            }
            
            # Performance recommendations
            recommendations = []
            
            if performance['dashboard_performance']['average_load_time_ms'] > 300:
                recommendations.append({
                    'category': 'dashboard',
                    'recommendation': 'Optimize admin dashboard loading',
                    'impact': 'medium'
                })
            
            if performance['operation_performance']['content_operations']['search_external_content_avg_ms'] > 1000:
                recommendations.append({
                    'category': 'content_search',
                    'recommendation': 'Implement content search caching',
                    'impact': 'high'
                })
            
            performance['recommendations'] = recommendations
            
        except Exception as e:
            performance['error'] = str(e)
            logger.error(f"Error getting detailed admin performance: {e}")
        
        return performance
    
    # Helper methods
    @classmethod
    def _check_core_admin_services(cls) -> Dict[str, Any]:
        """Check core admin services"""
        return {
            'admin_service_active': 'admin_bp' in cls.app.blueprints,
            'admin_routes_registered': len([rule for rule in cls.app.url_map.iter_rules() if 'admin' in rule.rule]),
            'admin_models_available': bool(cls.models.get('AdminNotification')),
            'admin_notification_service': bool(cls.services.get('admin_notification_service'))
        }
    
    @classmethod
    def _check_notification_system(cls) -> Dict[str, Any]:
        """Check notification system health"""
        try:
            AdminNotification = cls.models.get('AdminNotification')
            
            health = {
                'database_notifications': bool(AdminNotification),
                'email_service': cls._check_email_service_health(),
                'telegram_service': cls._check_telegram_service_health()
            }
            
            if AdminNotification:
                unread_notifications = AdminNotification.query.filter_by(is_read=False).count()
                urgent_notifications = AdminNotification.query.filter_by(is_urgent=True).count()
                
                health['unread_count'] = unread_notifications
                health['urgent_count'] = urgent_notifications
                health['critical_issues'] = 1 if urgent_notifications > 10 else 0
            
            return health
            
        except Exception as e:
            return {'error': str(e), 'critical_issues': 1}
    
    @classmethod
    def _check_support_system(cls) -> Dict[str, Any]:
        """Check support system health"""
        try:
            SupportTicket = cls.models.get('SupportTicket')
            
            health = {
                'support_service_active': 'support_bp' in cls.app.blueprints,
                'support_models_available': bool(SupportTicket)
            }
            
            if SupportTicket:
                urgent_tickets = SupportTicket.query.filter_by(priority='urgent').count()
                open_tickets = SupportTicket.query.filter(
                    SupportTicket.status.in_(['open', 'in_progress'])
                ).count()
                sla_breached = SupportTicket.query.filter_by(sla_breached=True).count()
                
                health['urgent_tickets'] = urgent_tickets
                health['open_tickets'] = open_tickets
                health['sla_breached'] = sla_breached
                health['critical_issues'] = urgent_tickets + sla_breached
            
            return health
            
        except Exception as e:
            return {'error': str(e), 'critical_issues': 1}
    
    @classmethod
    def _check_admin_user_activity(cls) -> Dict[str, Any]:
        """Check admin user activity"""
        try:
            User = cls.models.get('User')
            
            if User:
                admin_users = User.query.filter_by(is_admin=True).all()
                active_admins = [
                    admin for admin in admin_users
                    if admin.last_active and admin.last_active >= datetime.utcnow() - timedelta(hours=24)
                ]
                
                return {
                    'total_admins': len(admin_users),
                    'active_admins_24h': len(active_admins),
                    'activity_rate': round((len(active_admins) / len(admin_users) * 100), 1) if admin_users else 0,
                    'status': 'healthy' if len(active_admins) > 0 else 'warning'
                }
            
            return {'status': 'no_admin_users'}
            
        except Exception as e:
            return {'error': str(e), 'status': 'error'}
    
    @classmethod
    def _check_email_service_health(cls) -> bool:
        """Check email service health"""
        try:
            from auth.service import email_service
            return bool(email_service and email_service.email_enabled)
        except:
            return False
    
    @classmethod
    def _check_telegram_service_health(cls) -> bool:
        """Check Telegram service health"""
        return all([
            os.environ.get('TELEGRAM_BOT_TOKEN'),
            os.environ.get('TELEGRAM_CHANNEL_ID')
        ])
    
    @classmethod
    def _get_system_health_summary(cls) -> Dict[str, Any]:
        """Get system health summary for admin overview"""
        return {
            'overall_status': 'healthy',  # Would be calculated from actual checks
            'database_status': 'connected',
            'cache_status': 'connected' if cls.cache else 'not_configured',
            'external_apis_status': 'operational',
            'services_status': 'all_operational'
        }
    
    @classmethod
    def _get_admin_activity_summary(cls) -> Dict[str, Any]:
        """Get admin activity summary"""
        try:
            User = cls.models.get('User')
            AdminRecommendation = cls.models.get('AdminRecommendation')
            
            summary = {}
            
            if User:
                admin_count = User.query.filter_by(is_admin=True).count()
                active_admins = User.query.filter(
                    User.is_admin == True,
                    User.last_active >= datetime.utcnow() - timedelta(hours=24)
                ).count()
                
                summary['admin_users'] = {
                    'total': admin_count,
                    'active_24h': active_admins
                }
            
            if AdminRecommendation:
                recent_recommendations = AdminRecommendation.query.filter(
                    AdminRecommendation.created_at >= datetime.utcnow() - timedelta(days=7)
                ).count()
                
                summary['recommendations'] = {
                    'recent_7d': recent_recommendations
                }
            
            return summary
            
        except Exception as e:
            return {'error': str(e)}
    
    @classmethod
    def _get_support_system_summary(cls) -> Dict[str, Any]:
        """Get support system summary"""
        try:
            SupportTicket = cls.models.get('SupportTicket')
            
            if SupportTicket:
                return {
                    'total_tickets': SupportTicket.query.count(),
                    'open_tickets': SupportTicket.query.filter(
                        SupportTicket.status.in_(['open', 'in_progress'])
                    ).count(),
                    'urgent_tickets': SupportTicket.query.filter_by(priority='urgent').count(),
                    'sla_breached': SupportTicket.query.filter_by(sla_breached=True).count()
                }
            
            return {'status': 'not_available'}
            
        except Exception as e:
            return {'error': str(e)}
    
    @classmethod
    def _get_notification_system_summary(cls) -> Dict[str, Any]:
        """Get notification system summary"""
        try:
            AdminNotification = cls.models.get('AdminNotification')
            
            if AdminNotification:
                return {
                    'total_notifications': AdminNotification.query.count(),
                    'unread_notifications': AdminNotification.query.filter_by(is_read=False).count(),
                    'urgent_notifications': AdminNotification.query.filter_by(is_urgent=True).count(),
                    'email_service': cls._check_email_service_health(),
                    'telegram_service': cls._check_telegram_service_health()
                }
            
            return {'status': 'not_available'}
            
        except Exception as e:
            return {'error': str(e)}
    
    @classmethod
    def _get_critical_alerts(cls) -> List[Dict[str, Any]]:
        """Get critical alerts for admin overview"""
        alerts = []
        
        try:
            SupportTicket = cls.models.get('SupportTicket')
            AdminNotification = cls.models.get('AdminNotification')
            
            if SupportTicket:
                # Check for urgent tickets
                urgent_tickets = SupportTicket.query.filter_by(priority='urgent').count()
                if urgent_tickets > 0:
                    alerts.append({
                        'level': 'critical' if urgent_tickets > 5 else 'warning',
                        'component': 'support',
                        'message': f'{urgent_tickets} urgent support tickets',
                        'action': 'Review urgent tickets'
                    })
                
                # Check for SLA breaches
                sla_breached = SupportTicket.query.filter_by(sla_breached=True).count()
                if sla_breached > 0:
                    alerts.append({
                        'level': 'critical',
                        'component': 'support_sla',
                        'message': f'{sla_breached} SLA breaches',
                        'action': 'Address SLA breaches'
                    })
            
            if AdminNotification:
                # Check for unread urgent notifications
                urgent_unread = AdminNotification.query.filter(
                    AdminNotification.is_urgent == True,
                    AdminNotification.is_read == False
                ).count()
                
                if urgent_unread > 0:
                    alerts.append({
                        'level': 'warning',
                        'component': 'notifications',
                        'message': f'{urgent_unread} urgent notifications unread',
                        'action': 'Review notifications'
                    })
            
        except Exception as e:
            alerts.append({
                'level': 'error',
                'component': 'monitoring',
                'message': f'Error checking alerts: {str(e)}',
                'action': 'Check monitoring system'
            })
        
        return alerts
    
    @classmethod
    def _get_performance_indicators(cls) -> Dict[str, Any]:
        """Get performance indicators"""
        return {
            'response_time_avg': 200,  # Would be from actual metrics
            'uptime_percentage': 99.9,
            'error_rate': 0.1,
            'throughput_requests_per_minute': 150
        }
    
    # Additional helper methods for metrics
    @classmethod
    def _get_concurrent_admin_users(cls) -> int:
        """Get current concurrent admin users"""
        try:
            User = cls.models.get('User')
            if User:
                # Admins active in last 30 minutes
                return User.query.filter(
                    User.is_admin == True,
                    User.last_active >= datetime.utcnow() - timedelta(minutes=30)
                ).count()
        except:
            pass
        return 0
    
    @classmethod
    def _get_notification_queue_size(cls) -> int:
        """Get notification queue size"""
        try:
            AdminNotification = cls.models.get('AdminNotification')
            if AdminNotification:
                return AdminNotification.query.filter_by(is_read=False).count()
        except:
            pass
        return 0
    
    @classmethod
    def _get_support_processing_rate(cls) -> float:
        """Get support ticket processing rate"""
        try:
            SupportTicket = cls.models.get('SupportTicket')
            if SupportTicket:
                today = datetime.utcnow().date()
                created_today = SupportTicket.query.filter(
                    func.date(SupportTicket.created_at) == today
                ).count()
                resolved_today = SupportTicket.query.filter(
                    func.date(SupportTicket.resolved_at) == today
                ).count()
                
                if created_today > 0:
                    return round((resolved_today / created_today), 2)
        except:
            pass
        return 0.0
    
    @classmethod
    def _get_admin_api_calls(cls) -> int:
        """Get admin API calls in last 24h (placeholder)"""
        # In production, this would be from actual API logs
        return 150
    
    @classmethod
    def _get_admin_data_access(cls) -> int:
        """Get admin data access operations (placeholder)"""
        # In production, this would be from actual audit logs
        return 75
    
    @classmethod
    def _get_config_changes(cls) -> int:
        """Get configuration changes in last 24h (placeholder)"""
        # In production, this would be from actual change logs
        return 2
    
    @classmethod
    def _get_admin_db_connections(cls) -> int:
        """Get admin-related database connections"""
        # Simplified - would be more sophisticated in production
        return 5
    
    # Alert generation methods
    @classmethod
    def _get_system_alerts(cls) -> List[Dict[str, Any]]:
        """Get system-level alerts"""
        alerts = []
        
        # Check database connection
        try:
            cls.db.session.execute(text('SELECT 1'))
        except Exception:
            alerts.append({
                'level': 'critical',
                'component': 'database',
                'message': 'Database connection failed',
                'action': 'Check database connectivity'
            })
        
        return alerts
    
    @classmethod
    def _get_admin_service_alerts(cls) -> List[Dict[str, Any]]:
        """Get admin service alerts"""
        alerts = []
        
        if 'admin_bp' not in cls.app.blueprints:
            alerts.append({
                'level': 'critical',
                'component': 'admin_service',
                'message': 'Admin service not active',
                'action': 'Check admin service configuration'
            })
        
        return alerts
    
    @classmethod
    def _get_support_system_alerts(cls) -> List[Dict[str, Any]]:
        """Get support system alerts"""
        alerts = []
        
        try:
            SupportTicket = cls.models.get('SupportTicket')
            if SupportTicket:
                urgent_tickets = SupportTicket.query.filter_by(priority='urgent').count()
                if urgent_tickets > 5:
                    alerts.append({
                        'level': 'warning',
                        'component': 'support',
                        'message': f'{urgent_tickets} urgent tickets need attention',
                        'action': 'Review urgent support tickets'
                    })
        except Exception:
            pass
        
        return alerts
    
    @classmethod
    def _get_notification_alerts(cls) -> List[Dict[str, Any]]:
        """Get notification system alerts"""
        alerts = []
        
        if not cls._check_email_service_health():
            alerts.append({
                'level': 'warning',
                'component': 'email_service',
                'message': 'Email service not configured',
                'action': 'Configure email service for notifications'
            })
        
        return alerts
    
    @classmethod
    def _get_performance_alerts(cls) -> List[Dict[str, Any]]:
        """Get performance alerts"""
        alerts = []
        
        # In production, would check actual performance metrics
        # This is a placeholder implementation
        
        return alerts
    
    @classmethod
    def _get_security_alerts(cls) -> List[Dict[str, Any]]:
        """Get security alerts"""
        alerts = []
        
        try:
            User = cls.models.get('User')
            if User:
                # Check for inactive admin accounts
                admin_users = User.query.filter_by(is_admin=True).all()
                inactive_admins = [
                    admin for admin in admin_users
                    if not admin.last_active or admin.last_active < datetime.utcnow() - timedelta(days=30)
                ]
                
                if len(inactive_admins) > 0:
                    alerts.append({
                        'level': 'info',
                        'component': 'security',
                        'message': f'{len(inactive_admins)} inactive admin accounts',
                        'action': 'Review inactive admin accounts'
                    })
        except Exception:
            pass
        
        return alerts


3. # system/routes.py

from flask import Blueprint, request, jsonify
from datetime import datetime, timedelta
import logging
import os
import psutil
from sqlalchemy import text

from .system import SystemService
from .admin_monitor import AdminMonitoringService

# Create the system blueprint
system_bp = Blueprint('system', __name__)

logger = logging.getLogger(__name__)

# Global variables (will be set by init function)
db = None
app = None
cache = None
models = None
services = None

def init_system_routes(flask_app, database, app_models, app_services):
    """Initialize the system routes with dependencies"""
    global db, app, cache, models, services
    
    app = flask_app
    db = database
    cache = app_services.get('cache')
    models = app_models
    services = app_services
    
    # Initialize SystemService and AdminMonitoringService
    SystemService.init(flask_app, database, app_models, app_services)
    AdminMonitoringService.init(flask_app, database, app_models, app_services)
    
    logger.info("✅ CineBrain system routes initialized successfully")

# ============================================================================
# HEALTH CHECK ROUTES
# ============================================================================

@system_bp.route('/api/health', methods=['GET'])
def health_check():
    """Comprehensive system health check"""
    try:
        health_info = SystemService.get_health_status()
        
        status_code = 200
        if health_info['status'] == 'degraded':
            status_code = 206
        elif health_info['status'] == 'unhealthy':
            status_code = 503
            
        return jsonify(health_info), status_code
        
    except Exception as e:
        logger.error(f"CineBrain health check error: {e}")
        return jsonify({
            'status': 'unhealthy',
            'service': 'cinebrain_system',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/health/detailed', methods=['GET'])
def detailed_health_check():
    """Detailed health check with all system components"""
    try:
        detailed_health = SystemService.get_detailed_health_status()
        return jsonify(detailed_health), 200
        
    except Exception as e:
        logger.error(f"CineBrain detailed health check error: {e}")
        return jsonify({
            'error': 'Failed to get detailed health status',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/health/admin', methods=['GET'])
def admin_health_check():
    """Admin-specific health check"""
    try:
        admin_health = AdminMonitoringService.get_admin_health_status()
        return jsonify(admin_health), 200
        
    except Exception as e:
        logger.error(f"CineBrain admin health check error: {e}")
        return jsonify({
            'error': 'Failed to get admin health status',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# ADMIN MONITORING ROUTES
# ============================================================================

@system_bp.route('/api/admin/monitoring/overview', methods=['GET'])
def admin_monitoring_overview():
    """Get admin monitoring overview"""
    try:
        overview = AdminMonitoringService.get_monitoring_overview()
        return jsonify(overview), 200
        
    except Exception as e:
        logger.error(f"Admin monitoring overview error: {e}")
        return jsonify({
            'error': 'Failed to get admin monitoring overview',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/admin/monitoring/activity', methods=['GET'])
def admin_activity_monitoring():
    """Get admin activity monitoring data"""
    try:
        activity = AdminMonitoringService.get_admin_activity()
        return jsonify(activity), 200
        
    except Exception as e:
        logger.error(f"Admin activity monitoring error: {e}")
        return jsonify({
            'error': 'Failed to get admin activity data',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/admin/monitoring/performance', methods=['GET'])
def admin_performance_monitoring():
    """Get admin performance metrics"""
    try:
        performance = AdminMonitoringService.get_admin_performance()
        return jsonify(performance), 200
        
    except Exception as e:
        logger.error(f"Admin performance monitoring error: {e}")
        return jsonify({
            'error': 'Failed to get admin performance metrics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/admin/monitoring/security', methods=['GET'])
def admin_security_monitoring():
    """Get admin security monitoring data"""
    try:
        security = AdminMonitoringService.get_security_monitoring()
        return jsonify(security), 200
        
    except Exception as e:
        logger.error(f"Admin security monitoring error: {e}")
        return jsonify({
            'error': 'Failed to get admin security data',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/admin/monitoring/notifications', methods=['GET'])
def admin_notifications_monitoring():
    """Get admin notifications system health"""
    try:
        notifications = AdminMonitoringService.get_notification_system_health()
        return jsonify(notifications), 200
        
    except Exception as e:
        logger.error(f"Admin notifications monitoring error: {e}")
        return jsonify({
            'error': 'Failed to get admin notifications data',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/admin/monitoring/alerts', methods=['GET'])
def admin_monitoring_alerts():
    """Get admin-specific monitoring alerts"""
    try:
        alerts = AdminMonitoringService.get_admin_alerts()
        return jsonify(alerts), 200
        
    except Exception as e:
        logger.error(f"Admin alerts monitoring error: {e}")
        return jsonify({
            'error': 'Failed to get admin alerts',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# PERFORMANCE MONITORING ROUTES
# ============================================================================

@system_bp.route('/api/performance', methods=['GET'])
def performance_check():
    """System performance metrics"""
    try:
        performance_data = SystemService.get_performance_metrics()
        return jsonify(performance_data), 200
        
    except Exception as e:
        logger.error(f"CineBrain performance check error: {e}")
        return jsonify({
            'error': 'Failed to get performance metrics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/performance/detailed', methods=['GET'])
def detailed_performance():
    """Detailed performance metrics"""
    try:
        detailed_performance = SystemService.get_detailed_performance_metrics()
        return jsonify(detailed_performance), 200
        
    except Exception as e:
        logger.error(f"CineBrain detailed performance error: {e}")
        return jsonify({
            'error': 'Failed to get detailed performance metrics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/performance/admin', methods=['GET'])
def admin_performance():
    """Admin-specific performance metrics"""
    try:
        admin_perf = AdminMonitoringService.get_detailed_admin_performance()
        return jsonify(admin_perf), 200
        
    except Exception as e:
        logger.error(f"Admin performance error: {e}")
        return jsonify({
            'error': 'Failed to get admin performance metrics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# SYSTEM STATISTICS ROUTES
# ============================================================================

@system_bp.route('/api/system/stats', methods=['GET'])
def system_stats():
    """Get comprehensive system statistics"""
    try:
        stats = SystemService.get_system_statistics()
        return jsonify(stats), 200
        
    except Exception as e:
        logger.error(f"CineBrain system stats error: {e}")
        return jsonify({
            'error': 'Failed to get system statistics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/system/database', methods=['GET'])
def database_stats():
    """Get database statistics and health"""
    try:
        db_stats = SystemService.get_database_statistics()
        return jsonify(db_stats), 200
        
    except Exception as e:
        logger.error(f"CineBrain database stats error: {e}")
        return jsonify({
            'error': 'Failed to get database statistics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/system/services', methods=['GET'])
def services_status():
    """Get status of all CineBrain services"""
    try:
        services_status = SystemService.get_services_status()
        return jsonify(services_status), 200
        
    except Exception as e:
        logger.error(f"CineBrain services status error: {e}")
        return jsonify({
            'error': 'Failed to get services status',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# SYSTEM MAINTENANCE ROUTES
# ============================================================================

@system_bp.route('/api/system/cache/clear', methods=['POST'])
def clear_cache():
    """Clear system cache"""
    try:
        if cache:
            cache.clear()
            return jsonify({
                'success': True,
                'message': 'CineBrain cache cleared successfully',
                'timestamp': datetime.utcnow().isoformat()
            }), 200
        else:
            return jsonify({
                'success': False,
                'message': 'CineBrain cache not configured',
                'timestamp': datetime.utcnow().isoformat()
            }), 400
            
    except Exception as e:
        logger.error(f"CineBrain cache clear error: {e}")
        return jsonify({
            'error': 'Failed to clear cache',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/system/cache/stats', methods=['GET'])
def cache_stats():
    """Get cache statistics"""
    try:
        cache_data = SystemService.get_cache_statistics()
        return jsonify(cache_data), 200
        
    except Exception as e:
        logger.error(f"CineBrain cache stats error: {e}")
        return jsonify({
            'error': 'Failed to get cache statistics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# MONITORING ROUTES
# ============================================================================

@system_bp.route('/api/system/monitoring/alerts', methods=['GET'])
def monitoring_alerts():
    """Get system monitoring alerts"""
    try:
        alerts = SystemService.get_monitoring_alerts()
        return jsonify(alerts), 200
        
    except Exception as e:
        logger.error(f"CineBrain monitoring alerts error: {e}")
        return jsonify({
            'error': 'Failed to get monitoring alerts',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/system/monitoring/metrics', methods=['GET'])
def monitoring_metrics():
    """Get real-time monitoring metrics"""
    try:
        metrics = SystemService.get_real_time_metrics()
        return jsonify(metrics), 200
        
    except Exception as e:
        logger.error(f"CineBrain monitoring metrics error: {e}")
        return jsonify({
            'error': 'Failed to get monitoring metrics',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# CLI OPERATIONS ROUTES
# ============================================================================

@system_bp.route('/api/system/cli/status', methods=['GET'])
def cli_operations_status():
    """Get status of CLI operations"""
    try:
        cli_status = SystemService.get_cli_operations_status()
        return jsonify(cli_status), 200
        
    except Exception as e:
        logger.error(f"CineBrain CLI status error: {e}")
        return jsonify({
            'error': 'Failed to get CLI operations status',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# ============================================================================
# SYSTEM INFORMATION ROUTES
# ============================================================================

@system_bp.route('/api/system/info', methods=['GET'])
def system_info():
    """Get comprehensive system information"""
    try:
        sys_info = SystemService.get_system_info()
        return jsonify(sys_info), 200
        
    except Exception as e:
        logger.error(f"CineBrain system info error: {e}")
        return jsonify({
            'error': 'Failed to get system information',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@system_bp.route('/api/system/version', methods=['GET'])
def version_info():
    """Get CineBrain version and build information"""
    try:
        version_data = SystemService.get_version_info()
        return jsonify(version_data), 200
        
    except Exception as e:
        logger.error(f"CineBrain version info error: {e}")
        return jsonify({
            'error': 'Failed to get version information',
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# Export the initialization function
__all__ = ['system_bp', 'init_system_routes']


4. # system/system.py

import os
import psutil
import platform
from datetime import datetime, timedelta
from typing import Dict, Any, List
import logging
from sqlalchemy import text, func
from sqlalchemy.exc import OperationalError
import redis
import json

logger = logging.getLogger(__name__)

class SystemService:
    """CineBrain System Service for health and performance monitoring"""
    
    db = None
    app = None
    cache = None
    models = None
    services = None
    
    @classmethod
    def init(cls, flask_app, database, app_models, app_services):
        """Initialize the system service"""
        cls.app = flask_app
        cls.db = database
        cls.cache = app_services.get('cache')
        cls.models = app_models
        cls.services = app_services
    
    @classmethod
    def get_health_status(cls) -> Dict[str, Any]:
        """Get overall system health status"""
        health_info = {
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'version': '5.5.0',
            'python_version': platform.python_version(),
            'cinebrain_brand': 'CineBrain Entertainment Platform',
            'service': 'cinebrain_system'
        }
        
        # Database health
        try:
            cls.db.session.execute(text('SELECT 1'))
            health_info['database'] = 'connected'
        except Exception as e:
            health_info['database'] = f'disconnected: {str(e)}'
            health_info['status'] = 'degraded'
        
        # Cache health
        try:
            if cls.cache:
                cls.cache.set('cinebrain_health_check', 'ok', timeout=10)
                if cls.cache.get('cinebrain_health_check') == 'ok':
                    health_info['cache'] = 'connected'
                else:
                    health_info['cache'] = 'error'
                    health_info['status'] = 'degraded'
            else:
                health_info['cache'] = 'not_configured'
        except Exception as e:
            health_info['cache'] = f'disconnected: {str(e)}'
            health_info['status'] = 'degraded'
        
        # Admin services health
        health_info['admin_services'] = cls._check_admin_services_health()
        
        # API Keys health
        health_info['api_keys'] = {
            'tmdb': bool(os.environ.get('TMDB_API_KEY')),
            'youtube': bool(os.environ.get('YOUTUBE_API_KEY')),
            'cloudinary': all([
                os.environ.get('CLOUDINARY_CLOUD_NAME'),
                os.environ.get('CLOUDINARY_API_KEY'),
                os.environ.get('CLOUDINARY_API_SECRET')
            ])
        }
        
        # Services health
        health_info['services'] = cls._get_services_health()
        
        # System resources
        try:
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            health_info['resources'] = {
                'memory_usage': memory.percent,
                'disk_usage': disk.percent,
                'cpu_usage': psutil.cpu_percent(interval=1)
            }
            
            # Alert on high resource usage
            if memory.percent > 90 or disk.percent > 90:
                health_info['status'] = 'degraded'
                health_info['alerts'] = ['High resource usage detected']
                
        except Exception as e:
            logger.warning(f"Could not get system resources: {e}")
        
        return health_info
    
    @classmethod
    def get_detailed_health_status(cls) -> Dict[str, Any]:
        """Get detailed health status with all components"""
        basic_health = cls.get_health_status()
        
        detailed = {
            **basic_health,
            'components': {}
        }
        
        # Database detailed health
        detailed['components']['database'] = cls._get_database_health()
        
        # Cache detailed health
        detailed['components']['cache'] = cls._get_cache_health()
        
        # Services detailed health
        detailed['components']['services'] = cls._get_detailed_services_health()
        
        # Admin system detailed health
        detailed['components']['admin_system'] = cls._get_admin_system_health()
        
        # External APIs health
        detailed['components']['external_apis'] = cls._get_external_apis_health()
        
        # Background processes health
        detailed['components']['background_processes'] = cls._get_background_processes_health()
        
        return detailed
    
    @classmethod
    def get_performance_metrics(cls) -> Dict[str, Any]:
        """Get system performance metrics"""
        performance_data = {
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'cinebrain_brand': 'CineBrain Entertainment Platform',
            'cinebrain_service': 'performance'
        }
        
        # Database performance
        try:
            Content = cls.models.get('Content')
            if Content:
                total_content = Content.query.count()
                content_with_slugs = Content.query.filter(
                    Content.slug != None, Content.slug != ''
                ).count()
                
                performance_data['database'] = {
                    'total_content': total_content,
                    'content_with_slugs': content_with_slugs,
                    'content_without_slugs': total_content - content_with_slugs,
                    'slug_coverage': round((content_with_slugs / total_content * 100), 2) if total_content > 0 else 0
                }
        except Exception as e:
            performance_data['database'] = {'error': str(e)}
        
        # Admin system performance
        performance_data['admin_system'] = cls._get_admin_performance_metrics()
        
        # Cache performance
        performance_data['cache'] = {
            'type': cls.app.config.get('CACHE_TYPE', 'unknown'),
            'status': 'enabled' if cls.cache else 'disabled'
        }
        
        # Service performance
        performance_data['cinebrain_services'] = cls._get_services_performance()
        
        # Optimization status
        performance_data['cinebrain_performance'] = {
            'optimizations_applied': [
                'cinebrain_python_3.13_compatibility',
                'cinebrain_reduced_api_timeouts', 
                'cinebrain_optimized_thread_pools',
                'cinebrain_enhanced_caching',
                'cinebrain_error_handling_improvements',
                'cinebrain_cast_crew_optimization',
                'cinebrain_support_service_integration',
                'cinebrain_admin_notification_system',
                'cinebrain_real_time_monitoring',
                'cinebrain_auth_service_enhanced',
                'cinebrain_user_service_modular',
                'cinebrain_new_releases_service',
                'cinebrain_enhanced_critics_choice_service',
                'cinebrain_recommendation_service_modular',
                'cinebrain_advanced_personalized_system',
                'cinebrain_admin_monitoring_system'
            ],
            'memory_optimizations': 'cinebrain_enabled',
            'unicode_fixes': 'cinebrain_applied',
            'monitoring': 'cinebrain_background_threads_active',
            'admin_monitoring': 'cinebrain_enabled'
        }
        
        return performance_data
    
    @classmethod
    def get_detailed_performance_metrics(cls) -> Dict[str, Any]:
        """Get detailed performance metrics"""
        basic_performance = cls.get_performance_metrics()
        
        detailed = {
            **basic_performance,
            'system_metrics': cls._get_system_metrics(),
            'application_metrics': cls._get_application_metrics(),
            'database_metrics': cls._get_database_metrics(),
            'cache_metrics': cls._get_cache_metrics(),
            'admin_metrics': cls._get_admin_detailed_metrics()
        }
        
        return detailed
    
    @classmethod
    def get_system_statistics(cls) -> Dict[str, Any]:
        """Get comprehensive system statistics"""
        stats = {
            'timestamp': datetime.utcnow().isoformat(),
            'cinebrain_brand': 'CineBrain Entertainment Platform'
        }
        
        try:
            # Content statistics
            Content = cls.models.get('Content')
            User = cls.models.get('User')
            UserInteraction = cls.models.get('UserInteraction')
            Review = cls.models.get('Review')
            SupportTicket = cls.models.get('SupportTicket')
            AdminNotification = cls.models.get('AdminNotification')
            
            if Content:
                stats['content'] = {
                    'total': Content.query.count(),
                    'movies': Content.query.filter_by(content_type='movie').count(),
                    'tv_shows': Content.query.filter_by(content_type='tv').count(),
                    'anime': Content.query.filter_by(content_type='anime').count(),
                    'trending': Content.query.filter_by(is_trending=True).count(),
                    'new_releases': Content.query.filter_by(is_new_release=True).count(),
                    'critics_choice': Content.query.filter_by(is_critics_choice=True).count()
                }
            
            if User:
                total_users = User.query.count()
                active_users = User.query.filter(
                    User.last_active >= datetime.utcnow() - timedelta(days=7)
                ).count()
                admin_users = User.query.filter_by(is_admin=True).count()
                
                stats['users'] = {
                    'total': total_users,
                    'active_7d': active_users,
                    'admins': admin_users,
                    'activity_rate': round((active_users / total_users * 100), 1) if total_users > 0 else 0
                }
            
            if UserInteraction:
                stats['interactions'] = {
                    'total': UserInteraction.query.count(),
                    'views': UserInteraction.query.filter_by(interaction_type='view').count(),
                    'likes': UserInteraction.query.filter_by(interaction_type='like').count(),
                    'favorites': UserInteraction.query.filter_by(interaction_type='favorite').count(),
                    'ratings': UserInteraction.query.filter_by(interaction_type='rating').count(),
                    'watchlist': UserInteraction.query.filter_by(interaction_type='watchlist').count()
                }
            
            if Review:
                stats['reviews'] = {
                    'total': Review.query.count(),
                    'approved': Review.query.filter_by(is_approved=True).count(),
                    'with_spoilers': Review.query.filter_by(has_spoilers=True).count()
                }
            
            # Admin system statistics
            if SupportTicket:
                today = datetime.utcnow().date()
                stats['support'] = {
                    'total_tickets': SupportTicket.query.count(),
                    'open_tickets': SupportTicket.query.filter(
                        SupportTicket.status.in_(['open', 'in_progress'])
                    ).count(),
                    'urgent_tickets': SupportTicket.query.filter_by(priority='urgent').count(),
                    'sla_breached': SupportTicket.query.filter_by(sla_breached=True).count(),
                    'today_tickets': SupportTicket.query.filter(
                        func.date(SupportTicket.created_at) == today
                    ).count()
                }
            
            if AdminNotification:
                stats['admin_notifications'] = {
                    'total': AdminNotification.query.count(),
                    'unread': AdminNotification.query.filter_by(is_read=False).count(),
                    'urgent': AdminNotification.query.filter_by(is_urgent=True).count(),
                    'action_required': AdminNotification.query.filter_by(action_required=True).count()
                }
                
        except Exception as e:
            logger.error(f"Error getting system statistics: {e}")
            stats['error'] = str(e)
        
        return stats
    
    @classmethod
    def get_database_statistics(cls) -> Dict[str, Any]:
        """Get detailed database statistics"""
        db_stats = {
            'timestamp': datetime.utcnow().isoformat(),
            'connection_status': 'unknown'
        }
        
        try:
            # Test connection
            cls.db.session.execute(text('SELECT 1'))
            db_stats['connection_status'] = 'connected'
            
            # Get database size information
            if cls.app.config.get('SQLALCHEMY_DATABASE_URI', '').startswith('postgresql'):
                try:
                    result = cls.db.session.execute(text(
                        "SELECT pg_size_pretty(pg_database_size(current_database())) as size"
                    )).fetchone()
                    db_stats['database_size'] = result[0] if result else 'unknown'
                except Exception:
                    db_stats['database_size'] = 'unknown'
            
            # Table statistics
            tables_stats = {}
            for model_name, model_class in cls.models.items():
                try:
                    if hasattr(model_class, 'query'):
                        tables_stats[model_name.lower()] = {
                            'count': model_class.query.count(),
                            'table_name': model_class.__tablename__ if hasattr(model_class, '__tablename__') else model_name.lower()
                        }
                except Exception as e:
                    tables_stats[model_name.lower()] = {'error': str(e)}
            
            db_stats['tables'] = tables_stats
            
        except Exception as e:
            db_stats['connection_status'] = 'error'
            db_stats['error'] = str(e)
        
        return db_stats
    
    @classmethod
    def get_services_status(cls) -> Dict[str, Any]:
        """Get status of all CineBrain services"""
        services_status = {
            'timestamp': datetime.utcnow().isoformat(),
            'cinebrain_brand': 'CineBrain Entertainment Platform'
        }
        
        # Core services
        services_status['core_services'] = {
            'tmdb_api': bool(os.environ.get('TMDB_API_KEY')),
            'youtube_api': bool(os.environ.get('YOUTUBE_API_KEY')),
            'database': cls._test_database_connection(),
            'cache': cls._test_cache_connection()
        }
        
        # Application services
        services_status['application_services'] = {
            'details_service': 'details_service' in cls.services,
            'content_service': 'ContentService' in cls.services,
            'new_releases_service': 'new_releases_service' in cls.services,
            'critics_choice_service': 'critics_choice_service' in cls.services,
            'support_service': 'support_bp' in cls.app.blueprints,
            'admin_service': 'admin_bp' in cls.app.blueprints,
            'auth_service': 'auth_bp' in cls.app.blueprints,
            'user_service': 'user_bp' in cls.app.blueprints,
            'recommendation_service': 'recommendations' in cls.app.blueprints,
            'personalized_service': 'personalized' in cls.app.blueprints,
            'system_service': True  # This service
        }
        
        # Admin services
        services_status['admin_services'] = {
            'admin_dashboard': 'admin_bp' in cls.app.blueprints,
            'admin_notifications': bool(cls.services.get('admin_notification_service')),
            'support_monitoring': 'support_bp' in cls.app.blueprints,
            'email_notifications': cls._check_email_service(),
            'telegram_notifications': cls._check_telegram_service(),
            'admin_monitoring': True  # This monitoring system
        }
        
        # Advanced services
        services_status['advanced_services'] = {
            'profile_analyzer': 'profile_analyzer' in cls.services,
            'personalized_recommendation_engine': 'personalized_recommendation_engine' in cls.services,
            'recommendation_orchestrator': 'recommendation_orchestrator' in cls.services,
            'ultra_powerful_similarity_engine': True,
            'cinematic_dna_analysis': 'profile_analyzer' in cls.services,
            'real_time_learning': 'profile_analyzer' in cls.services
        }
        
        # External services
        services_status['external_services'] = {
            'cloudinary': all([
                os.environ.get('CLOUDINARY_CLOUD_NAME'),
                os.environ.get('CLOUDINARY_API_KEY'),
                os.environ.get('CLOUDINARY_API_SECRET')
            ]),
            'redis': cls._test_redis_connection(),
            'tmdb': cls._test_tmdb_connection(),
            'jikan': True,  # No API key required
            'youtube': bool(os.environ.get('YOUTUBE_API_KEY'))
        }
        
        return services_status
    
    @classmethod
    def get_cache_statistics(cls) -> Dict[str, Any]:
        """Get cache statistics"""
        cache_stats = {
            'timestamp': datetime.utcnow().isoformat(),
            'cache_enabled': bool(cls.cache),
            'cache_type': cls.app.config.get('CACHE_TYPE', 'not_configured')
        }
        
        if cls.cache:
            try:
                # Test cache functionality
                test_key = 'cinebrain_cache_test'
                test_value = 'test_value'
                
                cls.cache.set(test_key, test_value, timeout=60)
                retrieved_value = cls.cache.get(test_key)
                
                cache_stats['cache_working'] = (retrieved_value == test_value)
                
                # Clean up test key
                cls.cache.delete(test_key)
                
            except Exception as e:
                cache_stats['cache_working'] = False
                cache_stats['cache_error'] = str(e)
        else:
            cache_stats['cache_working'] = False
            cache_stats['message'] = 'Cache not configured'
        
        return cache_stats
    
    @classmethod
    def get_monitoring_alerts(cls) -> Dict[str, Any]:
        """Get system monitoring alerts"""
        alerts = {
            'timestamp': datetime.utcnow().isoformat(),
            'alerts': []
        }
        
        try:
            # Check system resources
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            cpu = psutil.cpu_percent(interval=1)
            
            if memory.percent > 90:
                alerts['alerts'].append({
                    'level': 'critical',
                    'component': 'memory',
                    'message': f'Memory usage is {memory.percent}%',
                    'threshold': '90%'
                })
            
            if disk.percent > 90:
                alerts['alerts'].append({
                    'level': 'critical',
                    'component': 'disk',
                    'message': f'Disk usage is {disk.percent}%',
                    'threshold': '90%'
                })
            
            if cpu > 80:
                alerts['alerts'].append({
                    'level': 'warning',
                    'component': 'cpu',
                    'message': f'CPU usage is {cpu}%',
                    'threshold': '80%'
                })
            
            # Check database connection
            if not cls._test_database_connection():
                alerts['alerts'].append({
                    'level': 'critical',
                    'component': 'database',
                    'message': 'Database connection failed',
                    'action': 'Check database connectivity'
                })
            
            # Check cache connection
            if cls.cache and not cls._test_cache_connection():
                alerts['alerts'].append({
                    'level': 'warning',
                    'component': 'cache',
                    'message': 'Cache connection failed',
                    'action': 'Check cache service'
                })
            
            # Admin-specific alerts
            admin_alerts = cls._get_admin_system_alerts()
            alerts['alerts'].extend(admin_alerts)
            
        except Exception as e:
            alerts['alerts'].append({
                'level': 'error',
                'component': 'monitoring',
                'message': f'Error generating alerts: {str(e)}',
                'action': 'Check monitoring system'
            })
        
        alerts['total_alerts'] = len(alerts['alerts'])
        alerts['critical_count'] = len([a for a in alerts['alerts'] if a.get('level') == 'critical'])
        alerts['warning_count'] = len([a for a in alerts['alerts'] if a.get('level') == 'warning'])
        
        return alerts
    
    @classmethod
    def get_real_time_metrics(cls) -> Dict[str, Any]:
        """Get real-time system metrics"""
        metrics = {
            'timestamp': datetime.utcnow().isoformat()
        }
        
        try:
            # System metrics
            metrics['system'] = {
                'cpu_percent': psutil.cpu_percent(interval=0.1),
                'memory_percent': psutil.virtual_memory().percent,
                'disk_percent': psutil.disk_usage('/').percent,
                'load_average': os.getloadavg() if hasattr(os, 'getloadavg') else [0, 0, 0]
            }
            
            # Database metrics
            metrics['database'] = {
                'connection_status': cls._test_database_connection(),
                'active_connections': cls._get_active_db_connections()
            }
            
            # Cache metrics
            if cls.cache:
                metrics['cache'] = {
                    'connection_status': cls._test_cache_connection(),
                    'type': cls.app.config.get('CACHE_TYPE')
                }
            
            # Admin metrics
            metrics['admin_system'] = cls._get_admin_real_time_metrics()
            
        except Exception as e:
            metrics['error'] = str(e)
        
        return metrics
    
    @classmethod
    def get_cli_operations_status(cls) -> Dict[str, Any]:
        """Get status of CLI operations"""
        cli_status = {
            'timestamp': datetime.utcnow().isoformat(),
            'available_commands': [
                'generate-slugs',
                'populate-cast-crew',
                'cinebrain-new-releases-refresh',
                'analyze-user-profiles',
                'test-personalized-recommendations',
                'admin-system-check',
                'admin-notification-test'
            ]
        }
        
        # Check if required services are available for each command
        cli_status['command_status'] = {
            'generate-slugs': {
                'available': 'details_service' in cls.services,
                'requirements': ['details_service', 'database']
            },
            'populate-cast-crew': {
                'available': all([
                    'details_service' in cls.services,
                    bool(os.environ.get('TMDB_API_KEY'))
                ]),
                'requirements': ['details_service', 'tmdb_api', 'database']
            },
            'cinebrain-new-releases-refresh': {
                'available': 'new_releases_service' in cls.services,
                'requirements': ['new_releases_service', 'tmdb_api', 'database']
            },
            'analyze-user-profiles': {
                'available': 'profile_analyzer' in cls.services,
                'requirements': ['profile_analyzer', 'database']
            },
            'test-personalized-recommendations': {
                'available': 'personalized_recommendation_engine' in cls.services,
                'requirements': ['personalized_recommendation_engine', 'database']
            },
            'admin-system-check': {
                'available': True,
                'requirements': ['admin_system', 'database']
            },
            'admin-notification-test': {
                'available': bool(cls.services.get('admin_notification_service')),
                'requirements': ['admin_notification_service', 'email_service']
            }
        }
        
        return cli_status
    
    @classmethod
    def get_system_info(cls) -> Dict[str, Any]:
        """Get comprehensive system information"""
        sys_info = {
            'timestamp': datetime.utcnow().isoformat(),
            'cinebrain_brand': 'CineBrain Entertainment Platform'
        }
        
        # Platform information
        sys_info['platform'] = {
            'system': platform.system(),
            'release': platform.release(),
            'version': platform.version(),
            'machine': platform.machine(),
            'processor': platform.processor(),
            'python_version': platform.python_version(),
            'python_implementation': platform.python_implementation()
        }
        
        # Environment information
        sys_info['environment'] = {
            'flask_env': os.environ.get('FLASK_ENV', 'production'),
            'debug_mode': cls.app.debug,
            'testing_mode': cls.app.testing,
            'database_url_configured': bool(os.environ.get('DATABASE_URL')),
            'redis_url_configured': bool(os.environ.get('REDIS_URL')),
            'secret_key_configured': bool(cls.app.secret_key)
        }
        
        # Application information
        sys_info['application'] = {
            'name': 'CineBrain',
            'version': '5.5.0',
            'blueprints': list(cls.app.blueprints.keys()),
            'url_rules_count': len(list(cls.app.url_map.iter_rules())),
            'registered_services': list(cls.services.keys()) if cls.services else []
        }
        
        # Admin system information
        sys_info['admin_system'] = {
            'monitoring_enabled': True,
            'notification_system': bool(cls.services.get('admin_notification_service')),
            'email_notifications': cls._check_email_service(),
            'telegram_notifications': cls._check_telegram_service(),
            'support_system': 'support_bp' in cls.app.blueprints
        }
        
        return sys_info
    
    @classmethod
    def get_version_info(cls) -> Dict[str, Any]:
        """Get version and build information"""
        return {
            'cinebrain': {
                'version': '5.5.0',
                'build_date': datetime.utcnow().isoformat(),
                'python_version': platform.python_version(),
                'platform': platform.system()
            },
            'features': {
                'advanced_personalized_recommendations': True,
                'cinematic_dna_analysis': True,
                'real_time_learning': True,
                'telugu_cultural_priority': True,
                'modular_architecture': True,
                'comprehensive_monitoring': True,
                'admin_monitoring': True,
                'security_monitoring': True,
                'performance_tracking': True
            },
            'api_version': '3.0',
            'database_schema_version': '1.0',
            'monitoring_version': '2.0'
        }
    
    # Admin-specific helper methods
    @classmethod
    def _check_admin_services_health(cls) -> Dict[str, str]:
        """Check health of admin-specific services"""
        return {
            'admin_dashboard': 'enabled' if 'admin_bp' in cls.app.blueprints else 'disabled',
            'admin_notifications': 'enabled' if cls.services.get('admin_notification_service') else 'disabled',
            'support_monitoring': 'enabled' if 'support_bp' in cls.app.blueprints else 'disabled',
            'email_service': 'enabled' if cls._check_email_service() else 'disabled',
            'telegram_service': 'enabled' if cls._check_telegram_service() else 'disabled'
        }
    
    @classmethod
    def _get_admin_system_health(cls) -> Dict[str, Any]:
        """Get admin system detailed health"""
        health = {
            'admin_service': 'admin_bp' in cls.app.blueprints,
            'notification_service': bool(cls.services.get('admin_notification_service')),
            'support_system': 'support_bp' in cls.app.blueprints,
            'email_service': cls._check_email_service(),
            'monitoring_active': True
        }
        
        # Check admin notification delivery
        try:
            if cls.services.get('admin_notification_service'):
                health['notification_delivery'] = 'functional'
            else:
                health['notification_delivery'] = 'disabled'
        except Exception as e:
            health['notification_delivery'] = f'error: {str(e)}'
        
        return health
    
    @classmethod
    def _get_admin_performance_metrics(cls) -> Dict[str, Any]:
        """Get admin system performance metrics"""
        try:
            AdminNotification = cls.models.get('AdminNotification')
            SupportTicket = cls.models.get('SupportTicket')
            
            metrics = {
                'admin_service_active': 'admin_bp' in cls.app.blueprints,
                'notification_system_active': bool(cls.services.get('admin_notification_service'))
            }
            
            if AdminNotification:
                total_notifications = AdminNotification.query.count()
                unread_notifications = AdminNotification.query.filter_by(is_read=False).count()
                
                metrics['notifications'] = {
                    'total': total_notifications,
                    'unread': unread_notifications,
                    'read_rate': round(((total_notifications - unread_notifications) / total_notifications * 100), 1) if total_notifications > 0 else 0
                }
            
            if SupportTicket:
                today = datetime.utcnow().date()
                total_tickets = SupportTicket.query.count()
                today_tickets = SupportTicket.query.filter(
                    func.date(SupportTicket.created_at) == today
                ).count()
                
                metrics['support'] = {
                    'total_tickets': total_tickets,
                    'today_tickets': today_tickets,
                    'ticket_growth_rate': today_tickets
                }
            
            return metrics
            
        except Exception as e:
            return {'error': str(e)}
    
    @classmethod
    def _get_admin_detailed_metrics(cls) -> Dict[str, Any]:
        """Get detailed admin metrics"""
        try:
            User = cls.models.get('User')
            AdminNotification = cls.models.get('AdminNotification')
            SupportTicket = cls.models.get('SupportTicket')
            
            metrics = {}
            
            if User:
                admin_users = User.query.filter_by(is_admin=True).all()
                active_admins = [
                    admin for admin in admin_users 
                    if admin.last_active and admin.last_active >= datetime.utcnow() - timedelta(hours=24)
                ]
                
                metrics['admin_users'] = {
                    'total_admins': len(admin_users),
                    'active_admins_24h': len(active_admins),
                    'admin_activity_rate': round((len(active_admins) / len(admin_users) * 100), 1) if admin_users else 0
                }
            
            if AdminNotification:
                recent_notifications = AdminNotification.query.filter(
                    AdminNotification.created_at >= datetime.utcnow() - timedelta(hours=24)
                ).count()
                
                metrics['notifications_24h'] = recent_notifications
            
            if SupportTicket:
                urgent_tickets = SupportTicket.query.filter_by(priority='urgent').count()
                sla_breached = SupportTicket.query.filter_by(sla_breached=True).count()
                
                metrics['support_critical'] = {
                    'urgent_tickets': urgent_tickets,
                    'sla_breached': sla_breached
                }
            
            return metrics
            
        except Exception as e:
            return {'error': str(e)}
    
    @classmethod
    def _get_admin_system_alerts(cls) -> List[Dict[str, Any]]:
        """Get admin system specific alerts"""
        alerts = []
        
        try:
            SupportTicket = cls.models.get('SupportTicket')
            AdminNotification = cls.models.get('AdminNotification')
            
            if SupportTicket:
                # Check for urgent tickets
                urgent_tickets = SupportTicket.query.filter(
                    SupportTicket.priority == 'urgent',
                    SupportTicket.status.in_(['open', 'in_progress'])
                ).count()
                
                if urgent_tickets > 5:
                    alerts.append({
                        'level': 'critical',
                        'component': 'support_system',
                        'message': f'{urgent_tickets} urgent support tickets need attention',
                        'action': 'Review urgent support tickets'
                    })
                
                # Check for SLA breaches
                sla_breached = SupportTicket.query.filter_by(sla_breached=True).count()
                
                if sla_breached > 0:
                    alerts.append({
                        'level': 'warning',
                        'component': 'support_sla',
                        'message': f'{sla_breached} tickets have exceeded SLA',
                        'action': 'Address SLA breaches immediately'
                    })
            
            if AdminNotification:
                # Check for unread urgent notifications
                urgent_unread = AdminNotification.query.filter(
                    AdminNotification.is_urgent == True,
                    AdminNotification.is_read == False
                ).count()
                
                if urgent_unread > 0:
                    alerts.append({
                        'level': 'warning',
                        'component': 'admin_notifications',
                        'message': f'{urgent_unread} urgent admin notifications unread',
                        'action': 'Review urgent notifications'
                    })
            
            # Check email service
            if not cls._check_email_service():
                alerts.append({
                    'level': 'warning',
                    'component': 'email_service',
                    'message': 'Email service not configured or not working',
                    'action': 'Check email service configuration'
                })
            
        except Exception as e:
            alerts.append({
                'level': 'error',
                'component': 'admin_monitoring',
                'message': f'Error checking admin alerts: {str(e)}',
                'action': 'Check admin monitoring system'
            })
        
        return alerts
    
    @classmethod
    def _get_admin_real_time_metrics(cls) -> Dict[str, Any]:
        """Get real-time admin metrics"""
        try:
            metrics = {
                'timestamp': datetime.utcnow().isoformat(),
                'admin_service_status': 'admin_bp' in cls.app.blueprints,
                'notification_service_status': bool(cls.services.get('admin_notification_service')),
                'support_service_status': 'support_bp' in cls.app.blueprints
            }
            
            # Real-time counts
            SupportTicket = cls.models.get('SupportTicket')
            if SupportTicket:
                metrics['live_support_stats'] = {
                    'open_tickets': SupportTicket.query.filter(
                        SupportTicket.status.in_(['open', 'in_progress'])
                    ).count(),
                    'urgent_tickets': SupportTicket.query.filter_by(priority='urgent').count()
                }
            
            AdminNotification = cls.models.get('AdminNotification')
            if AdminNotification:
                metrics['live_notification_stats'] = {
                    'unread_notifications': AdminNotification.query.filter_by(is_read=False).count(),
                    'urgent_notifications': AdminNotification.query.filter(
                        AdminNotification.is_urgent == True,
                        AdminNotification.is_read == False
                    ).count()
                }
            
            return metrics
            
        except Exception as e:
            return {'error': str(e)}
    
    # Helper methods (existing ones updated)
    @classmethod
    def _get_services_health(cls) -> Dict[str, str]:
        """Get basic services health status"""
        return {
            'tmdb': 'enabled' if os.environ.get('TMDB_API_KEY') else 'disabled',
            'youtube': 'enabled' if os.environ.get('YOUTUBE_API_KEY') else 'disabled',
            'details_service': 'enabled' if 'details_service' in cls.services else 'disabled',
            'content_service': 'enabled' if 'ContentService' in cls.services else 'disabled',
            'new_releases_service': 'enabled' if 'new_releases_service' in cls.services else 'disabled',
            'personalized_service': 'enabled' if 'personalized_recommendation_engine' in cls.services else 'disabled',
            'admin_service': 'enabled' if 'admin_bp' in cls.app.blueprints else 'disabled',
            'support_service': 'enabled' if 'support_bp' in cls.app.blueprints else 'disabled'
        }
    
    @classmethod
    def _check_email_service(cls) -> bool:
        """Check if email service is configured"""
        try:
            from auth.service import email_service
            return bool(email_service and email_service.email_enabled)
        except:
            return False
    
    @classmethod
    def _check_telegram_service(cls) -> bool:
        """Check if Telegram service is configured"""
        return all([
            os.environ.get('TELEGRAM_BOT_TOKEN'),
            os.environ.get('TELEGRAM_CHANNEL_ID')
        ])
    
    @classmethod
    def _get_database_health(cls) -> Dict[str, Any]:
        """Get detailed database health"""
        health = {'status': 'unknown'}
        
        try:
            cls.db.session.execute(text('SELECT 1'))
            health['status'] = 'healthy'
            health['connection'] = 'active'
            
            # Check table existence
            tables_exist = {}
            for model_name, model_class in cls.models.items():
                try:
                    if hasattr(model_class, 'query'):
                        model_class.query.limit(1).first()
                        tables_exist[model_name.lower()] = True
                except Exception:
                    tables_exist[model_name.lower()] = False
            
            health['tables'] = tables_exist
            
        except Exception as e:
            health['status'] = 'unhealthy'
            health['error'] = str(e)
        
        return health
    
    @classmethod
    def _get_cache_health(cls) -> Dict[str, Any]:
        """Get detailed cache health"""
        health = {
            'configured': bool(cls.cache),
            'type': cls.app.config.get('CACHE_TYPE', 'not_configured')
        }
        
        if cls.cache:
            try:
                test_key = 'health_check_test'
                cls.cache.set(test_key, 'test', timeout=10)
                result = cls.cache.get(test_key)
                cls.cache.delete(test_key)
                
                health['status'] = 'healthy' if result == 'test' else 'unhealthy'
                health['functional'] = result == 'test'
                
            except Exception as e:
                health['status'] = 'unhealthy'
                health['error'] = str(e)
                health['functional'] = False
        else:
            health['status'] = 'not_configured'
            health['functional'] = False
        
        return health
    
    @classmethod
    def _get_detailed_services_health(cls) -> Dict[str, Any]:
        """Get detailed services health"""
        return {
            'recommendation_engine': {
                'legacy': 'recommendation_engine' in cls.services,
                'advanced': 'personalized_recommendation_engine' in cls.services,
                'profile_analyzer': 'profile_analyzer' in cls.services
            },
            'content_services': {
                'details_service': 'details_service' in cls.services,
                'content_service': 'ContentService' in cls.services,
                'new_releases': 'new_releases_service' in cls.services,
                'critics_choice': 'critics_choice_service' in cls.services
            },
            'user_services': {
                'auth': 'auth_bp' in cls.app.blueprints,
                'user_management': 'user_bp' in cls.app.blueprints,
                'admin': 'admin_bp' in cls.app.blueprints,
                'support': 'support_bp' in cls.app.blueprints
            },
            'admin_services': {
                'notification_system': bool(cls.services.get('admin_notification_service')),
                'monitoring_system': True,
                'email_service': cls._check_email_service(),
                'telegram_service': cls._check_telegram_service()
            }
        }
    
    @classmethod
    def _get_external_apis_health(cls) -> Dict[str, Any]:
        """Get external APIs health"""
        return {
            'tmdb': {
                'configured': bool(os.environ.get('TMDB_API_KEY')),
                'functional': cls._test_tmdb_connection()
            },
            'youtube': {
                'configured': bool(os.environ.get('YOUTUBE_API_KEY')),
                'functional': bool(os.environ.get('YOUTUBE_API_KEY'))
            },
            'cloudinary': {
                'configured': all([
                    os.environ.get('CLOUDINARY_CLOUD_NAME'),
                    os.environ.get('CLOUDINARY_API_KEY'),
                    os.environ.get('CLOUDINARY_API_SECRET')
                ]),
                'functional': True
            },
            'jikan': {
                'configured': True,
                'functional': True
            }
        }
    
    @classmethod
    def _get_background_processes_health(cls) -> Dict[str, Any]:
        """Get background processes health"""
        return {
            'support_monitoring': True,
            'admin_monitoring': True,
            'recommendation_updates': 'personalized_recommendation_engine' in cls.services,
            'cache_management': bool(cls.cache),
            'database_connections': cls._test_database_connection(),
            'notification_delivery': bool(cls.services.get('admin_notification_service'))
        }
    
    @classmethod
    def _get_services_performance(cls) -> Dict[str, str]:
        """Get services performance status"""
        return {
            'new_releases_service': 'enabled' if 'new_releases_service' in cls.services else 'disabled',
            'critics_choice_service': 'enabled' if 'critics_choice_service' in cls.services else 'disabled',
            'algorithms': 'cinebrain_optimized_enabled',
            'slug_support': 'cinebrain_comprehensive_enabled',
            'details_service': 'enabled' if 'details_service' in cls.services else 'disabled',
            'content_service': 'enabled' if 'ContentService' in cls.services else 'disabled',
            'cast_crew': 'cinebrain_fully_enabled',
            'support_service': 'enabled' if 'support_bp' in cls.app.blueprints else 'disabled',
            'admin_notifications': 'cinebrain_enabled',
            'admin_monitoring': 'cinebrain_active',
            'monitoring': 'cinebrain_active',
            'auth_service': 'enabled' if 'auth_bp' in cls.app.blueprints else 'disabled',
            'user_service': 'enabled' if 'user_bp' in cls.app.blueprints else 'disabled',
            'recommendation_service': 'enabled' if 'recommendations' in cls.app.blueprints else 'disabled',
            'personalized_service': 'enabled' if 'personalized' in cls.app.blueprints else 'disabled'
        }
    
    @classmethod
    def _get_system_metrics(cls) -> Dict[str, Any]:
        """Get detailed system metrics"""
        try:
            return {
                'cpu': {
                    'percent': psutil.cpu_percent(interval=1),
                    'count': psutil.cpu_count(),
                    'load_avg': os.getloadavg() if hasattr(os, 'getloadavg') else [0, 0, 0]
                },
                'memory': {
                    'total': psutil.virtual_memory().total,
                    'available': psutil.virtual_memory().available,
                    'percent': psutil.virtual_memory().percent,
                    'used': psutil.virtual_memory().used
                },
                'disk': {
                    'total': psutil.disk_usage('/').total,
                    'used': psutil.disk_usage('/').used,
                    'free': psutil.disk_usage('/').free,
                    'percent': psutil.disk_usage('/').percent
                }
            }
        except Exception as e:
            return {'error': str(e)}
    
    @classmethod
    def _get_application_metrics(cls) -> Dict[str, Any]:
        """Get application-specific metrics"""
        return {
            'blueprints_count': len(cls.app.blueprints),
            'url_rules_count': len(list(cls.app.url_map.iter_rules())),
            'registered_services_count': len(cls.services) if cls.services else 0,
            'debug_mode': cls.app.debug,
            'testing_mode': cls.app.testing,
            'admin_system_active': 'admin_bp' in cls.app.blueprints,
            'monitoring_system_active': True
        }
    
    @classmethod
    def _get_database_metrics(cls) -> Dict[str, Any]:
        """Get database performance metrics"""
        metrics = {}
        
        try:
            # Connection test
            start_time = datetime.utcnow()
            cls.db.session.execute(text('SELECT 1'))
            response_time = (datetime.utcnow() - start_time).total_seconds() * 1000
            
            metrics['response_time_ms'] = response_time
            metrics['connection_status'] = 'healthy'
            
        except Exception as e:
            metrics['connection_status'] = 'unhealthy'
            metrics['error'] = str(e)
        
        return metrics
    
    @classmethod
    def _get_cache_metrics(cls) -> Dict[str, Any]:
        """Get cache performance metrics"""
        metrics = {
            'configured': bool(cls.cache),
            'type': cls.app.config.get('CACHE_TYPE')
        }
        
        if cls.cache:
            try:
                # Test cache performance
                start_time = datetime.utcnow()
                cls.cache.set('perf_test', 'test', timeout=10)
                cls.cache.get('perf_test')
                cls.cache.delete('perf_test')
                response_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                
                metrics['response_time_ms'] = response_time
                metrics['functional'] = True
                
            except Exception as e:
                metrics['functional'] = False
                metrics['error'] = str(e)
        
        return metrics
    
    @classmethod
    def _test_database_connection(cls) -> bool:
        """Test database connection"""
        try:
            cls.db.session.execute(text('SELECT 1'))
            return True
        except Exception:
            return False
    
    @classmethod
    def _test_cache_connection(cls) -> bool:
        """Test cache connection"""
        if not cls.cache:
            return False
        
        try:
            cls.cache.set('test_connection', 'test', timeout=10)
            result = cls.cache.get('test_connection')
            cls.cache.delete('test_connection')
            return result == 'test'
        except Exception:
            return False
    
    @classmethod
    def _test_redis_connection(cls) -> bool:
        """Test Redis connection"""
        redis_url = os.environ.get('REDIS_URL')
        if not redis_url:
            return False
        
        try:
            import redis
            r = redis.from_url(redis_url)
            r.ping()
            return True
        except Exception:
            return False
    
    @classmethod
    def _test_tmdb_connection(cls) -> bool:
        """Test TMDB API connection"""
        return bool(os.environ.get('TMDB_API_KEY'))
    
    @classmethod
    def _get_active_db_connections(cls) -> int:
        """Get active database connections count"""
        try:
            if cls.app.config.get('SQLALCHEMY_DATABASE_URI', '').startswith('postgresql'):
                result = cls.db.session.execute(text(
                    "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'"
                )).fetchone()
                return result[0] if result else 0
        except Exception:
            pass
        return 0