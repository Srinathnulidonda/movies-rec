memorize my users folder files

1. # user/__init__.py
"""
CineBrain User Module
Comprehensive user management system with modular architecture
"""

from .routes import user_bp

__all__ = ['user_bp']
__version__ = '1.0.0'




2. # user/activity.py
from flask import request, jsonify
from datetime import datetime
import json
import logging

logger = logging.getLogger(__name__)

def record_interaction(current_user):
    """Record user interaction with content"""
    try:
        # Import inside function to get initialized versions
        from .utils import (
            db, UserInteraction, Content, create_minimal_content_record, 
            content_service, recommendation_engine, profile_analyzer, 
            personalized_recommendation_engine
        )
        
        data = request.get_json()
        
        required_fields = ['content_id', 'interaction_type']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields for CineBrain interaction'}), 400
        
        original_content_id = data['content_id']
        actual_content_id = original_content_id
        
        # FIX: First check if content exists with the given ID
        content_exists = Content.query.filter_by(id=original_content_id).first()
        
        if not content_exists:
            logger.warning(f"CineBrain: Content {original_content_id} not found in database, attempting to create")
            
            try:
                content_metadata = data.get('metadata', {})
                content_info = content_metadata.get('content_info')
                
                if content_info:
                    # FIX: Try to find existing content by TMDB ID first
                    if content_info.get('tmdb_id'):
                        existing_by_tmdb = Content.query.filter_by(tmdb_id=content_info['tmdb_id']).first()
                        if existing_by_tmdb:
                            content_exists = existing_by_tmdb
                            actual_content_id = existing_by_tmdb.id
                            logger.info(f"CineBrain: Found existing content by TMDB ID, using ID {actual_content_id}")
                    
                    # If not found by TMDB ID, try to create from TMDB
                    if not content_exists and content_service and content_info.get('tmdb_id'):
                        try:
                            from app import CineBrainTMDBService
                            tmdb_data = CineBrainTMDBService.get_content_details(
                                content_info['tmdb_id'], 
                                content_info.get('content_type', 'movie').strip()
                            )
                            if tmdb_data:
                                content_exists = content_service.save_content_from_tmdb(
                                    tmdb_data, 
                                    content_info.get('content_type', 'movie').strip()
                                )
                                if content_exists:
                                    actual_content_id = content_exists.id
                                    logger.info(f"CineBrain: Created content from TMDB with ID {actual_content_id}")
                        except Exception as e:
                            logger.warning(f"Failed to fetch from TMDB: {e}")
                    
                    # Create minimal record as last resort
                    if not content_exists:
                        content_exists = create_minimal_content_record(original_content_id, content_info)
                        if content_exists:
                            actual_content_id = content_exists.id
                
                if not content_exists:
                    return jsonify({
                        'error': 'Content not found in CineBrain database',
                        'details': 'Unable to create or fetch content record. Please try again.'
                    }), 404
                    
            except Exception as e:
                logger.error(f"Failed to create content record: {e}")
                return jsonify({
                    'error': 'Content not found in CineBrain database',
                    'details': 'Unable to create content record due to data validation error'
                }), 404
        
        # Handle removal interactions
        if data['interaction_type'] in ['remove_watchlist', 'remove_favorite']:
            interaction_type = 'watchlist' if data['interaction_type'] == 'remove_watchlist' else 'favorite'
            
            # FIX: First check with actual_content_id, then try original
            interaction = UserInteraction.query.filter_by(
                user_id=current_user.id,
                content_id=actual_content_id,
                interaction_type=interaction_type
            ).first()
            
            # If not found with actual ID, try finding by TMDB ID mapping
            if not interaction and original_content_id != actual_content_id:
                # Try with original ID in case it wasn't mapped
                interaction = UserInteraction.query.filter_by(
                    user_id=current_user.id,
                    content_id=original_content_id,
                    interaction_type=interaction_type
                ).first()
            
            if interaction:
                db.session.delete(interaction)
                db.session.commit()
                
                # Update recommendation systems
                update_results = []
                
                if profile_analyzer:
                    try:
                        success = profile_analyzer.update_profile_realtime(
                            current_user.id,
                            {
                                'content_id': interaction.content_id,  # Use the actual ID from database
                                'interaction_type': data['interaction_type'],
                                'metadata': data.get('metadata', {})
                            }
                        )
                        if success:
                            update_results.append('advanced_profile_updated')
                    except Exception as e:
                        logger.warning(f"Failed to update CineBrain advanced profile for removal: {e}")
                
                if recommendation_engine:
                    try:
                        if hasattr(recommendation_engine, 'update_user_preferences_realtime'):
                            recommendation_engine.update_user_preferences_realtime(
                                current_user.id,
                                {
                                    'content_id': interaction.content_id,  # Use the actual ID from database
                                    'interaction_type': data['interaction_type'],
                                    'metadata': data.get('metadata', {})
                                }
                            )
                            update_results.append('legacy_profile_updated')
                        elif hasattr(recommendation_engine, 'update_user_profile'):
                            recommendation_engine.update_user_profile(
                                current_user.id,
                                {
                                    'content_id': interaction.content_id,  # Use the actual ID from database
                                    'interaction_type': data['interaction_type'],
                                    'metadata': data.get('metadata', {})
                                }
                            )
                            update_results.append('profile_updated')
                    except Exception as e:
                        logger.warning(f"Failed to update CineBrain profile for removal: {e}")
                
                message = f'Removed from CineBrain {"watchlist" if interaction_type == "watchlist" else "favorites"}'
                return jsonify({
                    'success': True,
                    'message': message,
                    'real_time_updates': update_results,
                    'actual_content_id': interaction.content_id,
                    'removed_id': interaction.content_id
                }), 200
            else:
                # FIX: Return success even if not found in interactions (it was already removed from favorites)
                item_type = "watchlist" if interaction_type == "watchlist" else "favorites"
                logger.info(f"CineBrain: No interaction found for removal, but continuing (content_id: {actual_content_id})")
                
                return jsonify({
                    'success': True,
                    'message': f'Item removed from CineBrain {item_type}',
                    'note': 'Interaction record not found but operation completed',
                    'actual_content_id': actual_content_id
                }), 200
        
        # Check for existing interaction
        if data['interaction_type'] in ['watchlist', 'favorite']:
            existing = UserInteraction.query.filter_by(
                user_id=current_user.id,
                content_id=actual_content_id,  # FIX: Use actual_content_id
                interaction_type=data['interaction_type']
            ).first()
            
            if existing:
                item_type = "watchlist" if data['interaction_type'] == "watchlist" else "favorites"
                return jsonify({
                    'success': True,
                    'message': f'Already in CineBrain {item_type}',
                    'actual_content_id': actual_content_id  # FIX: Return actual ID
                }), 200
        
        # Create new interaction with actual content ID
        interaction = UserInteraction(
            user_id=current_user.id,
            content_id=actual_content_id,  # FIX: Use actual_content_id
            interaction_type=data['interaction_type'],
            rating=data.get('rating'),
            interaction_metadata=json.dumps(data.get('metadata', {}))
        )
        
        db.session.add(interaction)
        db.session.commit()
        
        # Update recommendation systems with actual content ID
        update_results = []
        
        if profile_analyzer:
            try:
                success = profile_analyzer.update_profile_realtime(
                    current_user.id,
                    {
                        'content_id': actual_content_id,  # FIX: Use actual_content_id
                        'interaction_type': data['interaction_type'],
                        'rating': data.get('rating'),
                        'metadata': data.get('metadata', {})
                    }
                )
                if success:
                    update_results.append('advanced_profile_updated')
                    logger.info(f"Successfully updated CineBrain advanced profile for user {current_user.id}")
            except Exception as e:
                logger.warning(f"Failed to update CineBrain advanced profile: {e}")
        
        if recommendation_engine:
            try:
                if hasattr(recommendation_engine, 'update_user_preferences_realtime'):
                    recommendation_engine.update_user_preferences_realtime(
                        current_user.id,
                        {
                            'content_id': actual_content_id,  # FIX: Use actual_content_id
                            'interaction_type': data['interaction_type'],
                            'rating': data.get('rating'),
                            'metadata': data.get('metadata', {})
                        }
                    )
                    update_results.append('legacy_profile_updated')
                elif hasattr(recommendation_engine, 'update_user_profile'):
                    recommendation_engine.update_user_profile(
                        current_user.id,
                        {
                            'content_id': actual_content_id,  # FIX: Use actual_content_id
                            'interaction_type': data['interaction_type'],
                            'rating': data.get('rating'),
                            'metadata': data.get('metadata', {})
                        }
                    )
                    update_results.append('profile_updated')
                logger.info(f"Successfully updated CineBrain profile for user {current_user.id}")
            except Exception as e:
                logger.warning(f"Failed to update CineBrain profile: {e}")
        
        return jsonify({
            'success': True,
            'message': 'CineBrain interaction recorded successfully',
            'interaction_id': interaction.id,
            'real_time_updates': update_results,
            'advanced_features_active': bool(profile_analyzer),
            'actual_content_id': actual_content_id  # FIX: Return actual ID
        }), 201
        
    except Exception as e:
        logger.error(f"CineBrain interaction recording error: {e}")
        from .utils import db
        if db:
            db.session.rollback()
        return jsonify({'error': 'Failed to record CineBrain interaction'}), 500

def get_public_activity(username):
    """Get public activity for a username"""
    try:
        from .utils import User, UserInteraction, Content
        
        user = User.query.filter_by(username=username).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        # Return limited public activity
        public_interactions = UserInteraction.query.filter_by(
            user_id=user.id,
            interaction_type='rating'  # Only show ratings publicly
        ).order_by(UserInteraction.timestamp.desc()).limit(10).all()
        
        formatted_activity = []
        for interaction in public_interactions:
            content = Content.query.get(interaction.content_id)
            if content:
                formatted_activity.append({
                    'interaction_type': interaction.interaction_type,
                    'rating': interaction.rating,
                    'timestamp': interaction.timestamp.isoformat(),
                    'content': {
                        'id': content.id,
                        'title': content.title,
                        'content_type': content.content_type,
                        'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path
                    }
                })
        
        return jsonify({'recent_activity': formatted_activity}), 200
    except Exception as e:
        logger.error(f"Error getting public activity: {e}")
        return jsonify({'error': 'Failed to get activity'}), 500

def get_public_stats(username):
    """Get public stats for a username"""
    try:
        from .utils import User, UserInteraction
        
        user = User.query.filter_by(username=username).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        # Return limited public stats
        interactions = UserInteraction.query.filter_by(user_id=user.id).all()
        
        public_stats = {
            'total_interactions': len(interactions),
            'favorites': len([i for i in interactions if i.interaction_type == 'favorite']),
            'ratings_given': len([i for i in interactions if i.interaction_type == 'rating'])
        }
        
        return jsonify({'stats': public_stats}), 200
    except Exception as e:
        logger.error(f"Error getting public stats: {e}")
        return jsonify({'error': 'Failed to get stats'}), 500




3. # user/avatar.py
from flask import request, jsonify
from datetime import datetime
import logging
import cloudinary
import cloudinary.uploader
import cloudinary.api
import os
import base64
import io
from PIL import Image
import re
from .utils import require_auth, db, User

logger = logging.getLogger(__name__)

# Configure Cloudinary
cloudinary.config(
    cloud_name=os.environ.get('CLOUDINARY_CLOUD_NAME'),
    api_key=os.environ.get('CLOUDINARY_API_KEY'),
    api_secret=os.environ.get('CLOUDINARY_API_SECRET'),
    secure=True
)

def validate_avatar_upload(file_data):
    """Validate uploaded avatar file"""
    try:
        if file_data.startswith('data:image/'):
            header, encoded = file_data.split(',', 1)
            file_data = base64.b64decode(encoded)
        
        image = Image.open(io.BytesIO(file_data))
        
        if image.format not in ['JPEG', 'PNG', 'WEBP']:
            return False, "Invalid image format. Only JPEG, PNG, and WEBP are allowed."
        
        if len(file_data) > 5 * 1024 * 1024:
            return False, "Image size too large. Maximum 5MB allowed."
        
        width, height = image.size
        if width > 2048 or height > 2048:
            return False, "Image dimensions too large. Maximum 2048x2048 pixels."
        
        if width < 50 or height < 50:
            return False, "Image too small. Minimum 50x50 pixels required."
        
        return True, "Valid image"
        
    except Exception as e:
        return False, f"Invalid image data: {str(e)}"

def process_avatar_image(file_data):
    """Process and optimize avatar image"""
    try:
        if isinstance(file_data, str) and file_data.startswith('data:image/'):
            header, encoded = file_data.split(',', 1)
            file_data = base64.b64decode(encoded)
        
        image = Image.open(io.BytesIO(file_data))
        
        if image.mode in ('RGBA', 'LA', 'P'):
            background = Image.new('RGB', image.size, (255, 255, 255))
            if image.mode == 'P':
                image = image.convert('RGBA')
            background.paste(image, mask=image.split()[-1] if image.mode == 'RGBA' else None)
            image = background
        
        image = image.resize((300, 300), Image.Resampling.LANCZOS)
        
        output = io.BytesIO()
        image.save(output, format='JPEG', quality=85, optimize=True)
        output.seek(0)
        
        return output.getvalue()
        
    except Exception as e:
        logger.error(f"Error processing avatar image: {e}")
        return None

def clean_username_for_storage(username):
    """Clean username for safe storage"""
    return re.sub(r'[^a-zA-Z0-9_-]', '_', username.lower())

def delete_old_avatar(current_user):
    """Delete old avatar from Cloudinary"""
    if not current_user.avatar_url:
        return
        
    if 'cloudinary' in current_user.avatar_url:
        try:
            clean_username = clean_username_for_storage(current_user.username)
            old_public_id = f"cinebrain/avatars/cinebrain_avatar_{clean_username}"
            cloudinary.uploader.destroy(old_public_id)
            
            url_parts = current_user.avatar_url.split('/')
            if len(url_parts) > 2:
                public_id = url_parts[-1].split('.')[0]
                if public_id.startswith('cinebrain_avatar_'):
                    cloudinary.uploader.destroy(f"cinebrain/avatars/{public_id}")
        except Exception as e:
            logger.warning(f"Failed to delete old avatar: {e}")

def upload_avatar_to_cloudinary(processed_image, username):
    """Upload avatar to Cloudinary"""
    clean_username = clean_username_for_storage(username)
    
    upload_result = cloudinary.uploader.upload(
        processed_image,
        folder="cinebrain/avatars",
        public_id=f"cinebrain_avatar_{clean_username}",
        transformation=[
            {'width': 300, 'height': 300, 'crop': 'fill', 'gravity': 'face'},
            {'quality': 'auto:good'},
            {'format': 'jpg'}
        ],
        tags=['cinebrain', 'avatar', f'username_{clean_username}'],
        overwrite=True,
        resource_type="image"
    )
    
    return upload_result

def is_cloudinary_configured():
    """Check if Cloudinary is configured"""
    return all([
        os.environ.get('CLOUDINARY_CLOUD_NAME'),
        os.environ.get('CLOUDINARY_API_KEY'),
        os.environ.get('CLOUDINARY_API_SECRET')
    ])

@require_auth
def upload_avatar(current_user):
    """Handle avatar upload"""
    try:
        data = request.get_json()
        
        if not data or 'image' not in data:
            return jsonify({'error': 'No image data provided'}), 400
        
        if not is_cloudinary_configured():
            return jsonify({'error': 'CineBrain avatar upload not configured'}), 503
        
        image_data = data['image']
        
        is_valid, message = validate_avatar_upload(image_data)
        if not is_valid:
            return jsonify({'error': message}), 400
        
        processed_image = process_avatar_image(image_data)
        if not processed_image:
            return jsonify({'error': 'Failed to process image'}), 400
        
        delete_old_avatar(current_user)
        
        try:
            upload_result = upload_avatar_to_cloudinary(processed_image, current_user.username)
            
            current_user.avatar_url = upload_result['secure_url']
            db.session.commit()
            
            logger.info(f"CineBrain: Avatar uploaded successfully for user {current_user.username} (ID: {current_user.id})")
            
            return jsonify({
                'success': True,
                'message': 'Avatar uploaded successfully',
                'avatar_url': upload_result['secure_url'],
                'username': current_user.username,
                'cloudinary_data': {
                    'public_id': upload_result['public_id'],
                    'version': upload_result['version'],
                    'width': upload_result['width'],
                    'height': upload_result['height'],
                    'format': upload_result['format'],
                    'bytes': upload_result['bytes'],
                    'stored_as': f"cinebrain_avatar_{clean_username_for_storage(current_user.username)}"
                }
            }), 200
            
        except cloudinary.exceptions.Error as e:
            logger.error(f"Cloudinary upload error for user {current_user.username}: {e}")
            return jsonify({'error': 'Failed to upload image to cloud storage'}), 500
            
    except Exception as e:
        logger.error(f"CineBrain avatar upload error for user {current_user.username}: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to upload avatar'}), 500

@require_auth
def delete_avatar(current_user):
    """Handle avatar deletion"""
    try:
        if not current_user.avatar_url:
            return jsonify({'error': 'No avatar to delete'}), 400
        
        if 'cloudinary' in current_user.avatar_url:
            delete_old_avatar(current_user)
        
        current_user.avatar_url = None
        db.session.commit()
        
        logger.info(f"CineBrain: Avatar deleted for user {current_user.username} (ID: {current_user.id})")
        
        return jsonify({
            'success': True,
            'message': 'Avatar deleted successfully',
            'username': current_user.username
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain avatar deletion error for user {current_user.username}: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to delete avatar'}), 500

@require_auth
def get_avatar_url(current_user):
    """Get current avatar URL"""
    try:
        return jsonify({
            'success': True,
            'avatar_url': current_user.avatar_url,
            'has_avatar': bool(current_user.avatar_url),
            'username': current_user.username
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain get avatar URL error: {e}")
        return jsonify({'error': 'Failed to get avatar URL'}), 500




4. # user/dashboard.py
from flask import request, jsonify
from datetime import datetime, timedelta
from typing import Dict, Any, List
import json
import logging
from .utils import require_auth, get_enhanced_user_stats, recommendation_engine, get_cinematic_dna_summary, profile_analyzer

logger = logging.getLogger(__name__)

@require_auth
def get_user_analytics(current_user):
    """Get comprehensive user analytics"""
    try:
        analytics = get_enhanced_user_stats(current_user.id)
        
        insights = {
            'recommendations': {
                'total_generated': analytics.get('total_interactions', 0),
                'accuracy_score': analytics.get('engagement_metrics', {}).get('engagement_score', 0),
                'improvement_tips': []
            },
            'content_preferences': {
                'diversity_level': 'high' if analytics.get('content_diversity', {}).get('diversity_score', 0) > 0.7 else 'medium',
                'exploration_tendency': analytics.get('discovery_score', 0),
                'quality_preference': analytics.get('quality_preferences', {}).get('quality_preference', 'balanced')
            },
            'engagement_level': 'high' if analytics.get('engagement_metrics', {}).get('engagement_score', 0) > 0.7 else 'moderate'
        }
        
        if analytics.get('total_interactions', 0) < 10:
            insights['recommendations']['improvement_tips'].append(
                "Interact with more CineBrain content (like, favorite, rate) to improve recommendations"
            )
        
        if analytics.get('ratings_given', 0) < 5:
            insights['recommendations']['improvement_tips'].append(
                "Rate CineBrain content to help our AI understand your preferences better"
            )
        
        if analytics.get('content_diversity', {}).get('genre_diversity_count', 0) < 5:
            insights['recommendations']['improvement_tips'].append(
                "Explore different genres on CineBrain to discover new content you might love"
            )
        
        return jsonify({
            'success': True,
            'analytics': analytics,
            'insights': insights,
            'generated_at': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain analytics error: {e}")
        return jsonify({'error': 'Failed to get CineBrain analytics'}), 500

@require_auth
def get_profile_insights(current_user):
    """Get profile insights for user dashboard"""
    try:
        # Try to use new profile analyzer first
        if profile_analyzer:
            try:
                user_profile = profile_analyzer.build_comprehensive_profile(current_user.id)
                
                if user_profile:
                    # Enhanced insights from new system
                    cinematic_dna = user_profile.get('cinematic_dna', {})
                    behavior_profile = user_profile.get('behavior_profile', {})
                    
                    insights = {
                        'profile_strength': {
                            'completeness': user_profile.get('profile_confidence', 0),
                            'confidence': user_profile.get('profile_confidence', 0),
                            'status': user_profile.get('personalization_readiness', 'developing'),
                            'recommendation_strategy': user_profile.get('recommendations_strategy', 'content_based'),
                            'interactions_needed': max(0, 20 - user_profile.get('content_history_size', 0))
                        },
                        'cinematic_dna': {
                            'sophistication_score': cinematic_dna.get('cinematic_sophistication_score', 0),
                            'narrative_preferences': cinematic_dna.get('narrative_preferences', {}),
                            'style_affinities': cinematic_dna.get('style_affinities', {}),
                            'cultural_alignment': cinematic_dna.get('cultural_alignment', {}),
                            'telugu_affinity': cinematic_dna.get('telugu_cultural_affinity', 0),
                            'indian_affinity': cinematic_dna.get('indian_cultural_affinity', 0),
                            'global_exposure': cinematic_dna.get('global_cinema_exposure', 0),
                            'production_scale_preference': cinematic_dna.get('production_scale_preference', 'medium')
                        },
                        'preferences': {
                            'top_genres': list(cinematic_dna.get('genre_sophistication', {}).keys())[:5],
                            'preferred_languages': _extract_preferred_languages(user_profile),
                            'narrative_themes': list(cinematic_dna.get('narrative_preferences', {}).keys())[:3],
                            'quality_threshold': behavior_profile.get('rating_behavior', {}).get('harsh_rating_threshold', 6.0)
                        },
                        'behavior': {
                            'engagement_score': behavior_profile.get('engagement_patterns', {}).get('total_weighted_engagement', 0),
                            'viewing_style': _determine_viewing_style(behavior_profile),
                            'exploration_tendency': behavior_profile.get('content_exploration', {}).get('exploration_tendency', 'medium'),
                            'total_interactions': user_profile.get('content_history_size', 0),
                            'consistency': behavior_profile.get('temporal_behavior', {}).get('activity_consistency', 0),
                            'binge_tendency': behavior_profile.get('temporal_behavior', {}).get('binge_tendency', 0)
                        },
                        'recent_activity': behavior_profile.get('recent_activity', {}),
                        'recommendations_quality': {
                            'accuracy_estimate': min(user_profile.get('profile_confidence', 0) * 100, 95),
                            'personalization_level': user_profile.get('personalization_readiness', 'developing'),
                            'next_improvement': _get_advanced_improvement_suggestion(user_profile),
                            'strategies_available': _get_available_strategies(user_profile)
                        }
                    }
                    
                    return jsonify({
                        'success': True,
                        'insights': insights,
                        'profile_version': user_profile.get('profile_version', '3.0'),
                        'last_updated': user_profile.get('profile_created_at', datetime.utcnow().isoformat()),
                        'next_update': user_profile.get('next_update_due', (datetime.utcnow() + timedelta(hours=24)).isoformat()),
                        'advanced_features': {
                            'cinematic_dna': True,
                            'behavioral_analysis': True,
                            'preference_embeddings': True,
                            'real_time_learning': True
                        }
                    }), 200
            except Exception as e:
                logger.warning(f"Error using advanced profile analyzer: {e}")
                # Fall through to legacy system
        
        # Fallback to legacy recommendation engine
        if not recommendation_engine:
            return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
        
        user_profile = recommendation_engine.user_profiler.build_comprehensive_user_profile(current_user.id)
        
        if not user_profile:
            return jsonify({
                'success': False,
                'message': 'Could not build CineBrain user profile - insufficient interaction data',
                'suggestion': 'Interact with more CineBrain content to build your profile'
            }), 404
        
        insights = {
            'profile_strength': {
                'completeness': user_profile.get('profile_completeness', 0),
                'confidence': user_profile.get('confidence_score', 0),
                'status': 'strong' if user_profile.get('confidence_score', 0) > 0.7 else 'developing',
                'interactions_needed': max(0, 20 - user_profile.get('implicit_preferences', {}).get('total_interactions', 0))
            },
            'preferences': {
                'top_genres': user_profile.get('genre_preferences', {}).get('top_genres', [])[:5],
                'preferred_languages': user_profile.get('language_preferences', {}).get('preferred_languages', [])[:3],
                'content_types': user_profile.get('content_type_preferences', {}).get('content_type_scores', {}),
                'quality_threshold': user_profile.get('quality_preferences', {}).get('min_rating', 6.0)
            },
            'behavior': {
                'engagement_score': user_profile.get('engagement_score', 0),
                'viewing_style': user_profile.get('implicit_preferences', {}).get('most_common_interaction', 'explorer'),
                'exploration_tendency': user_profile.get('exploration_tendency', 0),
                'total_interactions': user_profile.get('implicit_preferences', {}).get('total_interactions', 0),
                'consistency': user_profile.get('temporal_patterns', {}).get('activity_consistency', 0)
            },
            'recent_activity': user_profile.get('recent_activity', {}),
            'recommendations_quality': {
                'accuracy_estimate': min(user_profile.get('confidence_score', 0) * 100, 95),
                'personalization_level': 'high' if user_profile.get('confidence_score', 0) > 0.8 else 'moderate',
                'next_improvement': _get_improvement_suggestion(user_profile)
            }
        }
        
        return jsonify({
            'success': True,
            'insights': insights,
            'last_updated': user_profile.get('last_updated', datetime.utcnow()).isoformat(),
            'profile_version': '3.0'
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain Profile insights error: {e}")
        return jsonify({'error': 'Failed to get CineBrain profile insights'}), 500

def _get_improvement_suggestion(user_profile):
    """Get personalized improvement suggestion"""
    completeness = user_profile.get('profile_completeness', 0)
    total_interactions = user_profile.get('implicit_preferences', {}).get('total_interactions', 0)
    ratings_count = user_profile.get('explicit_preferences', {}).get('ratings_count', 0)
    
    if completeness < 0.3:
        return 'Interact with more CineBrain content (like, favorite, add to watchlist) to improve accuracy'
    elif ratings_count < 5:
        return 'Rate more CineBrain content to help our AI understand your taste better'
    elif completeness < 0.8:
        return 'Explore different genres on CineBrain to get more diverse recommendations'
    else:
        return 'Your CineBrain recommendations are highly accurate! Keep discovering new content'

def _extract_preferred_languages(user_profile: Dict[str, Any]) -> List[str]:
    """Extract preferred languages from advanced profile"""
    cinematic_dna = user_profile.get('cinematic_dna', {})
    cultural_alignment = cinematic_dna.get('cultural_alignment', {})
    
    languages = []
    if cultural_alignment.get('telugu_traditional', 0) > 0.5:
        languages.append('Telugu')
    if cultural_alignment.get('indian_mainstream', 0) > 0.5:
        languages.extend(['Hindi', 'Tamil'])
    if cultural_alignment.get('global_blockbuster', 0) > 0.5:
        languages.append('English')
    
    return languages[:3] if languages else ['Telugu', 'English', 'Hindi']

def _determine_viewing_style(behavior_profile: Dict[str, Any]) -> str:
    """Determine user's viewing style from behavior"""
    binge = behavior_profile.get('temporal_behavior', {}).get('binge_tendency', 0)
    exploration = behavior_profile.get('content_exploration', {}).get('overall_exploration_score', 0)
    
    if binge > 0.7:
        return 'binge_watcher'
    elif exploration > 0.7:
        return 'explorer'
    elif binge < 0.3 and exploration < 0.3:
        return 'casual_viewer'
    else:
        return 'balanced_viewer'

def _get_advanced_improvement_suggestion(user_profile: Dict[str, Any]) -> str:
    """Get advanced improvement suggestion based on profile analysis"""
    readiness = user_profile.get('personalization_readiness', 'cold_start')
    content_count = user_profile.get('content_history_size', 0)
    confidence = user_profile.get('profile_confidence', 0)
    
    if readiness == 'cold_start':
        return 'Start by exploring content in Telugu and your preferred languages'
    elif readiness == 'low':
        return 'Rate more content to help CineBrain understand your taste better'
    elif readiness == 'medium':
        return 'Try exploring different genres to enhance your Cinematic DNA profile'
    elif readiness == 'high' and confidence < 0.9:
        return 'Your profile is well-developed! Keep discovering new content'
    else:
        return 'Your CineBrain profile is optimized for maximum personalization!'

def _get_available_strategies(user_profile: Dict[str, Any]) -> List[str]:
    """Get list of recommendation strategies available for user"""
    readiness = user_profile.get('personalization_readiness', 'cold_start')
    
    strategies = ['popularity_based', 'language_priority']
    
    if readiness in ['low', 'medium', 'high']:
        strategies.append('content_based')
    
    if readiness in ['medium', 'high']:
        strategies.append('collaborative_filtering')
        strategies.append('cinematic_dna_matching')
    
    if readiness == 'high':
        strategies.append('advanced_hybrid')
        strategies.append('preference_embedding_similarity')
    
    return strategies




5. # user/favorites.py
from flask import request, jsonify
from datetime import datetime
import json
import logging

logger = logging.getLogger(__name__)

def get_actual_content_id(content_id):
    """Get the actual database content ID, handling TMDB ID mapping"""
    try:
        from .utils import Content
        
        # First try the ID as-is
        content = Content.query.filter_by(id=content_id).first()
        if content:
            return content_id
        
        # If not found, try as TMDB ID
        content_by_tmdb = Content.query.filter_by(tmdb_id=content_id).first()
        if content_by_tmdb:
            logger.info(f"CineBrain: Mapped TMDB ID {content_id} to database ID {content_by_tmdb.id}")
            return content_by_tmdb.id
        
        return None
    except Exception as e:
        logger.error(f"Error mapping content ID {content_id}: {e}")
        return None

def create_content_from_tmdb_id(tmdb_id, request_data):
    """Create content from TMDB ID when frontend sends tmdb_movie_xxx format"""
    try:
        from app import CineBrainTMDBService
        from .utils import content_service
        
        # Determine content type from the original ID format
        original_id = request_data.get('content_id', '')
        if 'movie' in original_id:
            content_type = 'movie'
        elif 'tv' in original_id:
            content_type = 'tv'
        else:
            content_type = 'movie'  # Default
            
        # Fetch from TMDB
        tmdb_data = CineBrainTMDBService.get_content_details(int(tmdb_id), content_type)
        
        if tmdb_data and content_service:
            new_content = content_service.save_content_from_tmdb(tmdb_data, content_type)
            if new_content:
                return new_content.id
                
        return None
        
    except Exception as e:
        logger.error(f"Error creating content from TMDB ID {tmdb_id}: {e}")
        return None

def get_favorites(current_user):
    """Get user's favorites"""
    try:
        # Import here to ensure we get the initialized versions
        from .utils import db, UserInteraction, Content, format_content_for_response
        
        favorite_interactions = UserInteraction.query.filter_by(
            user_id=current_user.id,
            interaction_type='favorite'
        ).order_by(UserInteraction.timestamp.desc()).all()
        
        content_ids = [interaction.content_id for interaction in favorite_interactions]
        contents = Content.query.filter(Content.id.in_(content_ids)).all()
        content_map = {content.id: content for content in contents}
        
        result = []
        for interaction in favorite_interactions:
            content = content_map.get(interaction.content_id)
            if content:
                formatted_content = format_content_for_response(content, interaction)
                formatted_content['favorited_at'] = interaction.timestamp.isoformat()
                formatted_content['user_rating'] = interaction.rating
                result.append(formatted_content)
        
        return jsonify({
            'favorites': result,
            'total_count': len(result),
            'last_updated': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain favorites error: {e}")
        return jsonify({'error': 'Failed to get CineBrain favorites'}), 500

def add_to_favorites(current_user):
    """Add content to favorites"""
    try:
        from .utils import db, UserInteraction, Content, recommendation_engine, content_service, create_minimal_content_record
        
        data = request.get_json()
        raw_content_id = data.get('content_id')
        rating = data.get('rating')
        
        if not raw_content_id:
            return jsonify({'error': 'Content ID required'}), 400
        
        # FIX: Validate and convert content_id to integer
        try:
            if isinstance(raw_content_id, str):
                if raw_content_id.startswith(('tmdb_', 'mal_', 'imdb_')):
                    if 'tmdb_movie_' in raw_content_id or 'tmdb_tv_' in raw_content_id:
                        tmdb_id = int(raw_content_id.split('_')[-1])
                        # Try to find existing content by TMDB ID
                        existing_content = Content.query.filter_by(tmdb_id=tmdb_id).first()
                        if existing_content:
                            content_id = existing_content.id
                            logger.info(f"Found existing content by TMDB ID: {tmdb_id} -> ID: {content_id}")
                        else:
                            # Will create new content below
                            content_id = None
                            logger.info(f"Will create new content for TMDB ID: {tmdb_id}")
                    else:
                        return jsonify({'error': 'Invalid content ID format'}), 400
                else:
                    content_id = int(raw_content_id)
            else:
                content_id = int(raw_content_id)
                
        except (ValueError, TypeError) as e:
            logger.error(f"Invalid content ID format: {raw_content_id}, error: {e}")
            return jsonify({'error': 'Invalid content ID format'}), 400
        
        # Check if content exists (if we have an ID)
        content_exists = None
        if content_id:
            content_exists = Content.query.filter_by(id=content_id).first()
        
        if not content_exists:
            logger.warning(f"Content {content_id or raw_content_id} not found, attempting to create from request data")
            
            content_metadata = data.get('metadata', {})
            content_info = content_metadata.get('content_info')
            
            if content_info:
                # Try to fetch from TMDB if we have tmdb_id
                if content_service and content_info.get('tmdb_id'):
                    try:
                        from app import CineBrainTMDBService
                        content_type = content_info.get('content_type', 'movie')
                        tmdb_data = CineBrainTMDBService.get_content_details(
                            content_info['tmdb_id'], 
                            content_type
                        )
                        if tmdb_data:
                            content_exists = content_service.save_content_from_tmdb(tmdb_data, content_type)
                            if content_exists:
                                content_id = content_exists.id  # FIX: Use the actual generated ID
                                logger.info(f"Created content from TMDB with new ID {content_id}")
                    except Exception as e:
                        logger.warning(f"Failed to fetch from TMDB: {e}")
                
                # If TMDB fetch failed, create minimal record
                if not content_exists:
                    # FIX: Don't force the original ID, let it auto-generate
                    content_exists = create_minimal_content_record(None, content_info)
                    if content_exists:
                        content_id = content_exists.id  # FIX: Use the actual generated ID
                        logger.info(f"Created minimal content record with new ID {content_id}")
            
            if not content_exists:
                logger.error(f"Failed to create content record")
                return jsonify({
                    'error': 'Content not available',
                    'message': 'Unable to add this content to favorites at this time'
                }), 400
        
        # Check if already in favorites (with actual content ID)
        existing = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=content_id,  # FIX: Use actual content_id
            interaction_type='favorite'
        ).first()
        
        if existing:
            if rating:
                existing.rating = rating
                db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Already in CineBrain favorites',
                'content_id': content_id,  # FIX: Return actual content_id
                'actual_content_id': content_id
            }), 200
        
        # Add to favorites
        interaction = UserInteraction(
            user_id=current_user.id,
            content_id=content_id,  # FIX: Use actual content_id
            interaction_type='favorite',
            rating=rating
        )
        
        db.session.add(interaction)
        db.session.commit()
        
        # Update recommendation engine with actual content ID
        if recommendation_engine:
            try:
                if hasattr(recommendation_engine, 'update_user_preferences_realtime'):
                    recommendation_engine.update_user_preferences_realtime(
                        current_user.id,
                        {
                            'content_id': content_id,  # FIX: Use actual content_id
                            'interaction_type': 'favorite',
                            'rating': rating
                        }
                    )
                elif hasattr(recommendation_engine, 'update_user_profile'):
                    recommendation_engine.update_user_profile(
                        current_user.id,
                        {
                            'content_id': content_id,  # FIX: Use actual content_id
                            'interaction_type': 'favorite',
                            'rating': rating
                        }
                    )
            except Exception as e:
                logger.warning(f"Failed to update CineBrain recommendations: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Added to CineBrain favorites',
            'content_id': content_id,  # FIX: Return actual content_id
            'actual_content_id': content_id
        }), 201
        
    except Exception as e:
        logger.error(f"Add to CineBrain favorites error: {e}")
        from .utils import db
        if db:
            db.session.rollback()
        return jsonify({'error': 'Failed to add to CineBrain favorites'}), 500

def remove_from_favorites(current_user, content_id):
    """Remove content from favorites"""
    try:
        from .utils import db, UserInteraction, Content, recommendation_engine
        
        # FIX: Use helper function for ID mapping
        try:
            if isinstance(content_id, str):
                # Handle string IDs that might contain non-numeric characters
                if content_id.startswith(('tmdb_', 'mal_', 'imdb_')):
                    return jsonify({
                        'success': False,
                        'error': 'Invalid content ID format for removal',
                        'message': 'Cannot remove content with external ID format'
                    }), 400
                content_id = int(content_id)
            else:
                content_id = int(content_id)
        except (ValueError, TypeError):
            return jsonify({
                'success': False,
                'error': 'Invalid content ID format',
                'message': 'Content ID must be a valid integer'
            }), 400
        
        # FIX: Use helper function to get actual content ID
        actual_content_id = get_actual_content_id(content_id)
        
        if not actual_content_id:
            logger.warning(f"CineBrain: No content found for ID {content_id}")
            return jsonify({
                'success': False,
                'message': 'Content not found in CineBrain database',
                'details': f'No content record found for ID {content_id}'
            }), 404
        
        # Try to find the favorite interaction
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=actual_content_id,
            interaction_type='favorite'
        ).first()
        
        if interaction:
            db.session.delete(interaction)
            db.session.commit()
            
            if recommendation_engine:
                try:
                    if hasattr(recommendation_engine, 'update_user_preferences_realtime'):
                        recommendation_engine.update_user_preferences_realtime(
                            current_user.id,
                            {
                                'content_id': actual_content_id,  # Use mapped ID
                                'interaction_type': 'remove_favorite'
                            }
                        )
                    elif hasattr(recommendation_engine, 'update_user_profile'):
                        recommendation_engine.update_user_profile(
                            current_user.id,
                            {
                                'content_id': actual_content_id,  # Use mapped ID
                                'interaction_type': 'remove_favorite'
                            }
                        )
                except Exception as e:
                    logger.warning(f"Failed to update CineBrain recommendations: {e}")
            
            return jsonify({
                'success': True,
                'message': 'Removed from CineBrain favorites',
                'actual_content_id': actual_content_id  # Return the actual ID used
            }), 200
        else:
            # Better error response for missing content
            logger.warning(f"CineBrain: No favorite found for content ID {content_id} (mapped to {actual_content_id})")
            return jsonify({
                'success': False,
                'message': 'Content not in CineBrain favorites',
                'details': f'No favorite record found for content ID {content_id}',
                'searched_id': actual_content_id
            }), 404
            
    except Exception as e:
        logger.error(f"Remove from CineBrain favorites error: {e}")
        from .utils import db
        if db:
            db.session.rollback()
        return jsonify({'error': 'Failed to remove from CineBrain favorites'}), 500

def check_favorite_status(current_user, content_id):
    """Check if content is in favorites"""
    try:
        from .utils import UserInteraction
        
        # FIX: Use helper function for ID mapping
        actual_content_id = get_actual_content_id(content_id)
        
        if not actual_content_id:
            return jsonify({
                'in_favorites': False,
                'favorited_at': None,
                'user_rating': None,
                'error': 'Content not found'
            }), 200
        
        interaction = UserInteraction.query.filter_by(
            user_id=current_user.id,
            content_id=actual_content_id,
            interaction_type='favorite'
        ).first()
        
        return jsonify({
            'in_favorites': interaction is not None,
            'favorited_at': interaction.timestamp.isoformat() if interaction else None,
            'user_rating': interaction.rating if interaction else None,
            'actual_content_id': actual_content_id
        }), 200
        
    except Exception as e:
        logger.error(f"Check CineBrain favorite status error: {e}")
        return jsonify({'error': 'Failed to check CineBrain favorite status'}), 500




6. # user/profile.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from .utils import (
    require_auth, db, User, UserInteraction, Content, 
    get_enhanced_user_stats, recommendation_engine,
    get_cinematic_dna_summary, profile_analyzer, personalized_recommendation_engine
)

logger = logging.getLogger(__name__)

@require_auth
def get_user_profile(current_user):
    """Get comprehensive user profile"""
    try:
        stats = get_enhanced_user_stats(current_user.id)
        
        # Get Cinematic DNA summary if available
        cinematic_dna_summary = get_cinematic_dna_summary(current_user.id)
        
        recent_interactions = []
        if UserInteraction:
            try:
                recent = UserInteraction.query.filter_by(
                    user_id=current_user.id
                ).order_by(UserInteraction.timestamp.desc()).limit(10).all()
                
                for interaction in recent:
                    content = Content.query.get(interaction.content_id) if Content else None
                    recent_interactions.append({
                        'id': interaction.id,
                        'interaction_type': interaction.interaction_type,
                        'timestamp': interaction.timestamp.isoformat(),
                        'rating': interaction.rating,
                        'content': {
                            'id': content.id,
                            'title': content.title,
                            'content_type': content.content_type,
                            'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path,
                            'slug': content.slug
                        } if content else None
                    })
            except Exception as e:
                logger.warning(f"Could not get CineBrain recent activity: {e}")
        
        # Get recommendation effectiveness with new system priority
        rec_effectiveness = {}
        try:
            if personalized_recommendation_engine:
                rec_effectiveness = personalized_recommendation_engine.get_user_recommendation_metrics(current_user.id)
            elif recommendation_engine:
                rec_effectiveness = recommendation_engine.get_user_recommendation_metrics(current_user.id)
        except Exception as e:
            logger.warning(f"Could not get CineBrain recommendation effectiveness: {e}")
        
        profile_fields = {
            'preferred_languages': current_user.preferred_languages,
            'preferred_genres': current_user.preferred_genres,
            'location': current_user.location,
            'avatar_url': current_user.avatar_url
        }
        
        completed_fields = [field for field, value in profile_fields.items() if value]
        completion_score = min(100, len(completed_fields) * 25)
        missing_fields = [field for field, value in profile_fields.items() if not value]
        
        profile_data = {
            'user': {
                'id': current_user.id,
                'username': current_user.username,
                'email': current_user.email,
                'is_admin': current_user.is_admin,
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location,
                'avatar_url': current_user.avatar_url,
                'created_at': current_user.created_at.isoformat(),
                'last_active': current_user.last_active.isoformat() if current_user.last_active else None
            },
            'stats': stats,
            'cinematic_dna': cinematic_dna_summary,
            'recent_activity': recent_interactions,
            'recommendation_effectiveness': rec_effectiveness,
            'profile_completion': {
                'score': completion_score,
                'missing_fields': missing_fields,
                'suggestions': [
                    'Add preferred languages to unlock Telugu-first recommendations',
                    'Select favorite genres to improve CineBrain content discovery',
                    'Add your location for regional CineBrain content suggestions',
                    'Upload an avatar to personalize your CineBrain profile'
                ][:len(missing_fields)]
            },
            'advanced_features': {
                'cinematic_dna_available': bool(cinematic_dna_summary),
                'behavioral_analysis_active': bool(profile_analyzer),
                'real_time_learning': bool(personalized_recommendation_engine),
                'telugu_priority_enabled': True
            }
        }
        
        return jsonify(profile_data), 200
        
    except Exception as e:
        logger.error(f"CineBrain profile error: {e}")
        return jsonify({'error': 'Failed to get CineBrain user profile'}), 500

@require_auth
def update_user_profile(current_user):
    """Update user profile"""
    try:
        data = request.get_json()
        
        updated_fields = []
        
        if 'preferred_languages' in data:
            current_user.preferred_languages = json.dumps(data['preferred_languages'])
            updated_fields.append('preferred_languages')
        
        if 'preferred_genres' in data:
            current_user.preferred_genres = json.dumps(data['preferred_genres'])
            updated_fields.append('preferred_genres')
        
        if 'location' in data:
            current_user.location = data['location']
            updated_fields.append('location')
        
        if 'avatar_url' in data:
            current_user.avatar_url = data['avatar_url']
            updated_fields.append('avatar_url')
        
        db.session.commit()
        
        if recommendation_engine and updated_fields:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'interaction_type': 'profile_update',
                        'metadata': {
                            'updated_fields': updated_fields,
                            'data': data
                        }
                    }
                )
                logger.info(f"Updated CineBrain recommendation engine for user {current_user.id}")
            except Exception as e:
                logger.warning(f"Failed to update CineBrain recommendation engine: {e}")
        
        return jsonify({
            'success': True,
            'message': f'CineBrain profile updated successfully. Updated: {", ".join(updated_fields)}',
            'updated_fields': updated_fields,
            'user': {
                'id': current_user.id,
                'username': current_user.username,
                'email': current_user.email,
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location,
                'avatar_url': current_user.avatar_url
            }
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain profile update error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update CineBrain profile'}), 500

def get_public_profile(username):
    """Get public profile for a username"""
    try:
        user = User.query.filter_by(username=username).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        return jsonify({
            'user': {
                'id': user.id,
                'username': user.username,
                'avatar_url': user.avatar_url,
                'created_at': user.created_at.isoformat(),
                'last_active': user.last_active.isoformat() if user.last_active else None
            }
        }), 200
    except Exception as e:
        logger.error(f"Error getting public profile: {e}")
        return jsonify({'error': 'Failed to get profile'}), 500

@require_auth
def update_user_preferences(current_user):
    """Update user preferences for personalization"""
    try:
        data = request.get_json()
        
        if 'preferred_languages' in data:
            current_user.preferred_languages = json.dumps(data['preferred_languages'])
        
        if 'preferred_genres' in data:
            current_user.preferred_genres = json.dumps(data['preferred_genres'])
        
        db.session.commit()
        
        # Update both recommendation engines if available
        update_results = []
        
        if personalized_recommendation_engine:
            try:
                # Use new real-time update method
                success = profile_analyzer.update_profile_realtime(
                    current_user.id,
                    {
                        'interaction_type': 'preference_update',
                        'metadata': {
                            'updated_languages': data.get('preferred_languages'),
                            'updated_genres': data.get('preferred_genres'),
                            'source': 'explicit_preference_update'
                        }
                    }
                )
                if success:
                    update_results.append('advanced_personalization')
                logger.info(f"Successfully updated CineBrain advanced preferences for user {current_user.id}")
            except Exception as e:
                logger.warning(f"Failed to update CineBrain advanced preferences: {e}")
        
        if recommendation_engine and recommendation_engine != personalized_recommendation_engine:
            try:
                recommendation_engine.update_user_preferences_realtime(
                    current_user.id,
                    {
                        'interaction_type': 'preference_update',
                        'metadata': {
                            'updated_languages': data.get('preferred_languages'),
                            'updated_genres': data.get('preferred_genres'),
                            'source': 'explicit_preference_update'
                        }
                    }
                )
                update_results.append('legacy_personalization')
            except Exception as e:
                logger.warning(f"Failed to update CineBrain legacy preferences: {e}")
        
        return jsonify({
            'success': True,
            'message': 'CineBrain preferences updated successfully',
            'user': {
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]')
            },
            'recommendation_refresh': 'triggered',
            'systems_updated': update_results
        }), 200
        
    except Exception as e:
        logger.error(f"Update CineBrain preferences error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update CineBrain preferences'}), 500



7. # user/routes.py
from flask import Blueprint, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
import json
import logging
import jwt
from sqlalchemy import or_

from .utils import init_user_module, add_cors_headers
from . import avatar
from . import profile
from . import watchlist
from . import favorites
from . import activity
from . import dashboard
from . import settings

# Create the user blueprint
user_bp = Blueprint('user', __name__)

logger = logging.getLogger(__name__)

# Global variables (will be set by init function)
db = None
User = None
app = None

def init_user_routes(flask_app, database, models, services):
    """Initialize the user routes with dependencies"""
    global db, User, app
    
    app = flask_app
    db = database
    User = models['User']
    
    # Initialize the user module
    init_user_module(flask_app, database, models, services)
    
    logger.info(" CineBrain user routes initialized successfully")

# ============================================================================
# AUTHENTICATION ROUTES
# ============================================================================

@user_bp.route('/api/register', methods=['POST', 'OPTIONS'])
def register():
    """User registration with welcome email"""
    if request.method == 'OPTIONS':
        return '', 200
    
    try:
        data = request.get_json()
        
        if not data.get('username') or not data.get('email') or not data.get('password'):
            return jsonify({'error': 'Missing required fields for CineBrain account'}), 400
        
        if User.query.filter_by(username=data['username']).first():
            return jsonify({'error': 'CineBrain username already exists'}), 400
        
        if User.query.filter_by(email=data['email']).first():
            return jsonify({'error': 'CineBrain email already exists'}), 400
        
        user = User(
            username=data['username'],
            email=data['email'],
            password_hash=generate_password_hash(data['password']),
            preferred_languages=json.dumps(data.get('preferred_languages', ['Telugu', 'English'])),
            preferred_genres=json.dumps(data.get('preferred_genres', [])),
            location=data.get('location', ''),
            avatar_url=data.get('avatar_url', '')
        )
        
        db.session.add(user)
        db.session.commit()
        
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(days=30)
        }, app.secret_key, algorithm='HS256')
        
        # Send welcome email
        welcome_email_sent = False
        try:
            from auth.user_mail_templates import get_professional_template
            from auth.service import email_service
            
            if email_service and email_service.email_enabled:
                # Prepare user languages for email
                user_languages = json.loads(user.preferred_languages or '["Telugu", "English"]')
                
                html_content, text_content = get_professional_template(
                    'registration',
                    user_name=user.username,
                    user_email=user.email,
                    preferred_languages=user_languages
                )
                
                email_service.queue_email(
                    to=user.email,
                    subject="Welcome to CineBrain! ",
                    html=html_content,
                    text=text_content,
                    priority='normal',
                    to_name=user.username
                )
                
                welcome_email_sent = True
                logger.info(f" Welcome email queued for user {user.username} ({user.email})")
            else:
                logger.warning(" Email service not available for welcome email")
                
        except Exception as e:
            logger.error(f" Failed to send welcome email to {user.email}: {e}")
            # Don't fail registration if email fails - user experience is priority
        
        from .utils import get_enhanced_user_stats
        stats = get_enhanced_user_stats(user.id)
        
        response_data = {
            'message': 'CineBrain user registered successfully',
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_admin': user.is_admin,
                'preferred_languages': json.loads(user.preferred_languages or '[]'),
                'preferred_genres': json.loads(user.preferred_genres or '[]'),
                'location': user.location,
                'avatar_url': user.avatar_url,
                'created_at': user.created_at.isoformat(),
                'stats': stats
            },
            'welcome_email_sent': welcome_email_sent
        }
        
        return jsonify(response_data), 201
        
    except Exception as e:
        logger.error(f"CineBrain registration error: {e}")
        db.session.rollback()
        return jsonify({'error': 'CineBrain registration failed'}), 500

@user_bp.route('/api/login', methods=['POST', 'OPTIONS'])
def login():
    """User login"""
    if request.method == 'OPTIONS':
        return '', 200
    
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return jsonify({'error': 'Missing username or password'}), 400
        
        user = None
        
        if '@' in username:
            user = User.query.filter(User.email.ilike(username)).first()
        else:
            user = User.query.filter(User.username.ilike(username)).first()
        
        if not user:
            user = User.query.filter(
                or_(
                    User.username.ilike(username),
                    User.email.ilike(username)
                )
            ).first()
        
        if not user:
            return jsonify({'error': 'Invalid credentials'}), 401
        
        password_valid = check_password_hash(user.password_hash, password)
        
        if not password_valid:
            return jsonify({'error': 'Invalid credentials'}), 401
        
        user.last_active = datetime.utcnow()
        db.session.commit()
        
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(days=30)
        }, app.secret_key, algorithm='HS256')
        
        from .utils import get_enhanced_user_stats, recommendation_engine
        stats = get_enhanced_user_stats(user.id)
        
        rec_effectiveness = {}
        try:
            if recommendation_engine:
                rec_effectiveness = recommendation_engine.get_user_recommendation_metrics(user.id)
        except Exception as e:
            logger.warning(f"Could not get CineBrain recommendation effectiveness: {e}")
        
        return jsonify({
            'message': 'CineBrain login successful',
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_admin': user.is_admin,
                'preferred_languages': json.loads(user.preferred_languages or '[]'),
                'preferred_genres': json.loads(user.preferred_genres or '[]'),
                'location': user.location,
                'avatar_url': user.avatar_url,
                'last_active': user.last_active.isoformat() if user.last_active else None,
                'stats': stats,
                'recommendation_effectiveness': rec_effectiveness
            }
        }), 200
        
    except Exception as e:
        logger.error(f"CineBrain Login error: {e}")
        return jsonify({'error': 'CineBrain login failed'}), 500

# ============================================================================
# PROFILE ROUTES
# ============================================================================

@user_bp.route('/api/users/profile', methods=['GET', 'OPTIONS'])
def get_profile():
    return profile.get_user_profile()

@user_bp.route('/api/users/profile', methods=['PUT', 'OPTIONS'])
def update_profile():
    return profile.update_user_profile()

@user_bp.route('/api/users/profile/public/<username>', methods=['GET'])
def get_public_profile_route(username):
    return profile.get_public_profile(username)

@user_bp.route('/api/personalized/update-preferences', methods=['POST', 'OPTIONS'])
def update_preferences():
    return profile.update_user_preferences()

# ============================================================================
# AVATAR ROUTES
# ============================================================================

@user_bp.route('/api/users/avatar/upload', methods=['POST', 'OPTIONS'])
def upload_avatar_route():
    return avatar.upload_avatar()

@user_bp.route('/api/users/avatar/delete', methods=['DELETE', 'OPTIONS'])
def delete_avatar_route():
    return avatar.delete_avatar()

@user_bp.route('/api/users/avatar/url', methods=['GET', 'OPTIONS'])
def get_avatar_url_route():
    return avatar.get_avatar_url()

# ============================================================================
# WATCHLIST ROUTES
# ============================================================================

@user_bp.route('/api/user/watchlist', methods=['GET', 'OPTIONS'])
def get_watchlist_route():
    return watchlist.get_watchlist()

@user_bp.route('/api/user/watchlist', methods=['POST', 'OPTIONS'])
def add_to_watchlist_route():
    return watchlist.add_to_watchlist()

@user_bp.route('/api/user/watchlist/<int:content_id>', methods=['DELETE', 'OPTIONS'])
def remove_from_watchlist_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return watchlist.remove_from_watchlist(current_user, content_id)
    return wrapper()

@user_bp.route('/api/user/watchlist/<int:content_id>', methods=['GET', 'OPTIONS'])
def check_watchlist_status_route(content_id):
    from .utils import require_auth
    @require_auth
    def wrapper(current_user):
        return watchlist.check_watchlist_status(current_user, content_id)
    return wrapper()

# ============================================================================
# FAVORITES ROUTES
# ============================================================================

@user_bp.route('/api/user/favorites', methods=['GET', 'OPTIONS'])
def get_favorites_route():
    from .utils import require_auth
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        return favorites.get_favorites(current_user)
    
    return wrapper()

@user_bp.route('/api/user/favorites', methods=['POST', 'OPTIONS'])
def add_to_favorites_route():
    from .utils import require_auth
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        return favorites.add_to_favorites(current_user)
    
    return wrapper()

@user_bp.route('/api/user/favorites/<int:content_id>', methods=['DELETE', 'OPTIONS'])
def remove_from_favorites_route(content_id):
    from .utils import require_auth
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        return favorites.remove_from_favorites(current_user, content_id)
    
    return wrapper()

@user_bp.route('/api/user/favorites/<int:content_id>', methods=['GET', 'OPTIONS'])
def check_favorite_status_route(content_id):
    from .utils import require_auth
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        return favorites.check_favorite_status(current_user, content_id)
    
    return wrapper()

# ============================================================================
# RATINGS ROUTES (Delegated to Reviews Module for Compatibility)
# ============================================================================

@user_bp.route('/api/user/ratings', methods=['GET', 'OPTIONS'])
def get_user_ratings_route():
    """Get user's ratings (delegates to reviews module for compatibility)"""
    try:
        from .utils import require_auth
        
        @require_auth
        def wrapper(current_user):
            if request.method == 'OPTIONS':
                return '', 200
            
            try:
                # Delegate to reviews service for ratings
                if hasattr(app, 'review_service') and app.review_service:
                    result = app.review_service.get_user_reviews(current_user.id, include_drafts=True)
                    
                    if result['success']:
                        # Filter to only show ratings and format for compatibility
                        ratings = []
                        for review_data in result['reviews']:
                            content_data = review_data.get('content', {})
                            ratings.append({
                                'id': content_data.get('id'),
                                'slug': content_data.get('slug'),
                                'title': content_data.get('title'),
                                'content_type': content_data.get('content_type'),
                                'poster_path': content_data.get('poster_url'),
                                'user_rating': review_data.get('rating'),
                                'imdb_rating': None,  # Would need to be fetched separately
                                'rated_at': review_data.get('created_at'),
                                'has_review': bool(review_data.get('review_text', '').strip()),
                                'review_id': review_data.get('id')
                            })
                        
                        # Calculate rating stats
                        rating_values = [r['user_rating'] for r in ratings if r['user_rating'] is not None]
                        stats = {
                            'total_ratings': len(rating_values),
                            'average_rating': round(sum(rating_values) / len(rating_values), 1) if rating_values else 0,
                            'highest_rating': max(rating_values) if rating_values else 0,
                            'lowest_rating': min(rating_values) if rating_values else 0
                        }
                        
                        return jsonify({
                            'ratings': ratings,
                            'stats': stats,
                            'last_updated': datetime.utcnow().isoformat()
                        }), 200
                    else:
                        return jsonify({
                            'ratings': [],
                            'stats': {'total_ratings': 0, 'average_rating': 0, 'highest_rating': 0, 'lowest_rating': 0},
                            'last_updated': datetime.utcnow().isoformat()
                        }), 200
                else:
                    # Fallback if reviews service not available
                    from .utils import UserInteraction, Content
                    
                    rating_interactions = UserInteraction.query.filter_by(
                        user_id=current_user.id,
                        interaction_type='rating'
                    ).filter(UserInteraction.rating.isnot(None)).order_by(
                        UserInteraction.timestamp.desc()
                    ).all()
                    
                    content_ids = [interaction.content_id for interaction in rating_interactions]
                    contents = Content.query.filter(Content.id.in_(content_ids)).all()
                    content_map = {content.id: content for content in contents}
                    
                    ratings = []
                    for interaction in rating_interactions:
                        content = content_map.get(interaction.content_id)
                        if content:
                            ratings.append({
                                'id': content.id,
                                'slug': content.slug,
                                'title': content.title,
                                'content_type': content.content_type,
                                'poster_path': f"https://image.tmdb.org/t/p/w300{content.poster_path}" if content.poster_path and not content.poster_path.startswith('http') else content.poster_path,
                                'user_rating': interaction.rating,
                                'imdb_rating': content.rating,
                                'rated_at': interaction.timestamp.isoformat(),
                                'has_review': False,
                                'review_id': None
                            })
                    
                    rating_values = [interaction.rating for interaction in rating_interactions]
                    stats = {
                        'total_ratings': len(rating_values),
                        'average_rating': round(sum(rating_values) / len(rating_values), 1) if rating_values else 0,
                        'highest_rating': max(rating_values) if rating_values else 0,
                        'lowest_rating': min(rating_values) if rating_values else 0
                    }
                    
                    return jsonify({
                        'ratings': ratings,
                        'stats': stats,
                        'last_updated': datetime.utcnow().isoformat()
                    }), 200
                    
            except Exception as e:
                logger.error(f"CineBrain user ratings error: {e}")
                return jsonify({'error': 'Failed to get CineBrain user ratings'}), 500
        
        return wrapper()
        
    except Exception as e:
        logger.error(f"Error in get_user_ratings_route: {e}")
        return jsonify({'error': 'Failed to get user ratings'}), 500

@user_bp.route('/api/user/ratings', methods=['POST', 'OPTIONS'])
def add_rating_route():
    """Add or update a rating (delegates to reviews module)"""
    try:
        from .utils import require_auth
        
        @require_auth
        def wrapper(current_user):
            if request.method == 'OPTIONS':
                return '', 200
            
            try:
                data = request.get_json()
                content_id = data.get('content_id')
                rating = data.get('rating')
                
                if not content_id or rating is None:
                    return jsonify({'error': 'Content ID and rating required'}), 400
                
                if not (1 <= rating <= 10):
                    return jsonify({'error': 'Rating must be between 1 and 10'}), 400
                
                # Get content slug for reviews service
                from .utils import Content
                content = Content.query.get(content_id)
                if not content:
                    return jsonify({'error': 'Content not found'}), 404
                
                # Delegate to reviews service if available
                if hasattr(app, 'review_service') and app.review_service:
                    result = app.review_service.add_rating(content.slug, current_user.id, rating)
                    return jsonify(result), 201 if result['success'] else 400
                else:
                    # Fallback to direct UserInteraction
                    from .utils import UserInteraction
                    
                    # Check if rating already exists
                    existing = UserInteraction.query.filter_by(
                        user_id=current_user.id,
                        content_id=content_id,
                        interaction_type='rating'
                    ).first()
                    
                    if existing:
                        existing.rating = rating
                        existing.timestamp = datetime.utcnow()
                        message = 'Rating updated successfully'
                    else:
                        interaction = UserInteraction(
                            user_id=current_user.id,
                            content_id=content_id,
                            interaction_type='rating',
                            rating=rating
                        )
                        db.session.add(interaction)
                        message = 'Rating added successfully'
                    
                    db.session.commit()
                    
                    return jsonify({
                        'success': True,
                        'message': message,
                        'rating': rating
                    }), 201
                    
            except Exception as e:
                logger.error(f"CineBrain add rating error: {e}")
                db.session.rollback()
                return jsonify({'error': 'Failed to add rating'}), 500
        
        return wrapper()
        
    except Exception as e:
        logger.error(f"Error in add_rating_route: {e}")
        return jsonify({'error': 'Failed to add rating'}), 500

@user_bp.route('/api/user/ratings/<int:content_id>', methods=['DELETE', 'OPTIONS'])
def remove_rating_route(content_id):
    """Remove a rating (delegates to reviews module)"""
    try:
        from .utils import require_auth
        
        @require_auth
        def wrapper(current_user):
            if request.method == 'OPTIONS':
                return '', 200
            
            try:
                # Get content slug for reviews service
                from .utils import Content
                content = Content.query.get(content_id)
                if not content:
                    return jsonify({'error': 'Content not found'}), 404
                
                # Delegate to reviews service if available
                if hasattr(app, 'review_service') and app.review_service:
                    # First check if user has a review/rating
                    result = app.review_service.get_user_rating(content.slug, current_user.id)
                    if result['success'] and result['has_rating']:
                        # Delete the review (which includes the rating)
                        if result['review_id']:
                            delete_result = app.review_service.delete_review(result['review_id'], current_user.id)
                            return jsonify(delete_result), 200 if delete_result['success'] else 400
                    
                    return jsonify({
                        'success': False,
                        'message': 'No rating found for this content'
                    }), 404
                else:
                    # Fallback to direct UserInteraction
                    from .utils import UserInteraction
                    
                    interaction = UserInteraction.query.filter_by(
                        user_id=current_user.id,
                        content_id=content_id,
                        interaction_type='rating'
                    ).first()
                    
                    if interaction:
                        db.session.delete(interaction)
                        db.session.commit()
                        
                        return jsonify({
                            'success': True,
                            'message': 'Rating removed successfully'
                        }), 200
                    else:
                        return jsonify({
                            'success': False,
                            'message': 'No rating found for this content'
                        }), 404
                        
            except Exception as e:
                logger.error(f"Remove rating error: {e}")
                db.session.rollback()
                return jsonify({'error': 'Failed to remove rating'}), 500
        
        return wrapper()
        
    except Exception as e:
        logger.error(f"Error in remove_rating_route: {e}")
        return jsonify({'error': 'Failed to remove rating'}), 500

@user_bp.route('/api/user/ratings/<int:content_id>', methods=['GET', 'OPTIONS'])
def get_rating_for_content_route(content_id):
    """Get user's rating for specific content (delegates to reviews module)"""
    try:
        from .utils import require_auth
        
        @require_auth
        def wrapper(current_user):
            if request.method == 'OPTIONS':
                return '', 200
            
            try:
                # Get content slug for reviews service
                from .utils import Content
                content = Content.query.get(content_id)
                if not content:
                    return jsonify({'error': 'Content not found'}), 404
                
                # Delegate to reviews service if available
                if hasattr(app, 'review_service') and app.review_service:
                    result = app.review_service.get_user_rating(content.slug, current_user.id)
                    if result['success']:
                        return jsonify({
                            'has_rating': result['has_rating'],
                            'rating': result['rating'],
                            'rated_at': result['created_at']
                        }), 200
                    else:
                        return jsonify({
                            'has_rating': False,
                            'rating': None,
                            'rated_at': None
                        }), 200
                else:
                    # Fallback to direct UserInteraction
                    from .utils import UserInteraction
                    
                    interaction = UserInteraction.query.filter_by(
                        user_id=current_user.id,
                        content_id=content_id,
                        interaction_type='rating'
                    ).first()
                    
                    return jsonify({
                        'has_rating': interaction is not None,
                        'rating': interaction.rating if interaction else None,
                        'rated_at': interaction.timestamp.isoformat() if interaction else None
                    }), 200
                    
            except Exception as e:
                logger.error(f"Get rating error: {e}")
                return jsonify({'error': 'Failed to get rating'}), 500
        
        return wrapper()
        
    except Exception as e:
        logger.error(f"Error in get_rating_for_content_route: {e}")
        return jsonify({'error': 'Failed to get rating'}), 500

# ============================================================================
# ACTIVITY ROUTES
# ============================================================================

@user_bp.route('/api/interactions', methods=['POST', 'OPTIONS'])
def record_interaction_route():
    from .utils import require_auth
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        return activity.record_interaction(current_user)
    
    return wrapper()


@user_bp.route('/api/users/<username>/activity/public', methods=['GET'])
def get_public_activity_route(username):
    return activity.get_public_activity(username)

@user_bp.route('/api/users/<username>/stats/public', methods=['GET'])
def get_public_stats_route(username):
    return activity.get_public_stats(username)

# ============================================================================
# DASHBOARD ROUTES
# ============================================================================

@user_bp.route('/api/users/analytics', methods=['GET', 'OPTIONS'])
def get_analytics_route():
    return dashboard.get_user_analytics()

@user_bp.route('/api/personalized/profile-insights', methods=['GET', 'OPTIONS'])
def get_profile_insights_route():
    return dashboard.get_profile_insights()

# ============================================================================
# PERSONALIZED RECOMMENDATION ROUTES
# ============================================================================

@user_bp.route('/api/personalized/', methods=['GET', 'OPTIONS'])
def get_personalized_recommendations():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({
                    'error': 'CineBrain recommendation engine not available',
                    'recommendations': {},
                    'fallback': True
                }), 503
            
            limit = min(int(request.args.get('limit', 50)), 100)
            categories = request.args.get('categories')
            
            if categories:
                category_list = [cat.strip() for cat in categories.split(',')]
            else:
                category_list = None
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=category_list
            )
            
            recommendations['platform'] = 'cinebrain'
            recommendations['user_tier'] = 'premium'
            recommendations['personalization_level'] = 'high'
            
            return jsonify({
                'success': True,
                'data': recommendations,
                'message': 'CineBrain personalized recommendations generated successfully',
                'user': {
                    'id': current_user.id,
                    'username': current_user.username
                },
                'metadata': {
                    'generated_at': datetime.utcnow().isoformat(),
                    'algorithm_version': '3.0',
                    'personalization_strength': recommendations.get('recommendation_metadata', {}).get('confidence_score', 0.8)
                }
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain personalized recommendations error for user {current_user.id}: {e}")
            return jsonify({
                'error': 'Failed to generate CineBrain personalized recommendations',
                'success': False,
                'data': {}
            }), 500
    
    return wrapper()

@user_bp.route('/api/personalized/for-you', methods=['GET', 'OPTIONS'])
def get_for_you_recommendations():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 30)), 50)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['for_you']
            )
            
            for_you_recs = recommendations.get('recommendations', {}).get('for_you', [])
            
            return jsonify({
                'success': True,
                'recommendations': for_you_recs,
                'total_count': len(for_you_recs),
                'user_insights': recommendations.get('profile_insights', {}),
                'metadata': recommendations.get('recommendation_metadata', {}),
                'generated_at': datetime.utcnow().isoformat()
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain For You recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain For You recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/because-you-watched', methods=['GET', 'OPTIONS'])
def get_because_you_watched():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 20)), 30)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['because_you_watched']
            )
            
            because_recs = recommendations.get('recommendations', {}).get('because_you_watched', [])
            
            return jsonify({
                'success': True,
                'recommendations': because_recs,
                'total_count': len(because_recs),
                'explanation': 'Based on your recently watched CineBrain content',
                'algorithm': 'content_similarity_and_collaborative_filtering'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Because you watched recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain because you watched recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/trending-for-you', methods=['GET', 'OPTIONS'])
def get_trending_for_you():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 25)), 40)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['trending_for_you']
            )
            
            trending_recs = recommendations.get('recommendations', {}).get('trending_for_you', [])
            
            return jsonify({
                'success': True,
                'recommendations': trending_recs,
                'total_count': len(trending_recs),
                'explanation': 'Trending CineBrain content personalized for your taste',
                'algorithm': 'hybrid_trending_personalization'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Trending for you recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain trending recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/your-language', methods=['GET', 'OPTIONS'])
def get_your_language_recommendations():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 25)), 40)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['your_language']
            )
            
            language_recs = recommendations.get('recommendations', {}).get('your_language', [])
            
            preferred_languages = json.loads(current_user.preferred_languages or '[]')
            
            return jsonify({
                'success': True,
                'recommendations': language_recs,
                'total_count': len(language_recs),
                'explanation': 'CineBrain content in your preferred languages',
                'preferred_languages': preferred_languages,
                'algorithm': 'language_preference_filtering'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Language recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain language recommendations'}), 500
    
    return wrapper()

@user_bp.route('/api/personalized/hidden-gems', methods=['GET', 'OPTIONS'])
def get_hidden_gems():
    from .utils import require_auth, recommendation_engine
    
    @require_auth
    def wrapper(current_user):
        if request.method == 'OPTIONS':
            return '', 200
        
        try:
            if not recommendation_engine:
                return jsonify({'error': 'CineBrain recommendation engine not available'}), 503
            
            limit = min(int(request.args.get('limit', 15)), 25)
            
            recommendations = recommendation_engine.get_personalized_recommendations(
                user_id=current_user.id,
                limit=limit,
                categories=['hidden_gems']
            )
            
            gems_recs = recommendations.get('recommendations', {}).get('hidden_gems', [])
            
            return jsonify({
                'success': True,
                'recommendations': gems_recs,
                'total_count': len(gems_recs),
                'explanation': 'High-quality CineBrain content you might have missed',
                'algorithm': 'hidden_gem_discovery'
            }), 200
            
        except Exception as e:
            logger.error(f"CineBrain Hidden gems recommendations error: {e}")
            return jsonify({'error': 'Failed to get CineBrain hidden gems recommendations'}), 500
    
    return wrapper()

# ============================================================================
# SETTINGS ROUTES
# ============================================================================

@user_bp.route('/api/users/settings', methods=['GET', 'OPTIONS'])
def get_settings_route():
    return settings.get_user_settings()

@user_bp.route('/api/users/settings/account', methods=['PUT', 'OPTIONS'])
def update_account_settings_route():
    return settings.update_account_settings()

@user_bp.route('/api/users/settings/password', methods=['PUT', 'OPTIONS'])
def change_password_route():
    return settings.change_password()

@user_bp.route('/api/users/settings/delete-account', methods=['DELETE', 'OPTIONS'])
def delete_account_route():
    return settings.delete_account()

@user_bp.route('/api/users/settings/export-data', methods=['GET', 'OPTIONS'])
def export_data_route():
    return settings.export_user_data()

# ============================================================================
# HEALTH ROUTE
# ============================================================================

@user_bp.route('/api/users/health', methods=['GET'])
def users_health():
    try:
        health_info = {
            'status': 'healthy',
            'service': 'cinebrain_users',
            'timestamp': datetime.utcnow().isoformat(),
            'version': '3.1.0'
        }
        
        try:
            User.query.limit(1).first()
            health_info['database'] = 'connected'
        except Exception as e:
            health_info['database'] = f'error: {str(e)}'
            health_info['status'] = 'degraded'
        
        from .utils import recommendation_engine
        health_info['recommendation_engine'] = 'connected' if recommendation_engine else 'not_available'
        
        # Check reviews service integration
        health_info['reviews_integration'] = 'connected' if hasattr(app, 'review_service') and app.review_service else 'not_available'
        
        # Check email service status
        try:
            from auth.service import email_service
            health_info['email_service'] = {
                'enabled': email_service.email_enabled if email_service else False,
                'smtp_enabled': email_service.smtp_enabled if email_service else False,
                'api_enabled': email_service.api_enabled if email_service else False
            }
        except:
            health_info['email_service'] = {'enabled': False}
        
        try:
            total_users = User.query.count()
            active_users = User.query.filter(
                User.last_active >= datetime.utcnow() - timedelta(days=7)
            ).count()
            users_with_avatars = User.query.filter(User.avatar_url.isnot(None)).count()
            
            health_info['user_metrics'] = {
                'total_users': total_users,
                'active_users_7d': active_users,
                'users_with_avatars': users_with_avatars,
                'activity_rate': round((active_users / total_users * 100), 1) if total_users > 0 else 0,
                'avatar_adoption_rate': round((users_with_avatars / total_users * 100), 1) if total_users > 0 else 0
            }
        except Exception as e:
            health_info['user_metrics'] = {'error': str(e)}
        
        health_info['features'] = {
            'personalized_recommendations': True,
            'user_analytics': True,
            'profile_management': True,
            'watchlist_favorites': True,
            'real_time_updates': True,
            'email_username_login': True,
            'avatar_service': True,
            'modular_architecture': True,
            'welcome_emails': True,
            'reviews_integration': hasattr(app, 'review_service') and bool(app.review_service),
            'ratings_delegation': True
        }
        
        return jsonify(health_info), 200
        
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'service': 'cinebrain_users',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

# Add CORS headers to all responses
@user_bp.after_request
def after_request(response):
    return add_cors_headers(response)

# Export the initialization function
__all__ = ['user_bp', 'init_user_routes']



8. # user/settings.py
from flask import request, jsonify
from datetime import datetime
import json
import logging
from werkzeug.security import generate_password_hash, check_password_hash
from .utils import require_auth, db

logger = logging.getLogger(__name__)

@require_auth
def get_user_settings(current_user):
    """Get user account settings"""
    try:
        settings = {
            'account': {
                'username': current_user.username,
                'email': current_user.email,
                'created_at': current_user.created_at.isoformat(),
                'last_active': current_user.last_active.isoformat() if current_user.last_active else None
            },
            'preferences': {
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location
            },
            'privacy': {
                'profile_visibility': 'public',  # This could be expanded
                'activity_visibility': 'public'
            },
            'notifications': {
                'email_recommendations': True,  # These could be database fields
                'new_release_alerts': True,
                'watchlist_updates': True
            }
        }
        
        return jsonify({
            'success': True,
            'settings': settings
        }), 200
        
    except Exception as e:
        logger.error(f"Get user settings error: {e}")
        return jsonify({'error': 'Failed to get user settings'}), 500

@require_auth
def update_account_settings(current_user):
    """Update account settings"""
    try:
        data = request.get_json()
        updated_fields = []
        
        # Update email if provided
        if 'email' in data and data['email'] != current_user.email:
            # Check if email is already taken
            from .utils import User
            existing_email = User.query.filter_by(email=data['email']).first()
            if existing_email and existing_email.id != current_user.id:
                return jsonify({'error': 'Email already in use'}), 400
            
            current_user.email = data['email']
            updated_fields.append('email')
        
        # Update username if provided
        if 'username' in data and data['username'] != current_user.username:
            # Check if username is already taken
            from .utils import User
            existing_username = User.query.filter_by(username=data['username']).first()
            if existing_username and existing_username.id != current_user.id:
                return jsonify({'error': 'Username already in use'}), 400
            
            current_user.username = data['username']
            updated_fields.append('username')
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Account settings updated: {", ".join(updated_fields)}',
            'updated_fields': updated_fields
        }), 200
        
    except Exception as e:
        logger.error(f"Update account settings error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update account settings'}), 500

@require_auth
def change_password(current_user):
    """Change user password"""
    try:
        data = request.get_json()
        
        current_password = data.get('current_password')
        new_password = data.get('new_password')
        
        if not current_password or not new_password:
            return jsonify({'error': 'Current password and new password required'}), 400
        
        # Verify current password
        if not check_password_hash(current_user.password_hash, current_password):
            return jsonify({'error': 'Current password is incorrect'}), 400
        
        # Validate new password
        if len(new_password) < 6:
            return jsonify({'error': 'New password must be at least 6 characters'}), 400
        
        # Update password
        current_user.password_hash = generate_password_hash(new_password)
        db.session.commit()
        
        logger.info(f"Password changed for user {current_user.username}")
        
        return jsonify({
            'success': True,
            'message': 'Password changed successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Change password error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to change password'}), 500

@require_auth
def delete_account(current_user):
    """Delete user account (soft delete for now)"""
    try:
        data = request.get_json()
        password = data.get('password')
        
        if not password:
            return jsonify({'error': 'Password required to delete account'}), 400
        
        # Verify password
        if not check_password_hash(current_user.password_hash, password):
            return jsonify({'error': 'Incorrect password'}), 400
        
        # For now, just mark as inactive instead of actual deletion
        # In production, you might want to anonymize data instead
        current_user.username = f"deleted_user_{current_user.id}"
        current_user.email = f"deleted_{current_user.id}@cinebrain.deleted"
        current_user.avatar_url = None
        current_user.preferred_languages = None
        current_user.preferred_genres = None
        current_user.location = None
        
        db.session.commit()
        
        logger.info(f"Account deleted for user ID {current_user.id}")
        
        return jsonify({
            'success': True,
            'message': 'Account deleted successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Delete account error: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to delete account'}), 500

@require_auth
def export_user_data(current_user):
    """Export user data"""
    try:
        from .utils import UserInteraction
        
        # Get user interactions
        interactions = UserInteraction.query.filter_by(user_id=current_user.id).all()
        
        user_data = {
            'account': {
                'username': current_user.username,
                'email': current_user.email,
                'created_at': current_user.created_at.isoformat(),
                'last_active': current_user.last_active.isoformat() if current_user.last_active else None
            },
            'preferences': {
                'preferred_languages': json.loads(current_user.preferred_languages or '[]'),
                'preferred_genres': json.loads(current_user.preferred_genres or '[]'),
                'location': current_user.location
            },
            'interactions': [
                {
                    'content_id': interaction.content_id,
                    'interaction_type': interaction.interaction_type,
                    'rating': interaction.rating,
                    'timestamp': interaction.timestamp.isoformat(),
                    'metadata': json.loads(interaction.interaction_metadata or '{}')
                }
                for interaction in interactions
            ],
            'exported_at': datetime.utcnow().isoformat()
        }
        
        return jsonify({
            'success': True,
            'data': user_data
        }), 200
        
    except Exception as e:
        logger.error(f"Export user data error: {e}")
        return jsonify({'error': 'Failed to export user data'}), 500
