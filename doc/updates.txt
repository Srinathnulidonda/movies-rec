
Endpoints
1. /recommendations/trending
   - Aggregate trending content from TMDB, OMDB, and Jikan.
   - Include movies, TV shows, and anime across all languages. Prioritize content in Telugu, English, Hindi, Tamil, Malayalam first, but include other languages as fallback.
   - Sort by a combined metric of popularity and recency (e.g., TMDB popularity_score, Jikan score, release date).
   - Remove duplicates (based on normalized title and type).
   
2. /recommendations/new-releases
   - Aggregate new releases from all APIs.
   - Include movies, TV shows, and anime.
   - **Prioritize content in Telugu, English, Hindi, Tamil, Malayalam first, but include other languages as fallback.
   - Sort by release_date descending, then by popularity.
   - Support optional type/language filters.
   
3. /recommendations/Popular-Movies
   - Aggregate top-rated content from all APIs.
   - Prioritize content in Telugu, English, Hindi, Tamil, Malayalam first, but include other languages as fallback.


Anime
‚Ä¢  Trending Anime ‚Üí /recommendations/trending?type=anime
‚Ä¢  New Anime Releases ‚Üí /recommendations/new-releases?type=anime
‚Ä¢  Top Rated Anime ‚Üí /recommendations/critics-choice?type=anime
‚Ä¢  Anime by Genre ‚Üí multiple carousels like:
‚Ä¢	Action Anime
‚Ä¢	Romance Anime
‚Ä¢	Comedy Anime
‚Ä¢	Fantasy / Isekai Anime
(API filter: /content/genre?type=anime&genre={genre})
________________________________________
üé¨ Movies
‚Ä¢	Trending Movies ‚Üí /recommendations/trending?type=movie
‚Ä¢	New Movie Releases ‚Üí /recommendations/new-releases?type=movie
‚Ä¢	Top Rated Movies ‚Üí /recommendations/critics-choice?type=movie
‚Ä¢	Movies by Genre ‚Üí multiple carousels like:
o	Action Movies ‚Üí /content/genre?type=movie&genre=Action
o	Romance Movies ‚Üí /content/genre?type=movie&genre=Romance
o	Comedy Movies ‚Üí /content/genre?type=movie&genre=Comedy
o	Thriller Movies ‚Üí /content/genre?type=movie&genre=Thriller
o	(API filter: /content/genre?type=movies &genre={genre})
________________________________________
üì∫ TV Shows
‚Ä¢	Trending TV Shows ‚Üí /recommendations/trending?type=tv
‚Ä¢	New TV Show Releases ‚Üí /recommendations/new-releases?type=tv
‚Ä¢	Top Rated TV Shows ‚Üí /recommendations/critics-choice?type=tv
‚Ä¢	TV Shows by Genre ‚Üí multiple carousels like:
o	Drama TV Shows ‚Üí /content/genre?type=tv&genre=Drama
o	Mystery TV Shows ‚Üí /content/genre?type=tv&genre=Mystery
o	Sitcoms / Comedy ‚Üí /content/genre?type=tv&genre=Comedy
o	Sci-Fi / Fantasy TV ‚Üí /content/genre?type=tv&genre=Sci-Fi
o	(API filter: /content/genre?type=tv-show&genre={genre})

The exact specifications needed for 100% accurate implementation. It includes:
Precise API endpoints and data structures
Exact scoring algorithms and formulas
Specific language prioritization logic
Detailed error handling and caching requirements
Complete duplicate removal algorithm
Performance benchmarks and validation rules
Comprehensive testing checklist



separate search from my backend/app.py and provide this in backend/search.py and implement a powerful, super-fast search system using pure Python. 
Ensure the search results are 100% accurate and instant by using:
1. N-gram analyzer for partial matching and auto-complete.
2. Fuzzy search to handle typos and misspellings.
3. Field boosting to prioritize titles, genres, and keywords.
4. Optimized queries for speed and accuracy.
5. Pagination and sorting by relevance.
6. No defaults or placeholders ‚Äì only complete realtime data should be used from the actual database.

Return the complete best version of search.py that defines search functions that can be used directly inside app.py.












You are a senior backend engineer. Implement the ‚Äúnew-releases‚Äù feature for my backend using Python. Modify backend/app.py and create backend/services/new_releases.py to provide a production-grade, region- and timezone-aware endpoint that returns the latest releases for Movies, TV/Series, and Anime, following the rules below.
Context and constraints
‚Ä¢	Language priority (strict order): ['telugu', 'english', 'hindi', 'malayalam', 'kannada', 'tamil']
‚Ä¢	Use these ISO-639-1 codes: telugu=te, english=en, hindi=hi, malayalam=ml, kannada=kn, tamil=ta
‚Ä¢	Categories:
‚Ä¢	Movies: release_date in current month, then remaining 2 months
‚Ä¢	TV/Series: first_air_date in current month, then remaining 2 months
‚Ä¢	Anime: airing_start/first_air_date in current month, then remaining 2 months
‚Ä¢	Rules:
‚Ä¢	Limit to current year only
‚Ä¢	Region-aware release dates
‚Ä¢	Sort by date (newest first), then by popularity/vote_count; then apply language priority as a tiebreaker
‚Ä¢	Refresh at least daily (prefer hourly)
‚Ä¢	Apply the language priority ordering strictly
‚Ä¢	Timezone: user‚Äôs timezone aware (use tz name, not just offset)
‚Ä¢	Region: user‚Äôs region aware (ISO 3166-1 alpha-2, e.g., IN, US)
‚Ä¢	If repository/framework detection is ambiguous, default to FastAPI, httpx (async), and Redis for caching. Write framework-agnostic core logic in services and a thin integration layer in app.py.
Data sources (default choices if not otherwise present in repo)
‚Ä¢	Movies and TV: TMDb API
‚Ä¢	Use Discover endpoints with region-aware filters
‚Ä¢	Movies: /discover/movie with params
‚Ä¢	region={REGION}, primary_release_year={YEAR}, primary_release_date.gte, primary_release_date.lte
‚Ä¢	with_release_type=2|3|4|5 (theatrical, digital, physical, TV)
‚Ä¢	TV: /discover/tv with params
‚Ä¢	first_air_date_year={YEAR}, first_air_date.gte, first_air_date.lte
‚Ä¢	watch_region={REGION} (influences availability), but expect first_air_date to be global
‚Ä¢	Use popularity and vote_count fields for secondary sorting
‚Ä¢	Anime: AniList GraphQL
‚Ä¢	Filter Media by startDate year==current year
‚Ä¢	Select TV, TV_SHORT, ONA, OVA, and MOVIE formats
‚Ä¢	Filter items whose startDate or nextAiringEpisode.airingAt date falls within each target month range (see algorithm)
‚Ä¢	Use popularity and favourites/averageScore as sorting tie-breakers











1.	In backend/services/personalized.py, build a personalized recommendation engine for movies, anime, TV shows, and series using UserActivity (watch history, completion rate, dwell time), UserPreferences (preferred_genres, preferred_languages, content_types), search history, and story similarity (plot/description embeddings).
2.	Use Neural Collaborative Filtering (90% traffic) as the primary engine, with Matrix Factorization (10% fallback), and integrate ANN retrieval + Redis for fast candidate serving.
3.	Implement story embedding similarity using transformer/NLP encoders to match user-watched plots with similar items, combining it with NCF/MF in a hybrid ranking pipeline that enforces hard filters for language & content type.
4.	Continuously improve via online learning (mini-batches), multi-armed bandit (exploring NCF, MF, story-similarity, trending), and real-time A/B testing to evolve recommendations with user behavior.
5.	Ensure recommendations are context-aware, diverse, and real-time, returning each item with scores, reasons (e.g., "story match: Inception", "pref: Action"), and experiment ID for observability.




You are a senior backend engineer: implement a production-ready file that
- the Similar Titles should be first priority that the content lanugage and the similar title should be the 100% accurate 
   and 100% perfect tiltle 
- all the logics and alogithms should be in backend/services/similar.py file so develop this with the best production-level 
  code  same goes to explore genre
- main factor is the story and the content