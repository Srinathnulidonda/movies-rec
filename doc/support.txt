1. # support/__init__.py

from .routes import support_bp, init_support_routes
from .tickets import TicketService, TicketStatus, TicketPriority, TicketType
from .contact import ContactService
from .report_issues import IssueReportService

def init_support(app, db, models, services):
    """Initialize support system with proper email service"""
    
    # Ensure email service is available
    if 'email_service' not in services:
        try:
            from auth.service import email_service as auth_email_service
            services['email_service'] = auth_email_service
            app.logger.info("‚úÖ Email service added to support services")
        except Exception as e:
            app.logger.warning(f"Could not import email service: {e}")
    
    # Initialize routes with existing models
    init_support_routes(app, db, models, services)
    
    return models

__all__ = [
    'support_bp',
    'init_support',
    'TicketService',
    'TicketStatus', 
    'TicketPriority',
    'TicketType',
    'ContactService',
    'IssueReportService'
]
__version__ = '2.0.0'



2. # support/contact.py

from flask import request, jsonify
from datetime import datetime
import logging
import re
import jwt
import os

logger = logging.getLogger(__name__)

EMAIL_REGEX = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')

class ContactService:
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.ContactMessage = models.get('ContactMessage')
        
        # Enhanced email service initialization
        self.email_service = self._initialize_email_service(services)
        self.redis_client = services.get('redis_client')
        
        # Get admin notification service if available
        self.admin_notification_service = services.get('admin_notification_service')
        
        logger.info("‚úÖ ContactService initialized successfully")
    
    def _initialize_email_service(self, services):
        """Initialize email service with fallbacks"""
        email_service = services.get('email_service')
        if email_service:
            return email_service
        
        try:
            from auth.service import email_service as auth_email_service
            if auth_email_service and hasattr(auth_email_service, 'queue_email'):
                logger.info("‚úÖ Email service loaded from auth module for contact")
                return auth_email_service
        except Exception as e:
            logger.warning(f"Could not load auth email service for contact: {e}")
        
        logger.warning("‚ö†Ô∏è No email service available for contact")
        return None
    
    def get_user_from_token(self):
        """Extract user from JWT token"""
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None
        
        token = auth_header.split(' ')[1]
        try:
            payload = jwt.decode(token, self.app.secret_key, algorithms=['HS256'])
            return self.User.query.get(payload.get('user_id'))
        except:
            return None
    
    def get_request_info(self):
        """Extract request information"""
        ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ip_address:
            ip_address = ip_address.split(',')[0].strip()
        
        return {
            'ip_address': ip_address,
            'user_agent': request.headers.get('User-Agent', 'Unknown'),
            'page_url': request.headers.get('Referer', '')
        }
    
    def submit_contact(self):
        """Handle contact form submission with enhanced notifications - FIXED"""
        try:
            data = request.get_json()
            
            # Validate required fields
            required_fields = ['name', 'email', 'subject', 'message']
            for field in required_fields:
                if not data.get(field):
                    return jsonify({'error': f'{field.replace("_", " ").title()} is required'}), 400
            
            # Validate email format
            if not EMAIL_REGEX.match(data['email']):
                return jsonify({'error': 'Please provide a valid email address'}), 400
            
            # Rate limiting
            if not self._check_rate_limit(data['email']):
                return jsonify({'error': 'Too many contact form submissions. Please try again in 15 minutes.'}), 429
            
            user = self.get_user_from_token()
            request_info = self.get_request_info()
            
            # Create contact message record
            contact_message = self.ContactMessage(
                name=data['name'],
                email=data['email'],
                subject=data['subject'],
                message=data['message'],
                user_id=user.id if user else None,
                phone=data.get('phone'),
                company=data.get('company'),
                **request_info
            )
            
            self.db.session.add(contact_message)
            self.db.session.commit()
            
            # Send notifications
            self._send_user_confirmation(data)
            self._send_admin_notification_enhanced(contact_message, data)
            
            logger.info(f"‚úÖ Contact form submitted by {data['email']}")
            
            return jsonify({
                'success': True,
                'message': 'Thank you for your message! We will get back to you soon.',
                'contact_id': contact_message.id
            }), 201
            
        except Exception as e:
            self.db.session.rollback()
            logger.error(f"‚ùå Error processing contact form: {e}")
            return jsonify({'error': 'Failed to send your message. Please try again.'}), 500
    
    def _check_rate_limit(self, email: str) -> bool:
        """Check rate limit for contact form"""
        if not self.redis_client:
            return True
        
        try:
            key = f"contact_rate_limit:{email}"
            current = self.redis_client.get(key)
            
            if current is None:
                self.redis_client.setex(key, 900, 1)  # 15 minutes
                return True
            
            if int(current) >= 5:  # Max 5 messages per 15 minutes
                return False
            
            self.redis_client.incr(key)
            return True
            
        except Exception as e:
            logger.error(f"Rate limit check error: {e}")
            return True
    
    def _send_user_confirmation(self, data):
        """Send confirmation email to user"""
        try:
            if not self.email_service:
                logger.warning("Email service not available - cannot send user confirmation")
                return
            
            from auth.support_mail_templates import get_support_template
            
            html, text = get_support_template(
                'contact_received',
                user_name=data['name'],
                subject=data['subject']
            )
            
            self.email_service.queue_email(
                to=data['email'],
                subject="Message Received - CineBrain Support",
                html=html,
                text=text,
                priority='normal',
                to_name=data['name']
            )
            
            logger.info(f"‚úÖ Contact confirmation email queued for {data['email']}")
            
        except Exception as e:
            logger.error(f"‚ùå Error sending contact confirmation: {e}")
    
    def _send_admin_notification(self, contact_message, data):
        """Send admin notification email - DEPRECATED, use enhanced version"""
        self._send_admin_notification_enhanced(contact_message, data)
    
    def _send_admin_notification_enhanced(self, contact_message, data):
        """Send enhanced admin notification email - FIXED"""
        try:
            # Check if the message is from a potential partner/business inquiry
            is_business_inquiry = any([
                data.get('company'),
                'partnership' in data.get('subject', '').lower(),
                'business' in data.get('subject', '').lower(),
                'collaborate' in data.get('message', '').lower()
            ])
            
            # Try using admin notification service first for general feedback
            if self.admin_notification_service and hasattr(self.admin_notification_service, 'notify_feedback_received'):
                try:
                    # Create a feedback-like object for the notification service
                    class ContactAsFeedback:
                        def __init__(self, contact, data):
                            self.id = contact.id
                            self.user_name = data['name']
                            self.user_email = data['email']
                            self.subject = data['subject']
                            self.feedback_type = 'business_inquiry' if is_business_inquiry else 'contact'
                            self.rating = None
                    
                    feedback_obj = ContactAsFeedback(contact_message, data)
                    self.admin_notification_service.notify_feedback_received(feedback_obj)
                    logger.info(f"‚úÖ Admin notification sent via notification service for contact from {data['email']}")
                except Exception as e:
                    logger.warning(f"Admin notification service failed, using direct email: {e}")
            
            # Always send direct email for contact forms (in addition to notification service)
            if not self.email_service:
                logger.warning("Email service not available - cannot send admin notification")
                return
            
            # Get admin email(s)
            admin_emails = []
            
            # Add environment admin email
            env_admin_email = os.environ.get('ADMIN_EMAIL', 'srinathnulidonda.dev@gmail.com')
            if env_admin_email:
                admin_emails.append(env_admin_email)
            
            # Add database admin emails
            admin_users = self.User.query.filter_by(is_admin=True).all()
            for admin_user in admin_users:
                if admin_user.email and admin_user.email not in admin_emails:
                    admin_emails.append(admin_user.email)
            
            if not admin_emails:
                logger.warning("No admin emails configured for notifications")
                return
            
            admin_link = f"{os.environ.get('FRONTEND_URL', 'https://cinebrain.vercel.app')}/admin/support/contact/{contact_message.id}"
            
            from auth.support_mail_templates import get_support_template
            
            # Determine priority based on content
            priority = 'urgent' if is_business_inquiry else 'high'
            
            html, text = get_support_template(
                'admin_notification',
                notification_type='contact',
                title=f"{'ü§ù Business Inquiry' if is_business_inquiry else 'üìß New Contact'}: {data['subject']}",
                message=f"""
                <p><strong>{'Business inquiry' if is_business_inquiry else 'New contact message'} received:</strong></p>
                <ul>
                    <li><strong>From:</strong> {data['name']} ({data['email']})</li>
                    <li><strong>Subject:</strong> {data['subject']}</li>
                    {f"<li><strong>Phone:</strong> {data.get('phone')}</li>" if data.get('phone') else ''}
                    {f"<li><strong>Company:</strong> {data.get('company')}</li>" if data.get('company') else ''}
                    <li><strong>IP Address:</strong> {contact_message.ip_address}</li>
                    <li><strong>User Agent:</strong> {contact_message.user_agent}</li>
                    <li><strong>Submitted:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}</li>
                </ul>
                <p><strong>Message:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid {'#10b981' if is_business_inquiry else '#28a745'}; margin: 15px 0;">
                    {data['message'].replace(chr(10), '<br>')}
                </div>
                <p style="margin-top: 20px;">
                    <a href="{admin_link}" style="background: #113CCF; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block;">
                        View in Admin Dashboard
                    </a>
                </p>
                """,
                user_email=data['email']
            )
            
            # Send to all admin emails
            for admin_email in admin_emails:
                try:
                    self.email_service.queue_email(
                        to=admin_email,
                        subject=f"{'ü§ù' if is_business_inquiry else 'üìß'} New Contact: {data['subject']} - CineBrain Admin",
                        html=html,
                        text=text,
                        priority=priority,
                        to_name='CineBrain Admin'
                    )
                    logger.info(f"‚úÖ Admin notification email queued for {admin_email}")
                except Exception as e:
                    logger.error(f"Failed to queue email for admin {admin_email}: {e}")
            
            logger.info(f"‚úÖ Admin notifications sent for contact from {data['email']}")
            
        except Exception as e:
            logger.error(f"‚ùå Error sending admin notification: {e}")

def init_contact_service(app, db, models, services):
    """Initialize contact service"""
    return ContactService(app, db, models, services)



3. # support/report_issues.py

from flask import request, jsonify
from datetime import datetime
import logging
import re
import jwt
import os
import uuid
import cloudinary
import cloudinary.uploader
from werkzeug.utils import secure_filename

logger = logging.getLogger(__name__)

EMAIL_REGEX = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')

# Configure Cloudinary
cloudinary.config(
    cloud_name=os.environ.get('CLOUDINARY_CLOUD_NAME'),
    api_key=os.environ.get('CLOUDINARY_API_KEY'),
    api_secret=os.environ.get('CLOUDINARY_API_SECRET'),
    secure=True
)

class IssueReportService:
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.IssueReport = models.get('IssueReport')
        self.SupportTicket = models['SupportTicket']
        self.SupportCategory = models['SupportCategory']
        self.TicketActivity = models['TicketActivity']
        
        # Enhanced email service initialization
        self.email_service = self._initialize_email_service(services)
        self.redis_client = services.get('redis_client')
        
        # Cloudinary settings
        self.cloudinary_folder = "report_issues"
        self.max_file_size = 10 * 1024 * 1024  # 10MB
        self.allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'pdf'}
        
        logger.info("‚úÖ IssueReportService initialized successfully")
    
    def _initialize_email_service(self, services):
        """Initialize email service with fallbacks"""
        email_service = services.get('email_service')
        if email_service:
            return email_service
        
        try:
            from auth.service import email_service as auth_email_service
            if auth_email_service and hasattr(auth_email_service, 'queue_email'):
                logger.info("‚úÖ Email service loaded from auth module for issues")
                return auth_email_service
        except Exception as e:
            logger.warning(f"Could not load auth email service for issues: {e}")
        
        logger.warning("‚ö†Ô∏è No email service available for issues")
        return None
    
    def get_user_from_token(self):
        """Extract user from JWT token"""
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None
        
        token = auth_header.split(' ')[1]
        try:
            payload = jwt.decode(token, self.app.secret_key, algorithms=['HS256'])
            return self.User.query.get(payload.get('user_id'))
        except:
            return None
    
    def get_request_info(self):
        """Extract request information"""
        ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ip_address:
            ip_address = ip_address.split(',')[0].strip()
        
        return {
            'ip_address': ip_address,
            'user_agent': request.headers.get('User-Agent', 'Unknown'),
            'page_url': request.headers.get('Referer', '')
        }
    
    def _allowed_file(self, filename):
        """Check if file extension is allowed"""
        return '.' in filename and \
               filename.rsplit('.', 1)[1].lower() in self.allowed_extensions
    
    def _upload_to_cloudinary(self, file, issue_id):
        """Upload file to Cloudinary"""
        try:
            if not file or file.filename == '':
                return None
            
            if not self._allowed_file(file.filename):
                raise ValueError(f"File type not allowed. Allowed types: {', '.join(self.allowed_extensions)}")
            
            # Check file size
            file.seek(0, os.SEEK_END)
            file_size = file.tell()
            file.seek(0)
            
            if file_size > self.max_file_size:
                raise ValueError("File size exceeds 10MB limit")
            
            # Generate unique filename
            filename = secure_filename(file.filename)
            unique_filename = f"{issue_id}_{uuid.uuid4().hex[:8]}_{filename}"
            
            # Upload to Cloudinary
            upload_result = cloudinary.uploader.upload(
                file,
                folder=self.cloudinary_folder,
                public_id=unique_filename,
                resource_type="auto",
                overwrite=False,
                transformation=[
                    {'quality': "auto:good"},
                    {'fetch_format': "auto"}
                ]
            )
            
            return {
                'url': upload_result['secure_url'],
                'public_id': upload_result['public_id'],
                'format': upload_result.get('format'),
                'width': upload_result.get('width'),
                'height': upload_result.get('height'),
                'bytes': upload_result.get('bytes'),
                'original_filename': filename
            }
            
        except Exception as e:
            logger.error(f"Cloudinary upload error: {e}")
            raise e
    
    def report_issue(self):
        """Handle issue report submission with enhanced processing"""
        try:
            # Handle form data (multipart/form-data for file uploads)
            data = {}
            data['name'] = request.form.get('name', '').strip()
            data['email'] = request.form.get('email', '').strip()
            data['issue_type'] = request.form.get('issue_type', 'bug_error')
            data['severity'] = request.form.get('severity', 'normal')
            data['issue_title'] = request.form.get('issue_title', '').strip()
            data['description'] = request.form.get('description', '').strip()
            data['browser_version'] = request.form.get('browser_version', '').strip()
            data['device_os'] = request.form.get('device_os', '').strip()
            data['page_url'] = request.form.get('page_url', '').strip()
            data['steps_to_reproduce'] = request.form.get('steps_to_reproduce', '').strip()
            data['expected_behavior'] = request.form.get('expected_behavior', '').strip()
            
            # Validate required fields
            required_fields = ['email', 'issue_title', 'description']
            for field in required_fields:
                if not data.get(field):
                    return jsonify({'error': f'{field.replace("_", " ").title()} is required'}), 400
            
            # Use email as name if name is not provided
            if not data['name']:
                data['name'] = data['email'].split('@')[0].replace('.', ' ').title()
            
            # Validate email format
            if not EMAIL_REGEX.match(data['email']):
                return jsonify({'error': 'Please provide a valid email address'}), 400
            
            # Rate limiting
            if not self._check_rate_limit(data['email']):
                return jsonify({'error': 'Too many issue reports. Please try again in 15 minutes.'}), 429
            
            user = self.get_user_from_token()
            request_info = self.get_request_info()
            
            # Generate unique issue ID
            issue_id = f"issue_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
            
            # Handle file uploads
            uploaded_files = []
            files = request.files.getlist('screenshots')
            
            if files and len(files) > 0:
                for file in files[:5]:  # Limit to 5 files
                    if file and file.filename:
                        try:
                            file_info = self._upload_to_cloudinary(file, issue_id)
                            if file_info:
                                uploaded_files.append(file_info)
                        except Exception as e:
                            logger.warning(f"File upload failed: {e}")
                            continue
            
            # Get or create Technical Issues category
            tech_category = self.SupportCategory.query.filter_by(name='Technical Issues').first()
            if not tech_category:
                tech_category = self.SupportCategory.query.first()
            
            # Create issue report record
            issue_report = self.IssueReport(
                issue_id=issue_id,
                name=data['name'],
                email=data['email'],
                issue_type=data['issue_type'],
                severity=data['severity'],
                issue_title=data['issue_title'],
                description=data['description'],
                browser_version=data['browser_version'],
                device_os=data['device_os'],
                page_url_reported=data['page_url'],
                steps_to_reproduce=data['steps_to_reproduce'],
                expected_behavior=data['expected_behavior'],
                screenshots=uploaded_files,
                user_id=user.id if user else None,
                **request_info
            )
            
            self.db.session.add(issue_report)
            self.db.session.flush()
            
            # Create corresponding support ticket
            ticket_number = self._generate_ticket_number()
            
            # Map severity to priority
            priority_mapping = {
                'low': 'low',
                'normal': 'normal', 
                'high': 'high',
                'critical': 'urgent'
            }
            
            priority = priority_mapping.get(data['severity'], 'normal')
            
            # Create detailed description for ticket
            detailed_description = f"""
ISSUE REPORT DETAILS:

üêõ Issue Type: {data['issue_type'].replace('_', ' ').title()}
‚ö° Severity: {data['severity'].title()}

üìù Description:
{data['description']}

üîÑ Steps to Reproduce:
{data['steps_to_reproduce'] or 'Not provided'}

‚úÖ Expected Behavior:
{data['expected_behavior'] or 'Not provided'}

üåê Technical Details:
‚Ä¢ Browser: {data['browser_version'] or 'Not provided'}
‚Ä¢ Device/OS: {data['device_os'] or 'Not provided'}
‚Ä¢ Page URL: {data['page_url'] or 'Not provided'}
‚Ä¢ User Agent: {request_info['user_agent']}
‚Ä¢ IP Address: {request_info['ip_address']}

üìé Screenshots: {len(uploaded_files)} file(s) attached
            """.strip()
            
            # Create support ticket
            ticket = self.SupportTicket(
                ticket_number=ticket_number,
                subject=f"[BUG REPORT] {data['issue_title']}",
                description=detailed_description,
                user_id=user.id if user else None,
                user_email=data['email'],
                user_name=data['name'],
                category_id=tech_category.id if tech_category else 1,
                ticket_type='bug_report',
                priority=priority,
                status='open',
                sla_deadline=self._calculate_sla_deadline(priority),
                **request_info
            )
            
            self.db.session.add(ticket)
            self.db.session.flush()
            
            # Link issue report to ticket
            issue_report.ticket_id = ticket.id
            
            # Add activity log
            activity = self.TicketActivity(
                ticket_id=ticket.id,
                action='created',
                description=f'Issue report submitted by {data["name"]} - {data["issue_type"]} ({data["severity"]} severity)',
                actor_type='user',
                actor_id=user.id if user else None,
                actor_name=data['name']
            )
            self.db.session.add(activity)
            
            self.db.session.commit()
            
            # Send notifications
            self._send_user_confirmation(issue_report, ticket, data)
            self._send_admin_notification(issue_report, ticket, data)
            
            logger.info(f"‚úÖ Issue report {issue_id} submitted by {data['email']}")
            
            return jsonify({
                'success': True,
                'message': 'Issue report submitted successfully. Thank you for helping us improve CineBrain!',
                'issue_id': issue_id,
                'ticket_number': ticket_number,
                'files_uploaded': len(uploaded_files)
            }), 201
            
        except Exception as e:
            self.db.session.rollback()
            logger.error(f"‚ùå Error processing issue report: {e}")
            return jsonify({'error': 'Failed to submit issue report. Please try again.'}), 500
    
    def _generate_ticket_number(self):
        """Generate unique ticket number"""
        import random
        import string
        
        date_str = datetime.now().strftime('%Y%m%d')
        random_str = ''.join(random.choices(string.digits, k=4))
        ticket_number = f"CB-{date_str}-{random_str}"
        
        # Ensure uniqueness
        while self.SupportTicket.query.filter_by(ticket_number=ticket_number).first():
            random_str = ''.join(random.choices(string.digits, k=4))
            ticket_number = f"CB-{date_str}-{random_str}"
        
        return ticket_number
    
    def _calculate_sla_deadline(self, priority_str):
        """Calculate SLA deadline based on priority string"""
        from datetime import timedelta
        
        now = datetime.utcnow()
        sla_hours = {
            'urgent': 4,
            'high': 24,
            'normal': 48,
            'low': 72
        }
        
        hours = sla_hours.get(priority_str, 48)
        return now + timedelta(hours=hours)
    
    def _check_rate_limit(self, email: str) -> bool:
        """Check rate limit for issue reports"""
        if not self.redis_client:
            return True
        
        try:
            key = f"issue_rate_limit:{email}"
            current = self.redis_client.get(key)
            
            if current is None:
                self.redis_client.setex(key, 900, 1)  # 15 minutes
                return True
            
            if int(current) >= 5:  # Max 5 reports per 15 minutes
                return False
            
            self.redis_client.incr(key)
            return True
            
        except Exception as e:
            logger.error(f"Rate limit check error: {e}")
            return True
    
    def _send_user_confirmation(self, issue_report, ticket, data):
        """Send confirmation email to user"""
        try:
            if not self.email_service:
                logger.warning("Email service not available - cannot send user confirmation")
                return
            
            from auth.support_mail_templates import get_support_template
            
            html, text = get_support_template(
                'issue_reported',
                user_name=data['name'],
                issue_title=data['issue_title'],
                issue_type=data['issue_type'].replace('_', ' ').title(),
                severity=data['severity'],
                ticket_number=ticket.ticket_number
            )
            
            self.email_service.queue_email(
                to=data['email'],
                subject=f"Issue Report Received #{ticket.ticket_number} - CineBrain",
                html=html,
                text=text,
                priority='high',
                to_name=data['name']
            )
            
            logger.info(f"‚úÖ Issue confirmation email queued for {data['email']}")
            
        except Exception as e:
            logger.error(f"‚ùå Error sending issue confirmation: {e}")
    
    def _send_admin_notification(self, issue_report, ticket, data):
        """Send admin notification email"""
        try:
            if not self.email_service:
                logger.warning("Email service not available - cannot send admin notification")
                return
            
            admin_email = os.environ.get('ADMIN_EMAIL', 'srinathnulidonda.dev@gmail.com')
            admin_link = f"{os.environ.get('FRONTEND_URL', 'https://cinebrain.vercel.app')}/admin/support/issue/{issue_report.issue_id}"
            
            from auth.support_mail_templates import get_support_template
            
            # Prepare screenshot info
            screenshot_info = ""
            if issue_report.screenshots:
                screenshot_info = f"""
                <p><strong>üì∏ Screenshots ({len(issue_report.screenshots)} files):</strong></p>
                <ul>
                """
                for i, screenshot in enumerate(issue_report.screenshots, 1):
                    screenshot_info += f"""
                    <li><a href="{screenshot['url']}" target="_blank">{screenshot['original_filename']}</a> 
                    ({screenshot.get('bytes', 0) // 1024}KB, {screenshot.get('format', 'unknown').upper()})</li>
                    """
                screenshot_info += "</ul>"
            
            html, text = get_support_template(
                'admin_notification',
                notification_type='issue_report',
                title=f"üêõ New Issue Report: {data['issue_title']}",
                message=f"""
                <p><strong>New issue report submitted:</strong></p>
                <ul>
                    <li><strong>Ticket:</strong> #{ticket.ticket_number}</li>
                    <li><strong>Issue ID:</strong> {issue_report.issue_id}</li>
                    <li><strong>From:</strong> {data['name']} ({data['email']})</li>
                    <li><strong>Type:</strong> {data['issue_type'].replace('_', ' ').title()}</li>
                    <li><strong>Severity:</strong> <span style="color: {'#ef4444' if data['severity'] == 'critical' else '#f59e0b' if data['severity'] == 'high' else '#3b82f6'}; font-weight: bold;">{data['severity'].upper()}</span></li>
                    <li><strong>Browser:</strong> {data.get('browser_version', 'Not provided')}</li>
                    <li><strong>Device/OS:</strong> {data.get('device_os', 'Not provided')}</li>
                    <li><strong>Page URL:</strong> {data.get('page_url', 'Not provided')}</li>
                </ul>
                
                <p><strong>üìù Description:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid #ef4444; margin: 15px 0;">
                    {data['description']}
                </div>
                
                {f'''
                <p><strong>üîÑ Steps to Reproduce:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid #3b82f6; margin: 15px 0;">
                    {data['steps_to_reproduce']}
                </div>
                ''' if data.get('steps_to_reproduce') else ''}
                
                {f'''
                <p><strong>‚úÖ Expected Behavior:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid #10b981; margin: 15px 0;">
                    {data['expected_behavior']}
                </div>
                ''' if data.get('expected_behavior') else ''}
                
                {screenshot_info}
                
                <p style="margin-top: 20px;">
                    <a href="{admin_link}" style="background: #113CCF; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block;">
                        View in Admin Dashboard
                    </a>
                </p>
                """,
                ticket_number=ticket.ticket_number,
                user_email=data['email']
            )
            
            priority = 'urgent' if data['severity'] in ['critical', 'high'] else 'high'
            
            self.email_service.queue_email(
                to=admin_email,
                subject=f"üö® New Issue Report: {data['issue_title']} - CineBrain Admin",
                html=html,
                text=text,
                priority=priority,
                to_name='CineBrain Admin'
            )
            
            logger.info(f"‚úÖ Admin notification email queued for issue {issue_report.issue_id}")
            
        except Exception as e:
            logger.error(f"‚ùå Error sending admin notification: {e}")

def init_issue_service(app, db, models, services):
    """Initialize issue service"""
    return IssueReportService(app, db, models, services)



4. # support/routes.py

from flask import Blueprint, request, jsonify
from datetime import datetime
import logging
import jwt
import os
from functools import wraps

logger = logging.getLogger(__name__)

support_bp = Blueprint('support', __name__)

# Global services - will be initialized by init_support_routes
ticket_service = None
contact_service = None
issue_service = None
app = None
db = None
User = None
cache = None

def get_user_from_token():
    """Extract user from JWT token"""
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return None
    
    token = auth_header.split(' ')[1]
    try:
        payload = jwt.decode(token, app.secret_key, algorithms=['HS256'])
        return User.query.get(payload.get('user_id'))
    except:
        return None

def admin_required(f):
    """Decorator for admin-only endpoints"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user = get_user_from_token()
        if not user or not getattr(user, 'is_admin', False):
            return jsonify({'error': 'Admin access required'}), 403
        return f(*args, **kwargs)
    return decorated_function

# Health and Info Routes
@support_bp.route('/api/support/health', methods=['GET'])
def support_health():
    """Support service health check"""
    try:
        # Test database connection
        if db and User:
            User.query.limit(1).first()
        
        # Check service availability
        services_status = {
            'tickets': ticket_service is not None,
            'contact': contact_service is not None,
            'issues': issue_service is not None
        }
        
        # Get environment status
        env_status = {
            'frontend_url': bool(os.environ.get('FRONTEND_URL')),
            'admin_email': bool(os.environ.get('ADMIN_EMAIL')),
            'cloudinary_configured': all([
                os.environ.get('CLOUDINARY_CLOUD_NAME'),
                os.environ.get('CLOUDINARY_API_KEY'),
                os.environ.get('CLOUDINARY_API_SECRET')
            ])
        }
        
        # Get database stats
        db_stats = {}
        try:
            if 'SupportTicket' in globals():
                SupportTicket = globals()['SupportTicket']
                db_stats = {
                    'total_tickets': SupportTicket.query.count(),
                    'open_tickets': SupportTicket.query.filter_by(status='open').count(),
                    'resolved_tickets': SupportTicket.query.filter_by(status='resolved').count()
                }
        except:
            db_stats = {'error': 'Could not fetch database stats'}
        
        return jsonify({
            'status': 'healthy',
            'service': 'support',
            'version': '2.0.0',
            'services': services_status,
            'environment': env_status,
            'database': db_stats,
            'features': {
                'ticket_management': True,
                'contact_forms': True,
                'issue_reporting': True,
                'file_uploads': True,
                'email_notifications': True,
                'admin_integration': True,
                'rate_limiting': True
            },
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Support health check error: {e}")
        return jsonify({
            'status': 'unhealthy',
            'service': 'support',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@support_bp.route('/api/support/stats', methods=['GET'])
@admin_required
def get_support_stats():
    """Get support statistics for admin dashboard"""
    try:
        stats = {}
        
        # Get ticket stats
        if ticket_service and 'SupportTicket' in globals():
            SupportTicket = globals()['SupportTicket']
            
            # Basic counts
            stats['tickets'] = {
                'total': SupportTicket.query.count(),
                'open': SupportTicket.query.filter_by(status='open').count(),
                'in_progress': SupportTicket.query.filter_by(status='in_progress').count(),
                'resolved': SupportTicket.query.filter_by(status='resolved').count(),
                'closed': SupportTicket.query.filter_by(status='closed').count()
            }
            
            # Priority breakdown
            stats['priority'] = {
                'urgent': SupportTicket.query.filter_by(priority='urgent').count(),
                'high': SupportTicket.query.filter_by(priority='high').count(),
                'normal': SupportTicket.query.filter_by(priority='normal').count(),
                'low': SupportTicket.query.filter_by(priority='low').count()
            }
            
            # Recent tickets (last 7 days)
            from datetime import timedelta
            week_ago = datetime.utcnow() - timedelta(days=7)
            stats['recent'] = {
                'this_week': SupportTicket.query.filter(
                    SupportTicket.created_at >= week_ago
                ).count(),
                'overdue': SupportTicket.query.filter(
                    SupportTicket.sla_deadline < datetime.utcnow(),
                    SupportTicket.status.in_(['open', 'in_progress'])
                ).count()
            }
        
        # Get contact message stats
        if contact_service and 'ContactMessage' in globals():
            ContactMessage = globals()['ContactMessage']
            stats['contact'] = {
                'total': ContactMessage.query.count(),
                'unread': ContactMessage.query.filter_by(is_read=False).count()
            }
        
        # Get issue report stats
        if issue_service and 'IssueReport' in globals():
            IssueReport = globals()['IssueReport']
            stats['issues'] = {
                'total': IssueReport.query.count(),
                'unresolved': IssueReport.query.filter_by(is_resolved=False).count(),
                'critical': IssueReport.query.filter_by(severity='critical').count()
            }
        
        return jsonify({
            'success': True,
            'stats': stats,
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching support stats: {e}")
        return jsonify({'error': 'Failed to fetch support statistics'}), 500

# Ticket Routes
@support_bp.route('/api/support/tickets', methods=['POST', 'OPTIONS'])
def create_ticket():
    """Create a new support ticket"""
    if request.method == 'OPTIONS':
        return '', 200
    
    if not ticket_service:
        return jsonify({'error': 'Ticket service not available'}), 503
    
    return ticket_service.create_ticket()

@support_bp.route('/api/support/tickets/<ticket_number>', methods=['GET'])
def get_ticket(ticket_number):
    """Get ticket by number"""
    if not ticket_service:
        return jsonify({'error': 'Ticket service not available'}), 503
    
    return ticket_service.get_ticket(ticket_number)

@support_bp.route('/api/support/tickets', methods=['GET'])
@admin_required
def list_tickets():
    """List all tickets for admin"""
    try:
        if not ticket_service or 'SupportTicket' not in globals():
            return jsonify({'error': 'Ticket service not available'}), 503
        
        SupportTicket = globals()['SupportTicket']
        SupportCategory = globals()['SupportCategory']
        
        # Get query parameters
        status = request.args.get('status')
        priority = request.args.get('priority')
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 25)), 100)
        search = request.args.get('search', '').strip()
        
        # Build query
        query = SupportTicket.query
        
        if status:
            query = query.filter_by(status=status)
        
        if priority:
            query = query.filter_by(priority=priority)
        
        if search:
            query = query.filter(
                db.or_(
                    SupportTicket.ticket_number.contains(search),
                    SupportTicket.subject.contains(search),
                    SupportTicket.user_email.contains(search),
                    SupportTicket.user_name.contains(search)
                )
            )
        
        # Order by created_at desc
        query = query.order_by(SupportTicket.created_at.desc())
        
        # Paginate
        pagination = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        tickets = []
        for ticket in pagination.items:
            category = SupportCategory.query.get(ticket.category_id)
            tickets.append({
                'id': ticket.id,
                'ticket_number': ticket.ticket_number,
                'subject': ticket.subject,
                'status': ticket.status,
                'priority': ticket.priority,
                'ticket_type': ticket.ticket_type,
                'user_name': ticket.user_name,
                'user_email': ticket.user_email,
                'category': {
                    'id': category.id,
                    'name': category.name,
                    'icon': category.icon
                } if category else None,
                'created_at': ticket.created_at.isoformat(),
                'sla_deadline': ticket.sla_deadline.isoformat() if ticket.sla_deadline else None,
                'sla_breached': ticket.sla_breached,
                'first_response_at': ticket.first_response_at.isoformat() if ticket.first_response_at else None
            })
        
        return jsonify({
            'success': True,
            'tickets': tickets,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error listing tickets: {e}")
        return jsonify({'error': 'Failed to fetch tickets'}), 500

@support_bp.route('/api/support/tickets/<int:ticket_id>/status', methods=['PUT'])
@admin_required
def update_ticket_status(ticket_id):
    """Update ticket status"""
    try:
        if not ticket_service or 'SupportTicket' not in globals():
            return jsonify({'error': 'Ticket service not available'}), 503
        
        data = request.get_json()
        new_status = data.get('status')
        update_message = data.get('message', '')
        
        if not new_status:
            return jsonify({'error': 'Status is required'}), 400
        
        SupportTicket = globals()['SupportTicket']
        TicketActivity = globals()['TicketActivity']
        
        ticket = SupportTicket.query.get_or_404(ticket_id)
        old_status = ticket.status
        
        # Update status
        ticket.status = new_status
        
        # Update timestamps based on status
        if new_status == 'resolved' and not ticket.resolved_at:
            ticket.resolved_at = datetime.utcnow()
        elif new_status == 'closed' and not ticket.closed_at:
            ticket.closed_at = datetime.utcnow()
        
        # Add activity
        user = get_user_from_token()
        activity = TicketActivity(
            ticket_id=ticket.id,
            action='status_updated',
            description=f'Status changed from {old_status} to {new_status}',
            old_value=old_status,
            new_value=new_status,
            actor_type='admin',
            actor_id=user.id,
            actor_name=user.username
        )
        
        db.session.add(activity)
        db.session.commit()
        
        # Send status update email to user
        try:
            from auth.service import email_service
            from auth.support_mail_templates import get_support_template
            
            if email_service:
                html, text = get_support_template(
                    'ticket_status_updated',
                    ticket_number=ticket.ticket_number,
                    user_name=ticket.user_name,
                    old_status=old_status,
                    new_status=new_status,
                    update_message=update_message,
                    staff_name=user.username
                )
                
                email_service.queue_email(
                    to=ticket.user_email,
                    subject=f"Ticket Status Updated #{ticket.ticket_number} - CineBrain",
                    html=html,
                    text=text,
                    priority='high',
                    to_name=ticket.user_name
                )
        except Exception as e:
            logger.warning(f"Failed to send status update email: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Ticket status updated successfully',
            'ticket': {
                'id': ticket.id,
                'ticket_number': ticket.ticket_number,
                'status': ticket.status,
                'updated_at': datetime.utcnow().isoformat()
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error updating ticket status: {e}")
        return jsonify({'error': 'Failed to update ticket status'}), 500

# Contact Routes
@support_bp.route('/api/support/contact', methods=['POST', 'OPTIONS'])
def submit_contact():
    """Submit contact form"""
    if request.method == 'OPTIONS':
        return '', 200
    
    if not contact_service:
        return jsonify({'error': 'Contact service not available'}), 503
    
    return contact_service.submit_contact()

@support_bp.route('/api/support/contact/messages', methods=['GET'])
@admin_required
def list_contact_messages():
    """List contact messages for admin"""
    try:
        if not contact_service or 'ContactMessage' not in globals():
            return jsonify({'error': 'Contact service not available'}), 503
        
        ContactMessage = globals()['ContactMessage']
        
        # Get query parameters
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 25)), 100)
        unread_only = request.args.get('unread_only', 'false').lower() == 'true'
        search = request.args.get('search', '').strip()
        
        # Build query
        query = ContactMessage.query
        
        if unread_only:
            query = query.filter_by(is_read=False)
        
        if search:
            query = query.filter(
                db.or_(
                    ContactMessage.name.contains(search),
                    ContactMessage.email.contains(search),
                    ContactMessage.subject.contains(search)
                )
            )
        
        # Order by created_at desc
        query = query.order_by(ContactMessage.created_at.desc())
        
        # Paginate
        pagination = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        messages = []
        for message in pagination.items:
            messages.append({
                'id': message.id,
                'name': message.name,
                'email': message.email,
                'subject': message.subject,
                'message': message.message,
                'phone': message.phone,
                'company': message.company,
                'is_read': message.is_read,
                'admin_notes': message.admin_notes,
                'created_at': message.created_at.isoformat(),
                'ip_address': message.ip_address
            })
        
        return jsonify({
            'success': True,
            'messages': messages,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error listing contact messages: {e}")
        return jsonify({'error': 'Failed to fetch contact messages'}), 500

@support_bp.route('/api/support/contact/messages/<int:message_id>/read', methods=['PUT'])
@admin_required
def mark_message_read(message_id):
    """Mark contact message as read"""
    try:
        if 'ContactMessage' not in globals():
            return jsonify({'error': 'Contact service not available'}), 503
        
        ContactMessage = globals()['ContactMessage']
        message = ContactMessage.query.get_or_404(message_id)
        
        message.is_read = True
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Message marked as read'
        }), 200
        
    except Exception as e:
        logger.error(f"Error marking message as read: {e}")
        return jsonify({'error': 'Failed to update message status'}), 500

# Issue Report Routes
@support_bp.route('/api/support/report-issue', methods=['POST', 'OPTIONS'])
def report_issue():
    """Report an issue with file uploads"""
    if request.method == 'OPTIONS':
        return '', 200
    
    if not issue_service:
        return jsonify({'error': 'Issue service not available'}), 503
    
    return issue_service.report_issue()

@support_bp.route('/api/support/issues', methods=['GET'])
@admin_required
def list_issues():
    """List issue reports for admin"""
    try:
        if not issue_service or 'IssueReport' not in globals():
            return jsonify({'error': 'Issue service not available'}), 503
        
        IssueReport = globals()['IssueReport']
        
        # Get query parameters
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 25)), 100)
        severity = request.args.get('severity')
        unresolved_only = request.args.get('unresolved_only', 'false').lower() == 'true'
        search = request.args.get('search', '').strip()
        
        # Build query
        query = IssueReport.query
        
        if severity:
            query = query.filter_by(severity=severity)
        
        if unresolved_only:
            query = query.filter_by(is_resolved=False)
        
        if search:
            query = query.filter(
                db.or_(
                    IssueReport.issue_id.contains(search),
                    IssueReport.issue_title.contains(search),
                    IssueReport.email.contains(search),
                    IssueReport.name.contains(search)
                )
            )
        
        # Order by severity (critical first) then created_at desc
        severity_order = {
            'critical': 0,
            'high': 1,
            'normal': 2,
            'low': 3
        }
        
        query = query.order_by(
            db.case(severity_order, value=IssueReport.severity),
            IssueReport.created_at.desc()
        )
        
        # Paginate
        pagination = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        issues = []
        for issue in pagination.items:
            issues.append({
                'id': issue.id,
                'issue_id': issue.issue_id,
                'name': issue.name,
                'email': issue.email,
                'issue_type': issue.issue_type,
                'severity': issue.severity,
                'issue_title': issue.issue_title,
                'description': issue.description[:200] + '...' if len(issue.description) > 200 else issue.description,
                'browser_version': issue.browser_version,
                'device_os': issue.device_os,
                'page_url_reported': issue.page_url_reported,
                'screenshots': issue.screenshots,
                'ticket_id': issue.ticket_id,
                'is_resolved': issue.is_resolved,
                'created_at': issue.created_at.isoformat(),
                'resolved_at': issue.resolved_at.isoformat() if issue.resolved_at else None
            })
        
        return jsonify({
            'success': True,
            'issues': issues,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error listing issues: {e}")
        return jsonify({'error': 'Failed to fetch issues'}), 500

@support_bp.route('/api/support/issues/<int:issue_id>/resolve', methods=['PUT'])
@admin_required
def resolve_issue(issue_id):
    """Mark issue as resolved"""
    try:
        if 'IssueReport' not in globals():
            return jsonify({'error': 'Issue service not available'}), 503
        
        data = request.get_json()
        admin_notes = data.get('admin_notes', '')
        
        IssueReport = globals()['IssueReport']
        issue = IssueReport.query.get_or_404(issue_id)
        
        issue.is_resolved = True
        issue.resolved_at = datetime.utcnow()
        issue.admin_notes = admin_notes
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Issue marked as resolved'
        }), 200
        
    except Exception as e:
        logger.error(f"Error resolving issue: {e}")
        return jsonify({'error': 'Failed to resolve issue'}), 500

# Support Categories Routes
@support_bp.route('/api/support/categories', methods=['GET'])
def get_support_categories():
    """Get support categories"""
    try:
        if 'SupportCategory' not in globals():
            # Return default categories if not in database
            default_categories = [
                {'id': 1, 'name': 'Account & Login', 'description': 'Issues with account creation, login, password reset', 'icon': 'üë§'},
                {'id': 2, 'name': 'Technical Issues', 'description': 'App crashes, loading issues, performance problems', 'icon': 'üîß'},
                {'id': 3, 'name': 'Features & Functions', 'description': 'How to use features, feature requests', 'icon': '‚ö°'},
                {'id': 4, 'name': 'Content & Recommendations', 'description': 'Issues with movies, shows, recommendations', 'icon': 'üé¨'},
                {'id': 5, 'name': 'General Support', 'description': 'Other questions and general inquiries', 'icon': '‚ùì'}
            ]
            return jsonify({'categories': default_categories}), 200
        
        SupportCategory = globals()['SupportCategory']
        categories = SupportCategory.query.filter_by(is_active=True).order_by(SupportCategory.sort_order).all()
        
        return jsonify({
            'categories': [
                {
                    'id': cat.id,
                    'name': cat.name,
                    'description': cat.description,
                    'icon': cat.icon
                }
                for cat in categories
            ]
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching categories: {e}")
        return jsonify({'error': 'Failed to retrieve categories'}), 500

# Admin Management Routes
@support_bp.route('/api/support/dashboard', methods=['GET'])
@admin_required
def get_admin_dashboard():
    """Get admin dashboard data"""
    try:
        dashboard_data = {}
        
        # Recent tickets
        if 'SupportTicket' in globals():
            SupportTicket = globals()['SupportTicket']
            SupportCategory = globals()['SupportCategory']
            
            recent_tickets = SupportTicket.query.order_by(
                SupportTicket.created_at.desc()
            ).limit(10).all()
            
            dashboard_data['recent_tickets'] = []
            for ticket in recent_tickets:
                category = SupportCategory.query.get(ticket.category_id) if SupportCategory else None
                dashboard_data['recent_tickets'].append({
                    'id': ticket.id,
                    'ticket_number': ticket.ticket_number,
                    'subject': ticket.subject,
                    'status': ticket.status,
                    'priority': ticket.priority,
                    'user_name': ticket.user_name,
                    'category': category.name if category else 'General',
                    'created_at': ticket.created_at.isoformat(),
                    'sla_breached': ticket.sla_breached
                })
        
        # Recent contact messages
        if 'ContactMessage' in globals():
            ContactMessage = globals()['ContactMessage']
            recent_messages = ContactMessage.query.filter_by(
                is_read=False
            ).order_by(ContactMessage.created_at.desc()).limit(5).all()
            
            dashboard_data['unread_messages'] = [
                {
                    'id': msg.id,
                    'name': msg.name,
                    'email': msg.email,
                    'subject': msg.subject,
                    'created_at': msg.created_at.isoformat()
                }
                for msg in recent_messages
            ]
        
        # Critical issues
        if 'IssueReport' in globals():
            IssueReport = globals()['IssueReport']
            critical_issues = IssueReport.query.filter(
                IssueReport.severity.in_(['critical', 'high']),
                IssueReport.is_resolved == False
            ).order_by(IssueReport.created_at.desc()).limit(5).all()
            
            dashboard_data['critical_issues'] = [
                {
                    'id': issue.id,
                    'issue_id': issue.issue_id,
                    'issue_title': issue.issue_title,
                    'severity': issue.severity,
                    'name': issue.name,
                    'created_at': issue.created_at.isoformat()
                }
                for issue in critical_issues
            ]
        
        return jsonify({
            'success': True,
            'dashboard': dashboard_data,
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching dashboard data: {e}")
        return jsonify({'error': 'Failed to fetch dashboard data'}), 500

# Webhook Routes - UPDATED to use admin notification service through existing services
@support_bp.route('/api/webhooks/support/ticket-created', methods=['POST'])
def webhook_ticket_created():
    """Handle ticket creation webhook"""
    try:
        data = request.get_json()
        ticket_id = data.get('ticket_id')
        
        if ticket_id and 'SupportTicket' in globals():
            SupportTicket = globals()['SupportTicket']
            ticket = SupportTicket.query.get(ticket_id)
            if ticket and ticket_service:
                # Use the ticket service's admin notification service
                try:
                    if hasattr(ticket_service, 'admin_notification_service') and ticket_service.admin_notification_service:
                        ticket_service.admin_notification_service.notify_new_ticket(ticket)
                    else:
                        logger.warning("Admin notification service not available for webhook")
                except Exception as e:
                    logger.error(f"CineBrain error handling new ticket notification: {e}")
        
        return jsonify({'success': True, 'cinebrain_service': 'support_webhook'}), 200
    except Exception as e:
        logger.error(f"CineBrain webhook error: {e}")
        return jsonify({'error': 'CineBrain webhook processing failed'}), 500

@support_bp.route('/api/webhooks/support/feedback-created', methods=['POST'])
def webhook_feedback_created():
    """Handle feedback creation webhook"""
    try:
        data = request.get_json()
        feedback_id = data.get('feedback_id')
        
        if feedback_id and 'ContactMessage' in globals():
            ContactMessage = globals()['ContactMessage']
            feedback = ContactMessage.query.get(feedback_id)
            if feedback and contact_service:
                # Use the contact service's admin notification service
                try:
                    if hasattr(contact_service, 'admin_notification_service') and contact_service.admin_notification_service:
                        contact_service.admin_notification_service.notify_feedback_received(feedback)
                    else:
                        logger.warning("Admin notification service not available for webhook")
                except Exception as e:
                    logger.error(f"CineBrain error handling new feedback notification: {e}")
        
        return jsonify({'success': True, 'cinebrain_service': 'support_webhook'}), 200
    except Exception as e:
        logger.error(f"CineBrain feedback webhook error: {e}")
        return jsonify({'error': 'CineBrain webhook processing failed'}), 500

# Error Handlers
@support_bp.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Support endpoint not found'}), 404

@support_bp.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error in support service'}), 500

# CORS Headers
@support_bp.after_request
def after_request(response):
    """Add CORS headers"""
    origin = request.headers.get('Origin')
    allowed_origins = [
        'https://cinebrain.vercel.app',
        'http://127.0.0.1:5500', 
        'http://127.0.0.1:5501',
        'http://localhost:3000',
        'http://localhost:5173'
    ]
    
    if origin in allowed_origins:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type,Authorization'
        response.headers['Access-Control-Allow-Methods'] = 'GET,PUT,POST,DELETE,OPTIONS'
        response.headers['Access-Control-Allow-Credentials'] = 'true'
    
    return response

# Initialization Function
def init_support_routes(flask_app, database, models, services):
    """Initialize support routes with dependencies"""
    global ticket_service, contact_service, issue_service, app, db, User, cache
    
    app = flask_app
    db = database
    User = models.get('User')
    cache = services.get('cache')
    
    # Make models available globally for the routes
    for model_name, model_class in models.items():
        if model_name.startswith('Support') or model_name in ['ContactMessage', 'IssueReport', 'TicketActivity']:
            globals()[model_name] = model_class
    
    # Initialize individual services
    try:
        from .tickets import init_ticket_service
        from .contact import init_contact_service
        from .report_issues import init_issue_service
        
        ticket_service = init_ticket_service(app, db, models, services)
        contact_service = init_contact_service(app, db, models, services)
        issue_service = init_issue_service(app, db, models, services)
        
        logger.info("‚úÖ Support routes initialized successfully")
        logger.info(f"   - Ticket service: {'‚úì' if ticket_service else '‚úó'}")
        logger.info(f"   - Contact service: {'‚úì' if contact_service else '‚úó'}")
        logger.info(f"   - Issue service: {'‚úì' if issue_service else '‚úó'}")
        
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize support routes: {e}")
        raise e



5. # support/tickets.py

from flask import request, jsonify
from datetime import datetime, timedelta
from sqlalchemy import func, desc, and_, or_
import jwt
import logging
import json
import enum
import os
from typing import Dict, Optional, List

logger = logging.getLogger(__name__)

# Keep enum definitions for type checking and validation
class TicketStatus(enum.Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    WAITING_FOR_USER = "waiting_for_user"
    RESOLVED = "resolved"
    CLOSED = "closed"

class TicketPriority(enum.Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class TicketType(enum.Enum):
    GENERAL = "general"
    TECHNICAL = "technical"
    ACCOUNT = "account"
    BILLING = "billing"
    FEATURE_REQUEST = "feature_request"
    BUG_REPORT = "bug_report"

class TicketService:
    def __init__(self, app, db, models, services):
        self.app = app
        self.db = db
        self.User = models['User']
        self.SupportTicket = models['SupportTicket']
        self.SupportCategory = models['SupportCategory']
        self.TicketActivity = models['TicketActivity']
        
        # Enhanced email service initialization
        self.email_service = self._initialize_email_service(services)
        self.redis_client = services.get('redis_client')
        
        # Get admin notification service if available
        self.admin_notification_service = services.get('admin_notification_service')
        
        logger.info("‚úÖ TicketService initialized successfully")
    
    def _initialize_email_service(self, services):
        """Initialize email service with fallbacks"""
        email_service = services.get('email_service')
        if email_service:
            return email_service
        
        # Try to get from auth module
        try:
            from auth.service import email_service as auth_email_service
            if auth_email_service and hasattr(auth_email_service, 'queue_email'):
                logger.info("‚úÖ Email service loaded from auth module")
                return auth_email_service
        except Exception as e:
            logger.warning(f"Could not load auth email service: {e}")
        
        logger.warning("‚ö†Ô∏è No email service available for tickets")
        return None
        
    def generate_ticket_number(self) -> str:
        """Generate unique ticket number"""
        import random
        import string
        
        date_str = datetime.now().strftime('%Y%m%d')
        random_str = ''.join(random.choices(string.digits, k=4))
        ticket_number = f"CB-{date_str}-{random_str}"
        
        # Ensure uniqueness
        while self.SupportTicket.query.filter_by(ticket_number=ticket_number).first():
            random_str = ''.join(random.choices(string.digits, k=4))
            ticket_number = f"CB-{date_str}-{random_str}"
        
        return ticket_number
    
    def calculate_sla_deadline(self, priority: TicketPriority) -> datetime:
        """Calculate SLA deadline based on priority enum"""
        now = datetime.utcnow()
        
        sla_hours = {
            TicketPriority.URGENT: 4,
            TicketPriority.HIGH: 24,
            TicketPriority.NORMAL: 48,
            TicketPriority.LOW: 72
        }
        
        hours = sla_hours.get(priority, 48)
        return now + timedelta(hours=hours)
    
    def calculate_sla_deadline_string(self, priority_str: str) -> datetime:
        """Calculate SLA deadline based on priority string"""
        now = datetime.utcnow()
        
        sla_hours = {
            'urgent': 4,
            'high': 24,
            'normal': 48,
            'low': 72
        }
        
        hours = sla_hours.get(priority_str, 48)
        return now + timedelta(hours=hours)
    
    def get_user_from_token(self):
        """Extract user from JWT token"""
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None
        
        token = auth_header.split(' ')[1]
        try:
            payload = jwt.decode(token, self.app.secret_key, algorithms=['HS256'])
            return self.User.query.get(payload.get('user_id'))
        except:
            return None
    
    def get_request_info(self):
        """Extract request information"""
        ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ip_address:
            ip_address = ip_address.split(',')[0].strip()
        
        user_agent = request.headers.get('User-Agent', 'Unknown')
        
        return {
            'ip_address': ip_address,
            'user_agent': user_agent,
            'page_url': request.headers.get('Referer', ''),
            'browser_info': self._parse_user_agent(user_agent)
        }
    
    def _parse_user_agent(self, user_agent: str) -> str:
        """Parse user agent into readable format"""
        if not user_agent or user_agent == 'Unknown':
            return 'Unknown Browser'
        
        browsers = {
            'Chrome': 'Google Chrome',
            'Firefox': 'Mozilla Firefox',
            'Safari': 'Apple Safari',
            'Edge': 'Microsoft Edge',
            'Opera': 'Opera'
        }
        
        for key, value in browsers.items():
            if key in user_agent:
                return value
        
        return 'Unknown Browser'
    
    def create_ticket(self):
        """Create a new support ticket with enhanced error handling - FIXED"""
        try:
            data = request.get_json()
            
            # Validate required fields
            required_fields = ['subject', 'message', 'name', 'email', 'category_id']
            for field in required_fields:
                if not data.get(field):
                    return jsonify({'error': f'{field.replace("_", " ").title()} is required'}), 400
            
            # Rate limiting check
            if not self._check_rate_limit(data['email']):
                return jsonify({'error': 'Too many requests. Please try again later.'}), 429
            
            user = self.get_user_from_token()
            request_info = self.get_request_info()
            
            # Generate ticket number
            ticket_number = self.generate_ticket_number()
            
            # Use string values directly to avoid enum issues
            priority_value = data.get('priority', 'normal')
            ticket_type_value = data.get('ticket_type', 'general')
            
            # FIXED: Validate and map ticket type values
            valid_priorities = ['low', 'normal', 'high', 'urgent']
            valid_types = ['general', 'technical', 'billing', 'feature_request', 'bug_report']
            
            # Map common variations to valid types
            type_mapping = {
                'account': 'general',  # Map 'account' to 'general'
                'login': 'technical',
                'payment': 'billing',
                'feature': 'feature_request',
                'bug': 'bug_report'
            }
            
            # Apply mapping if needed
            if ticket_type_value in type_mapping:
                ticket_type_value = type_mapping[ticket_type_value]
            
            # Ensure valid values
            if priority_value not in valid_priorities:
                priority_value = 'normal'
            if ticket_type_value not in valid_types:
                ticket_type_value = 'general'
            
            logger.info(f"Creating ticket with type: {ticket_type_value}, priority: {priority_value}")
            
            # Create ticket with string values
            ticket = self.SupportTicket(
                ticket_number=ticket_number,
                subject=data['subject'],
                description=data['message'],
                user_id=user.id if user else None,
                user_email=data['email'],
                user_name=data['name'],
                category_id=data['category_id'],
                ticket_type=ticket_type_value,  # Using mapped string value
                priority=priority_value,         # Using string value
                status='open',                   # Using string value
                sla_deadline=self.calculate_sla_deadline_string(priority_value),
                **request_info
            )
            
            self.db.session.add(ticket)
            self.db.session.flush()
            
            # Add activity log
            activity = self.TicketActivity(
                ticket_id=ticket.id,
                action='created',
                description=f'Ticket created by {data["name"]}',
                actor_type='user',
                actor_id=user.id if user else None,
                actor_name=data['name']
            )
            self.db.session.add(activity)
            self.db.session.commit()
            
            # Send notifications
            self._send_user_confirmation(ticket, data)
            self._send_admin_notification_enhanced(ticket, data)
            
            logger.info(f"‚úÖ Support ticket {ticket_number} created for {data['email']}")
            
            return jsonify({
                'success': True,
                'message': 'Support ticket created successfully. You will receive a confirmation email shortly.',
                'ticket_number': ticket_number,
                'ticket_id': ticket.id,
                'sla_deadline': ticket.sla_deadline.isoformat() if ticket.sla_deadline else None
            }), 201
            
        except Exception as e:
            self.db.session.rollback()
            logger.error(f"‚ùå Error creating support ticket: {e}")
            return jsonify({'error': 'Failed to create support ticket. Please try again.'}), 500
    
    def get_ticket(self, ticket_number):
        """Get ticket details by number"""
        try:
            user = self.get_user_from_token()
            
            # Build query
            query = self.SupportTicket.query.filter_by(ticket_number=ticket_number)
            
            # If not admin, only show user's own tickets
            if user and not getattr(user, 'is_admin', False):
                query = query.filter_by(user_id=user.id)
            elif not user:
                # For anonymous users, they need to provide email
                email = request.args.get('email')
                if not email:
                    return jsonify({'error': 'Email required for ticket access'}), 400
                query = query.filter_by(user_email=email)
            
            ticket = query.first()
            if not ticket:
                return jsonify({'error': 'Ticket not found'}), 404
            
            # Get category info
            category = self.SupportCategory.query.get(ticket.category_id)
            
            # Get activities
            activities = self.TicketActivity.query.filter_by(
                ticket_id=ticket.id
            ).order_by(self.TicketActivity.created_at.desc()).all()
            
            return jsonify({
                'ticket': {
                    'id': ticket.id,
                    'ticket_number': ticket.ticket_number,
                    'subject': ticket.subject,
                    'description': ticket.description,
                    'status': ticket.status,
                    'priority': ticket.priority,
                    'ticket_type': ticket.ticket_type,
                    'category': {
                        'id': category.id,
                        'name': category.name,
                        'icon': category.icon
                    } if category else None,
                    'user_name': ticket.user_name,
                    'user_email': ticket.user_email,
                    'created_at': ticket.created_at.isoformat(),
                    'sla_deadline': ticket.sla_deadline.isoformat() if ticket.sla_deadline else None,
                    'sla_breached': ticket.sla_breached,
                    'first_response_at': ticket.first_response_at.isoformat() if ticket.first_response_at else None,
                    'resolved_at': ticket.resolved_at.isoformat() if ticket.resolved_at else None,
                    'browser_info': ticket.browser_info,
                    'page_url': ticket.page_url
                },
                'activities': [
                    {
                        'id': activity.id,
                        'action': activity.action,
                        'description': activity.description,
                        'actor_type': activity.actor_type,
                        'actor_name': activity.actor_name,
                        'created_at': activity.created_at.isoformat()
                    }
                    for activity in activities
                ]
            }), 200
            
        except Exception as e:
            logger.error(f"‚ùå Error fetching ticket {ticket_number}: {e}")
            return jsonify({'error': 'Failed to fetch ticket'}), 500
    
    def _check_rate_limit(self, email: str) -> bool:
        """Check rate limit for ticket creation"""
        if not self.redis_client:
            return True
        
        try:
            key = f"ticket_rate_limit:{email}"
            current = self.redis_client.get(key)
            
            if current is None:
                self.redis_client.setex(key, 900, 1)  # 15 minutes
                return True
            
            if int(current) >= 3:  # Max 3 tickets per 15 minutes
                return False
            
            self.redis_client.incr(key)
            return True
            
        except Exception as e:
            logger.error(f"Rate limit check error: {e}")
            return True
    
    def _send_user_confirmation(self, ticket, data):
        """Send confirmation email to user"""
        try:
            if not self.email_service:
                logger.warning("Email service not available - cannot send user confirmation")
                return
            
            from auth.support_mail_templates import get_support_template
            
            category = self.SupportCategory.query.get(ticket.category_id)
            
            html, text = get_support_template(
                'ticket_created',
                ticket_number=ticket.ticket_number,
                user_name=data['name'],
                subject=ticket.subject,
                priority=ticket.priority,
                category=category.name if category else 'General Support'
            )
            
            self.email_service.queue_email(
                to=data['email'],
                subject=f"Support Ticket Created #{ticket.ticket_number} - CineBrain",
                html=html,
                text=text,
                priority='high',
                to_name=data['name']
            )
            
            logger.info(f"‚úÖ User confirmation email queued for {data['email']}")
            
        except Exception as e:
            logger.error(f"‚ùå Error sending user confirmation: {e}")
    
    def _send_admin_notification(self, ticket, data):
        """Send admin notification email - DEPRECATED, use enhanced version"""
        self._send_admin_notification_enhanced(ticket, data)
    
    def _send_admin_notification_enhanced(self, ticket, data):
        """Send enhanced admin notification email - FIXED"""
        try:
            # Try using admin notification service first
            if self.admin_notification_service and hasattr(self.admin_notification_service, 'notify_new_ticket'):
                try:
                    self.admin_notification_service.notify_new_ticket(ticket)
                    logger.info(f"‚úÖ Admin notification sent via notification service for ticket {ticket.ticket_number}")
                    return
                except Exception as e:
                    logger.warning(f"Admin notification service failed, using direct email: {e}")
            
            # Fallback to direct email if notification service not available
            if not self.email_service:
                logger.warning("Email service not available - cannot send admin notification")
                return
            
            # Get admin email(s)
            admin_emails = []
            
            # Add environment admin email
            env_admin_email = os.environ.get('ADMIN_EMAIL', 'srinathnulidonda.dev@gmail.com')
            if env_admin_email:
                admin_emails.append(env_admin_email)
            
            # Add database admin emails
            admin_users = self.User.query.filter_by(is_admin=True).all()
            for admin_user in admin_users:
                if admin_user.email and admin_user.email not in admin_emails:
                    admin_emails.append(admin_user.email)
            
            if not admin_emails:
                logger.warning("No admin emails configured for notifications")
                return
            
            from auth.support_mail_templates import get_support_template
            
            category = self.SupportCategory.query.get(ticket.category_id)
            
            # Add link to admin dashboard
            admin_link = f"{os.environ.get('FRONTEND_URL', 'https://cinebrain.vercel.app')}/admin/support/ticket/{ticket.ticket_number}"
            
            html, text = get_support_template(
                'admin_notification',
                notification_type='new_ticket',
                title=f"New Support Ticket #{ticket.ticket_number}",
                message=f"""
                <p><strong>New support ticket received:</strong></p>
                <ul>
                    <li><strong>Ticket:</strong> #{ticket.ticket_number}</li>
                    <li><strong>Subject:</strong> {ticket.subject}</li>
                    <li><strong>From:</strong> {data['name']} ({data['email']})</li>
                    <li><strong>Category:</strong> {category.name if category else 'General'}</li>
                    <li><strong>Priority:</strong> <span style="color: {'#ef4444' if ticket.priority == 'urgent' else '#281e0dff' if ticket.priority == 'high' else '#3b82f6'}; font-weight: bold;">{ticket.priority.upper()}</span></li>
                    <li><strong>Type:</strong> {ticket.ticket_type.replace('_', ' ').title()}</li>
                    <li><strong>Status:</strong> {ticket.status.upper()}</li>
                </ul>
                <p><strong>Message:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid #007bff; margin: 15px 0;">
                    {ticket.description}
                </div>
                <p style="margin-top: 20px;">
                    <a href="{admin_link}" style="background: #113CCF; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block;">
                        View in Admin Dashboard
                    </a>
                </p>
                """,
                ticket_number=ticket.ticket_number,
                user_email=data['email']
            )
            
            # Send to all admin emails
            for admin_email in admin_emails:
                try:
                    self.email_service.queue_email(
                        to=admin_email,
                        subject=f"üé´ New Support Ticket #{ticket.ticket_number} - CineBrain Admin",
                        html=html,
                        text=text,
                        priority='urgent' if ticket.priority == 'urgent' else 'high',
                        to_name='CineBrain Admin'
                    )
                    logger.info(f"‚úÖ Admin notification email queued for {admin_email}")
                except Exception as e:
                    logger.error(f"Failed to queue email for admin {admin_email}: {e}")
            
            logger.info(f"‚úÖ Admin notifications sent for ticket {ticket.ticket_number}")
            
        except Exception as e:
            logger.error(f"‚ùå Error sending admin notification: {e}")

def init_ticket_service(app, db, models, services):
    """Initialize ticket service"""
    return TicketService(app, db, models, services)